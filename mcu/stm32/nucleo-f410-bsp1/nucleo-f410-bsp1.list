
nucleo-f410-bsp1.out:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001c0:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001c2:	482c      	ldr	r0, [pc, #176]	; (8000274 <bloop+0x1a>)
                msr     PSP, r0
 80001c4:	f380 8809 	msr	PSP, r0

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001c8:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001cc:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 80001d0:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 80001d4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001d8:	6008      	str	r0, [r1, #0]
                dsb
 80001da:	f3bf 8f4f 	dsb	sy
                isb
 80001de:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 80001e2:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 80001e6:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 80001ea:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 80001ee:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]
                dsb
 80001f4:	f3bf 8f4f 	dsb	sy
                isb
 80001f8:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 80001fc:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000200:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000204:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 8000208:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800020c:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 800020e:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000210:	f380 8814 	msr	CONTROL, r0
                isb
 8000214:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000218:	f003 fe8a 	bl	8003f30 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800021c:	f003 fe90 	bl	8003f40 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000220:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000224:	4914      	ldr	r1, [pc, #80]	; (8000278 <bloop+0x1e>)
                ldr     r2, =__main_stack_end__
 8000226:	4a15      	ldr	r2, [pc, #84]	; (800027c <bloop+0x22>)

08000228 <msloop>:
msloop:
                cmp     r1, r2
 8000228:	4291      	cmp	r1, r2
                itt     lo
 800022a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800022c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000230:	e7fa      	bcc.n	8000228 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000232:	4913      	ldr	r1, [pc, #76]	; (8000280 <bloop+0x26>)
                ldr     r2, =__process_stack_end__
 8000234:	4a0f      	ldr	r2, [pc, #60]	; (8000274 <bloop+0x1a>)

08000236 <psloop>:
psloop:
                cmp     r1, r2
 8000236:	4291      	cmp	r1, r2
                itt     lo
 8000238:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800023a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800023e:	e7fa      	bcc.n	8000236 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000240:	4910      	ldr	r1, [pc, #64]	; (8000284 <bloop+0x2a>)
                ldr     r2, =_data_start
 8000242:	4a11      	ldr	r2, [pc, #68]	; (8000288 <bloop+0x2e>)
                ldr     r3, =_data_end
 8000244:	4b11      	ldr	r3, [pc, #68]	; (800028c <bloop+0x32>)

08000246 <dloop>:
dloop:
                cmp     r2, r3
 8000246:	429a      	cmp	r2, r3
                ittt    lo
 8000248:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800024a:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024e:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000252:	e7f8      	bcc.n	8000246 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000254:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000256:	490e      	ldr	r1, [pc, #56]	; (8000290 <bloop+0x36>)
                ldr     r2, =_bss_end
 8000258:	4a0e      	ldr	r2, [pc, #56]	; (8000294 <bloop+0x3a>)

0800025a <bloop>:
bloop:
                cmp     r1, r2
 800025a:	4291      	cmp	r1, r2
                itt     lo
 800025c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000262:	e7fa      	bcc.n	800025a <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000264:	f003 fe7c 	bl	8003f60 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000268:	f001 ff1a 	bl	80020a0 <__late_init>
                b       initloop
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800026c:	f001 fee0 	bl	8002030 <main>
                b       finiloop
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000270:	f003 be6e 	b.w	8003f50 <__default_exit>
                ldr     r0, =__process_stack_end__
 8000274:	20000800 	.word	0x20000800
                ldr     r1, =__main_stack_base__
 8000278:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 800027c:	20000400 	.word	0x20000400
                ldr     r1, =__process_stack_base__
 8000280:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 8000284:	080041c8 	.word	0x080041c8
                ldr     r2, =_data_start
 8000288:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 800028c:	20000868 	.word	0x20000868
                ldr     r1, =_bss_start
 8000290:	20000868 	.word	0x20000868
                ldr     r2, =_bss_end
 8000294:	200014e0 	.word	0x200014e0
	...

080002a0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 80002a4:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002a8:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002ac:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ae:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 80002b0:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002b8 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002b8:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002ba:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002be:	4628      	mov	r0, r5
                blx     r4
 80002c0:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002c2:	2000      	movs	r0, #0
                bl      chThdExit
 80002c4:	f003 fd34 	bl	8003d30 <chThdExit>

080002c8 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002c8:	f003 fc7a 	bl	8003bc0 <chSchDoReschedule>

080002cc <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002cc:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002ce:	e7fe      	b.n	80002ce <_port_exit_from_isr+0x2>

080002d0 <memcpy>:
 80002d0:	4684      	mov	ip, r0
 80002d2:	ea41 0300 	orr.w	r3, r1, r0
 80002d6:	f013 0303 	ands.w	r3, r3, #3
 80002da:	d16d      	bne.n	80003b8 <memcpy+0xe8>
 80002dc:	3a40      	subs	r2, #64	; 0x40
 80002de:	d341      	bcc.n	8000364 <memcpy+0x94>
 80002e0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e4:	f840 3b04 	str.w	r3, [r0], #4
 80002e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ec:	f840 3b04 	str.w	r3, [r0], #4
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	f851 3b04 	ldr.w	r3, [r1], #4
 800030c:	f840 3b04 	str.w	r3, [r0], #4
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	f851 3b04 	ldr.w	r3, [r1], #4
 800031c:	f840 3b04 	str.w	r3, [r0], #4
 8000320:	f851 3b04 	ldr.w	r3, [r1], #4
 8000324:	f840 3b04 	str.w	r3, [r0], #4
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	3a40      	subs	r2, #64	; 0x40
 8000362:	d2bd      	bcs.n	80002e0 <memcpy+0x10>
 8000364:	3230      	adds	r2, #48	; 0x30
 8000366:	d311      	bcc.n	800038c <memcpy+0xbc>
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	3a10      	subs	r2, #16
 800038a:	d2ed      	bcs.n	8000368 <memcpy+0x98>
 800038c:	320c      	adds	r2, #12
 800038e:	d305      	bcc.n	800039c <memcpy+0xcc>
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	3a04      	subs	r2, #4
 800039a:	d2f9      	bcs.n	8000390 <memcpy+0xc0>
 800039c:	3204      	adds	r2, #4
 800039e:	d008      	beq.n	80003b2 <memcpy+0xe2>
 80003a0:	07d2      	lsls	r2, r2, #31
 80003a2:	bf1c      	itt	ne
 80003a4:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003a8:	f800 3b01 	strbne.w	r3, [r0], #1
 80003ac:	d301      	bcc.n	80003b2 <memcpy+0xe2>
 80003ae:	880b      	ldrh	r3, [r1, #0]
 80003b0:	8003      	strh	r3, [r0, #0]
 80003b2:	4660      	mov	r0, ip
 80003b4:	4770      	bx	lr
 80003b6:	bf00      	nop
 80003b8:	2a08      	cmp	r2, #8
 80003ba:	d313      	bcc.n	80003e4 <memcpy+0x114>
 80003bc:	078b      	lsls	r3, r1, #30
 80003be:	d08d      	beq.n	80002dc <memcpy+0xc>
 80003c0:	f010 0303 	ands.w	r3, r0, #3
 80003c4:	d08a      	beq.n	80002dc <memcpy+0xc>
 80003c6:	f1c3 0304 	rsb	r3, r3, #4
 80003ca:	1ad2      	subs	r2, r2, r3
 80003cc:	07db      	lsls	r3, r3, #31
 80003ce:	bf1c      	itt	ne
 80003d0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003d4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003d8:	d380      	bcc.n	80002dc <memcpy+0xc>
 80003da:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003de:	f820 3b02 	strh.w	r3, [r0], #2
 80003e2:	e77b      	b.n	80002dc <memcpy+0xc>
 80003e4:	3a04      	subs	r2, #4
 80003e6:	d3d9      	bcc.n	800039c <memcpy+0xcc>
 80003e8:	3a01      	subs	r2, #1
 80003ea:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003ee:	f800 3b01 	strb.w	r3, [r0], #1
 80003f2:	d2f9      	bcs.n	80003e8 <memcpy+0x118>
 80003f4:	780b      	ldrb	r3, [r1, #0]
 80003f6:	7003      	strb	r3, [r0, #0]
 80003f8:	784b      	ldrb	r3, [r1, #1]
 80003fa:	7043      	strb	r3, [r0, #1]
 80003fc:	788b      	ldrb	r3, [r1, #2]
 80003fe:	7083      	strb	r3, [r0, #2]
 8000400:	4660      	mov	r0, ip
 8000402:	4770      	bx	lr
	...

08000410 <memset>:
 8000410:	b470      	push	{r4, r5, r6}
 8000412:	0786      	lsls	r6, r0, #30
 8000414:	d046      	beq.n	80004a4 <memset+0x94>
 8000416:	1e54      	subs	r4, r2, #1
 8000418:	2a00      	cmp	r2, #0
 800041a:	d041      	beq.n	80004a0 <memset+0x90>
 800041c:	b2ca      	uxtb	r2, r1
 800041e:	4603      	mov	r3, r0
 8000420:	e002      	b.n	8000428 <memset+0x18>
 8000422:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
 8000426:	d33b      	bcc.n	80004a0 <memset+0x90>
 8000428:	f803 2b01 	strb.w	r2, [r3], #1
 800042c:	079d      	lsls	r5, r3, #30
 800042e:	d1f8      	bne.n	8000422 <memset+0x12>
 8000430:	2c03      	cmp	r4, #3
 8000432:	d92e      	bls.n	8000492 <memset+0x82>
 8000434:	b2cd      	uxtb	r5, r1
 8000436:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800043a:	2c0f      	cmp	r4, #15
 800043c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8000440:	d919      	bls.n	8000476 <memset+0x66>
 8000442:	f103 0210 	add.w	r2, r3, #16
 8000446:	4626      	mov	r6, r4
 8000448:	3e10      	subs	r6, #16
 800044a:	2e0f      	cmp	r6, #15
 800044c:	f842 5c10 	str.w	r5, [r2, #-16]
 8000450:	f842 5c0c 	str.w	r5, [r2, #-12]
 8000454:	f842 5c08 	str.w	r5, [r2, #-8]
 8000458:	f842 5c04 	str.w	r5, [r2, #-4]
 800045c:	f102 0210 	add.w	r2, r2, #16
 8000460:	d8f2      	bhi.n	8000448 <memset+0x38>
 8000462:	f1a4 0210 	sub.w	r2, r4, #16
 8000466:	f022 020f 	bic.w	r2, r2, #15
 800046a:	f004 040f 	and.w	r4, r4, #15
 800046e:	3210      	adds	r2, #16
 8000470:	2c03      	cmp	r4, #3
 8000472:	4413      	add	r3, r2
 8000474:	d90d      	bls.n	8000492 <memset+0x82>
 8000476:	461e      	mov	r6, r3
 8000478:	4622      	mov	r2, r4
 800047a:	3a04      	subs	r2, #4
 800047c:	2a03      	cmp	r2, #3
 800047e:	f846 5b04 	str.w	r5, [r6], #4
 8000482:	d8fa      	bhi.n	800047a <memset+0x6a>
 8000484:	1f22      	subs	r2, r4, #4
 8000486:	f022 0203 	bic.w	r2, r2, #3
 800048a:	3204      	adds	r2, #4
 800048c:	4413      	add	r3, r2
 800048e:	f004 0403 	and.w	r4, r4, #3
 8000492:	b12c      	cbz	r4, 80004a0 <memset+0x90>
 8000494:	b2c9      	uxtb	r1, r1
 8000496:	441c      	add	r4, r3
 8000498:	f803 1b01 	strb.w	r1, [r3], #1
 800049c:	429c      	cmp	r4, r3
 800049e:	d1fb      	bne.n	8000498 <memset+0x88>
 80004a0:	bc70      	pop	{r4, r5, r6}
 80004a2:	4770      	bx	lr
 80004a4:	4614      	mov	r4, r2
 80004a6:	4603      	mov	r3, r0
 80004a8:	e7c2      	b.n	8000430 <memset+0x20>
 80004aa:	bf00      	nop
 80004ac:	0000      	movs	r0, r0
	...

080004b0 <_iprintf_r>:
 80004b0:	b40e      	push	{r1, r2, r3}
 80004b2:	b510      	push	{r4, lr}
 80004b4:	4604      	mov	r4, r0
 80004b6:	b083      	sub	sp, #12
 80004b8:	b118      	cbz	r0, 80004c2 <_iprintf_r+0x12>
 80004ba:	6983      	ldr	r3, [r0, #24]
 80004bc:	b90b      	cbnz	r3, 80004c2 <_iprintf_r+0x12>
 80004be:	f000 fb57 	bl	8000b70 <__sinit>
 80004c2:	a806      	add	r0, sp, #24
 80004c4:	4603      	mov	r3, r0
 80004c6:	9001      	str	r0, [sp, #4]
 80004c8:	9a05      	ldr	r2, [sp, #20]
 80004ca:	68a1      	ldr	r1, [r4, #8]
 80004cc:	4620      	mov	r0, r4
 80004ce:	f000 fd1d 	bl	8000f0c <_vfiprintf_r>
 80004d2:	b003      	add	sp, #12
 80004d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80004d8:	b003      	add	sp, #12
 80004da:	4770      	bx	lr

080004dc <iprintf>:
 80004dc:	b40f      	push	{r0, r1, r2, r3}
 80004de:	b510      	push	{r4, lr}
 80004e0:	4b0a      	ldr	r3, [pc, #40]	; (800050c <iprintf+0x30>)
 80004e2:	681c      	ldr	r4, [r3, #0]
 80004e4:	b082      	sub	sp, #8
 80004e6:	b124      	cbz	r4, 80004f2 <iprintf+0x16>
 80004e8:	69a3      	ldr	r3, [r4, #24]
 80004ea:	b913      	cbnz	r3, 80004f2 <iprintf+0x16>
 80004ec:	4620      	mov	r0, r4
 80004ee:	f000 fb3f 	bl	8000b70 <__sinit>
 80004f2:	a805      	add	r0, sp, #20
 80004f4:	4603      	mov	r3, r0
 80004f6:	9001      	str	r0, [sp, #4]
 80004f8:	9a04      	ldr	r2, [sp, #16]
 80004fa:	68a1      	ldr	r1, [r4, #8]
 80004fc:	4620      	mov	r0, r4
 80004fe:	f000 fd05 	bl	8000f0c <_vfiprintf_r>
 8000502:	b002      	add	sp, #8
 8000504:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000508:	b004      	add	sp, #16
 800050a:	4770      	bx	lr
 800050c:	20000800 	.word	0x20000800

08000510 <_puts_r>:
 8000510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000514:	460e      	mov	r6, r1
 8000516:	4680      	mov	r8, r0
 8000518:	2800      	cmp	r0, #0
 800051a:	d03e      	beq.n	800059a <_puts_r+0x8a>
 800051c:	6983      	ldr	r3, [r0, #24]
 800051e:	2b00      	cmp	r3, #0
 8000520:	d039      	beq.n	8000596 <_puts_r+0x86>
 8000522:	6884      	ldr	r4, [r0, #8]
 8000524:	4b2f      	ldr	r3, [pc, #188]	; (80005e4 <_puts_r+0xd4>)
 8000526:	429c      	cmp	r4, r3
 8000528:	d043      	beq.n	80005b2 <_puts_r+0xa2>
 800052a:	4b2f      	ldr	r3, [pc, #188]	; (80005e8 <_puts_r+0xd8>)
 800052c:	429c      	cmp	r4, r3
 800052e:	d056      	beq.n	80005de <_puts_r+0xce>
 8000530:	4b2e      	ldr	r3, [pc, #184]	; (80005ec <_puts_r+0xdc>)
 8000532:	429c      	cmp	r4, r3
 8000534:	bf08      	it	eq
 8000536:	f8d8 400c 	ldreq.w	r4, [r8, #12]
 800053a:	89a3      	ldrh	r3, [r4, #12]
 800053c:	071b      	lsls	r3, r3, #28
 800053e:	d53d      	bpl.n	80005bc <_puts_r+0xac>
 8000540:	6923      	ldr	r3, [r4, #16]
 8000542:	2b00      	cmp	r3, #0
 8000544:	d03a      	beq.n	80005bc <_puts_r+0xac>
 8000546:	3e01      	subs	r6, #1
 8000548:	68a3      	ldr	r3, [r4, #8]
 800054a:	f816 5f01 	ldrb.w	r5, [r6, #1]!
 800054e:	3b01      	subs	r3, #1
 8000550:	60a3      	str	r3, [r4, #8]
 8000552:	b1b5      	cbz	r5, 8000582 <_puts_r+0x72>
 8000554:	2b00      	cmp	r3, #0
 8000556:	db04      	blt.n	8000562 <_puts_r+0x52>
 8000558:	6823      	ldr	r3, [r4, #0]
 800055a:	1c5a      	adds	r2, r3, #1
 800055c:	6022      	str	r2, [r4, #0]
 800055e:	701d      	strb	r5, [r3, #0]
 8000560:	e7f2      	b.n	8000548 <_puts_r+0x38>
 8000562:	69a7      	ldr	r7, [r4, #24]
 8000564:	42bb      	cmp	r3, r7
 8000566:	4622      	mov	r2, r4
 8000568:	4629      	mov	r1, r5
 800056a:	4640      	mov	r0, r8
 800056c:	db01      	blt.n	8000572 <_puts_r+0x62>
 800056e:	2d0a      	cmp	r5, #10
 8000570:	d1f2      	bne.n	8000558 <_puts_r+0x48>
 8000572:	f000 f845 	bl	8000600 <__swbuf_r>
 8000576:	3001      	adds	r0, #1
 8000578:	d1e6      	bne.n	8000548 <_puts_r+0x38>
 800057a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800057e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000582:	2b00      	cmp	r3, #0
 8000584:	db21      	blt.n	80005ca <_puts_r+0xba>
 8000586:	6823      	ldr	r3, [r4, #0]
 8000588:	220a      	movs	r2, #10
 800058a:	1c59      	adds	r1, r3, #1
 800058c:	6021      	str	r1, [r4, #0]
 800058e:	701a      	strb	r2, [r3, #0]
 8000590:	4610      	mov	r0, r2
 8000592:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000596:	f000 faeb 	bl	8000b70 <__sinit>
 800059a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800059e:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80005a2:	2b00      	cmp	r3, #0
 80005a4:	d1be      	bne.n	8000524 <_puts_r+0x14>
 80005a6:	4640      	mov	r0, r8
 80005a8:	f000 fae2 	bl	8000b70 <__sinit>
 80005ac:	4b0d      	ldr	r3, [pc, #52]	; (80005e4 <_puts_r+0xd4>)
 80005ae:	429c      	cmp	r4, r3
 80005b0:	d1bb      	bne.n	800052a <_puts_r+0x1a>
 80005b2:	f8d8 4004 	ldr.w	r4, [r8, #4]
 80005b6:	89a3      	ldrh	r3, [r4, #12]
 80005b8:	071b      	lsls	r3, r3, #28
 80005ba:	d4c1      	bmi.n	8000540 <_puts_r+0x30>
 80005bc:	4621      	mov	r1, r4
 80005be:	4640      	mov	r0, r8
 80005c0:	f000 f886 	bl	80006d0 <__swsetup_r>
 80005c4:	2800      	cmp	r0, #0
 80005c6:	d0be      	beq.n	8000546 <_puts_r+0x36>
 80005c8:	e7d7      	b.n	800057a <_puts_r+0x6a>
 80005ca:	4622      	mov	r2, r4
 80005cc:	4640      	mov	r0, r8
 80005ce:	210a      	movs	r1, #10
 80005d0:	f000 f816 	bl	8000600 <__swbuf_r>
 80005d4:	3001      	adds	r0, #1
 80005d6:	d0d0      	beq.n	800057a <_puts_r+0x6a>
 80005d8:	200a      	movs	r0, #10
 80005da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80005de:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80005e2:	e7aa      	b.n	800053a <_puts_r+0x2a>
 80005e4:	08004010 	.word	0x08004010
 80005e8:	08003ff0 	.word	0x08003ff0
 80005ec:	08003fd0 	.word	0x08003fd0

080005f0 <puts>:
 80005f0:	4b02      	ldr	r3, [pc, #8]	; (80005fc <puts+0xc>)
 80005f2:	4601      	mov	r1, r0
 80005f4:	6818      	ldr	r0, [r3, #0]
 80005f6:	f7ff bf8b 	b.w	8000510 <_puts_r>
 80005fa:	bf00      	nop
 80005fc:	20000800 	.word	0x20000800

08000600 <__swbuf_r>:
 8000600:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000602:	460d      	mov	r5, r1
 8000604:	4614      	mov	r4, r2
 8000606:	4606      	mov	r6, r0
 8000608:	b110      	cbz	r0, 8000610 <__swbuf_r+0x10>
 800060a:	6983      	ldr	r3, [r0, #24]
 800060c:	2b00      	cmp	r3, #0
 800060e:	d042      	beq.n	8000696 <__swbuf_r+0x96>
 8000610:	4b25      	ldr	r3, [pc, #148]	; (80006a8 <__swbuf_r+0xa8>)
 8000612:	429c      	cmp	r4, r3
 8000614:	d044      	beq.n	80006a0 <__swbuf_r+0xa0>
 8000616:	4b25      	ldr	r3, [pc, #148]	; (80006ac <__swbuf_r+0xac>)
 8000618:	429c      	cmp	r4, r3
 800061a:	d043      	beq.n	80006a4 <__swbuf_r+0xa4>
 800061c:	4b24      	ldr	r3, [pc, #144]	; (80006b0 <__swbuf_r+0xb0>)
 800061e:	429c      	cmp	r4, r3
 8000620:	bf08      	it	eq
 8000622:	68f4      	ldreq	r4, [r6, #12]
 8000624:	89a3      	ldrh	r3, [r4, #12]
 8000626:	69a2      	ldr	r2, [r4, #24]
 8000628:	60a2      	str	r2, [r4, #8]
 800062a:	071a      	lsls	r2, r3, #28
 800062c:	d522      	bpl.n	8000674 <__swbuf_r+0x74>
 800062e:	6923      	ldr	r3, [r4, #16]
 8000630:	b303      	cbz	r3, 8000674 <__swbuf_r+0x74>
 8000632:	6822      	ldr	r2, [r4, #0]
 8000634:	6961      	ldr	r1, [r4, #20]
 8000636:	1ad3      	subs	r3, r2, r3
 8000638:	b2ed      	uxtb	r5, r5
 800063a:	428b      	cmp	r3, r1
 800063c:	462f      	mov	r7, r5
 800063e:	da21      	bge.n	8000684 <__swbuf_r+0x84>
 8000640:	3301      	adds	r3, #1
 8000642:	68a1      	ldr	r1, [r4, #8]
 8000644:	1c50      	adds	r0, r2, #1
 8000646:	3901      	subs	r1, #1
 8000648:	60a1      	str	r1, [r4, #8]
 800064a:	6020      	str	r0, [r4, #0]
 800064c:	7015      	strb	r5, [r2, #0]
 800064e:	6962      	ldr	r2, [r4, #20]
 8000650:	429a      	cmp	r2, r3
 8000652:	d006      	beq.n	8000662 <__swbuf_r+0x62>
 8000654:	89a3      	ldrh	r3, [r4, #12]
 8000656:	07db      	lsls	r3, r3, #31
 8000658:	d501      	bpl.n	800065e <__swbuf_r+0x5e>
 800065a:	2d0a      	cmp	r5, #10
 800065c:	d001      	beq.n	8000662 <__swbuf_r+0x62>
 800065e:	4638      	mov	r0, r7
 8000660:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000662:	4621      	mov	r1, r4
 8000664:	4630      	mov	r0, r6
 8000666:	f000 f947 	bl	80008f8 <_fflush_r>
 800066a:	2800      	cmp	r0, #0
 800066c:	d0f7      	beq.n	800065e <__swbuf_r+0x5e>
 800066e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 8000672:	e7f4      	b.n	800065e <__swbuf_r+0x5e>
 8000674:	4621      	mov	r1, r4
 8000676:	4630      	mov	r0, r6
 8000678:	f000 f82a 	bl	80006d0 <__swsetup_r>
 800067c:	2800      	cmp	r0, #0
 800067e:	d1f6      	bne.n	800066e <__swbuf_r+0x6e>
 8000680:	6923      	ldr	r3, [r4, #16]
 8000682:	e7d6      	b.n	8000632 <__swbuf_r+0x32>
 8000684:	4621      	mov	r1, r4
 8000686:	4630      	mov	r0, r6
 8000688:	f000 f936 	bl	80008f8 <_fflush_r>
 800068c:	2800      	cmp	r0, #0
 800068e:	d1ee      	bne.n	800066e <__swbuf_r+0x6e>
 8000690:	6822      	ldr	r2, [r4, #0]
 8000692:	2301      	movs	r3, #1
 8000694:	e7d5      	b.n	8000642 <__swbuf_r+0x42>
 8000696:	f000 fa6b 	bl	8000b70 <__sinit>
 800069a:	4b03      	ldr	r3, [pc, #12]	; (80006a8 <__swbuf_r+0xa8>)
 800069c:	429c      	cmp	r4, r3
 800069e:	d1ba      	bne.n	8000616 <__swbuf_r+0x16>
 80006a0:	6874      	ldr	r4, [r6, #4]
 80006a2:	e7bf      	b.n	8000624 <__swbuf_r+0x24>
 80006a4:	68b4      	ldr	r4, [r6, #8]
 80006a6:	e7bd      	b.n	8000624 <__swbuf_r+0x24>
 80006a8:	08004010 	.word	0x08004010
 80006ac:	08003ff0 	.word	0x08003ff0
 80006b0:	08003fd0 	.word	0x08003fd0

080006b4 <__swbuf>:
 80006b4:	4b02      	ldr	r3, [pc, #8]	; (80006c0 <__swbuf+0xc>)
 80006b6:	460a      	mov	r2, r1
 80006b8:	4601      	mov	r1, r0
 80006ba:	6818      	ldr	r0, [r3, #0]
 80006bc:	f7ff bfa0 	b.w	8000600 <__swbuf_r>
 80006c0:	20000800 	.word	0x20000800
	...

080006d0 <__swsetup_r>:
 80006d0:	4b38      	ldr	r3, [pc, #224]	; (80007b4 <__swsetup_r+0xe4>)
 80006d2:	b570      	push	{r4, r5, r6, lr}
 80006d4:	681d      	ldr	r5, [r3, #0]
 80006d6:	4606      	mov	r6, r0
 80006d8:	460c      	mov	r4, r1
 80006da:	b115      	cbz	r5, 80006e2 <__swsetup_r+0x12>
 80006dc:	69ab      	ldr	r3, [r5, #24]
 80006de:	2b00      	cmp	r3, #0
 80006e0:	d042      	beq.n	8000768 <__swsetup_r+0x98>
 80006e2:	4b35      	ldr	r3, [pc, #212]	; (80007b8 <__swsetup_r+0xe8>)
 80006e4:	429c      	cmp	r4, r3
 80006e6:	d045      	beq.n	8000774 <__swsetup_r+0xa4>
 80006e8:	4b34      	ldr	r3, [pc, #208]	; (80007bc <__swsetup_r+0xec>)
 80006ea:	429c      	cmp	r4, r3
 80006ec:	d058      	beq.n	80007a0 <__swsetup_r+0xd0>
 80006ee:	4b34      	ldr	r3, [pc, #208]	; (80007c0 <__swsetup_r+0xf0>)
 80006f0:	429c      	cmp	r4, r3
 80006f2:	bf08      	it	eq
 80006f4:	68ec      	ldreq	r4, [r5, #12]
 80006f6:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80006fa:	b293      	uxth	r3, r2
 80006fc:	0719      	lsls	r1, r3, #28
 80006fe:	d50c      	bpl.n	800071a <__swsetup_r+0x4a>
 8000700:	6920      	ldr	r0, [r4, #16]
 8000702:	b1a8      	cbz	r0, 8000730 <__swsetup_r+0x60>
 8000704:	f013 0201 	ands.w	r2, r3, #1
 8000708:	d01e      	beq.n	8000748 <__swsetup_r+0x78>
 800070a:	6963      	ldr	r3, [r4, #20]
 800070c:	2200      	movs	r2, #0
 800070e:	425b      	negs	r3, r3
 8000710:	61a3      	str	r3, [r4, #24]
 8000712:	60a2      	str	r2, [r4, #8]
 8000714:	b1f0      	cbz	r0, 8000754 <__swsetup_r+0x84>
 8000716:	2000      	movs	r0, #0
 8000718:	bd70      	pop	{r4, r5, r6, pc}
 800071a:	06dd      	lsls	r5, r3, #27
 800071c:	d542      	bpl.n	80007a4 <__swsetup_r+0xd4>
 800071e:	0758      	lsls	r0, r3, #29
 8000720:	d42a      	bmi.n	8000778 <__swsetup_r+0xa8>
 8000722:	6920      	ldr	r0, [r4, #16]
 8000724:	f042 0308 	orr.w	r3, r2, #8
 8000728:	81a3      	strh	r3, [r4, #12]
 800072a:	b29b      	uxth	r3, r3
 800072c:	2800      	cmp	r0, #0
 800072e:	d1e9      	bne.n	8000704 <__swsetup_r+0x34>
 8000730:	f403 7220 	and.w	r2, r3, #640	; 0x280
 8000734:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8000738:	d0e4      	beq.n	8000704 <__swsetup_r+0x34>
 800073a:	4630      	mov	r0, r6
 800073c:	4621      	mov	r1, r4
 800073e:	f000 fab5 	bl	8000cac <__smakebuf_r>
 8000742:	89a3      	ldrh	r3, [r4, #12]
 8000744:	6920      	ldr	r0, [r4, #16]
 8000746:	e7dd      	b.n	8000704 <__swsetup_r+0x34>
 8000748:	0799      	lsls	r1, r3, #30
 800074a:	bf58      	it	pl
 800074c:	6962      	ldrpl	r2, [r4, #20]
 800074e:	60a2      	str	r2, [r4, #8]
 8000750:	2800      	cmp	r0, #0
 8000752:	d1e0      	bne.n	8000716 <__swsetup_r+0x46>
 8000754:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8000758:	061a      	lsls	r2, r3, #24
 800075a:	d5dd      	bpl.n	8000718 <__swsetup_r+0x48>
 800075c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000760:	81a3      	strh	r3, [r4, #12]
 8000762:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000766:	bd70      	pop	{r4, r5, r6, pc}
 8000768:	4628      	mov	r0, r5
 800076a:	f000 fa01 	bl	8000b70 <__sinit>
 800076e:	4b12      	ldr	r3, [pc, #72]	; (80007b8 <__swsetup_r+0xe8>)
 8000770:	429c      	cmp	r4, r3
 8000772:	d1b9      	bne.n	80006e8 <__swsetup_r+0x18>
 8000774:	686c      	ldr	r4, [r5, #4]
 8000776:	e7be      	b.n	80006f6 <__swsetup_r+0x26>
 8000778:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800077a:	b151      	cbz	r1, 8000792 <__swsetup_r+0xc2>
 800077c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8000780:	4299      	cmp	r1, r3
 8000782:	d004      	beq.n	800078e <__swsetup_r+0xbe>
 8000784:	4630      	mov	r0, r6
 8000786:	f000 fadb 	bl	8000d40 <_free_r>
 800078a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 800078e:	2300      	movs	r3, #0
 8000790:	6363      	str	r3, [r4, #52]	; 0x34
 8000792:	2300      	movs	r3, #0
 8000794:	6920      	ldr	r0, [r4, #16]
 8000796:	6063      	str	r3, [r4, #4]
 8000798:	f022 0224 	bic.w	r2, r2, #36	; 0x24
 800079c:	6020      	str	r0, [r4, #0]
 800079e:	e7c1      	b.n	8000724 <__swsetup_r+0x54>
 80007a0:	68ac      	ldr	r4, [r5, #8]
 80007a2:	e7a8      	b.n	80006f6 <__swsetup_r+0x26>
 80007a4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80007a8:	2309      	movs	r3, #9
 80007aa:	6033      	str	r3, [r6, #0]
 80007ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80007b0:	81a2      	strh	r2, [r4, #12]
 80007b2:	bd70      	pop	{r4, r5, r6, pc}
 80007b4:	20000800 	.word	0x20000800
 80007b8:	08004010 	.word	0x08004010
 80007bc:	08003ff0 	.word	0x08003ff0
 80007c0:	08003fd0 	.word	0x08003fd0
	...

080007d0 <__sflush_r>:
 80007d0:	898b      	ldrh	r3, [r1, #12]
 80007d2:	071a      	lsls	r2, r3, #28
 80007d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80007d8:	460d      	mov	r5, r1
 80007da:	4680      	mov	r8, r0
 80007dc:	d433      	bmi.n	8000846 <__sflush_r+0x76>
 80007de:	684a      	ldr	r2, [r1, #4]
 80007e0:	2a00      	cmp	r2, #0
 80007e2:	dd67      	ble.n	80008b4 <__sflush_r+0xe4>
 80007e4:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 80007e6:	2c00      	cmp	r4, #0
 80007e8:	d045      	beq.n	8000876 <__sflush_r+0xa6>
 80007ea:	2200      	movs	r2, #0
 80007ec:	f8d8 6000 	ldr.w	r6, [r8]
 80007f0:	f8c8 2000 	str.w	r2, [r8]
 80007f4:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
 80007f8:	d060      	beq.n	80008bc <__sflush_r+0xec>
 80007fa:	6d6a      	ldr	r2, [r5, #84]	; 0x54
 80007fc:	075f      	lsls	r7, r3, #29
 80007fe:	d505      	bpl.n	800080c <__sflush_r+0x3c>
 8000800:	6869      	ldr	r1, [r5, #4]
 8000802:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8000804:	1a52      	subs	r2, r2, r1
 8000806:	b10b      	cbz	r3, 800080c <__sflush_r+0x3c>
 8000808:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800080a:	1ad2      	subs	r2, r2, r3
 800080c:	2300      	movs	r3, #0
 800080e:	6a29      	ldr	r1, [r5, #32]
 8000810:	4640      	mov	r0, r8
 8000812:	47a0      	blx	r4
 8000814:	1c44      	adds	r4, r0, #1
 8000816:	d039      	beq.n	800088c <__sflush_r+0xbc>
 8000818:	89ab      	ldrh	r3, [r5, #12]
 800081a:	692a      	ldr	r2, [r5, #16]
 800081c:	602a      	str	r2, [r5, #0]
 800081e:	04db      	lsls	r3, r3, #19
 8000820:	f04f 0200 	mov.w	r2, #0
 8000824:	606a      	str	r2, [r5, #4]
 8000826:	d443      	bmi.n	80008b0 <__sflush_r+0xe0>
 8000828:	6b69      	ldr	r1, [r5, #52]	; 0x34
 800082a:	f8c8 6000 	str.w	r6, [r8]
 800082e:	b311      	cbz	r1, 8000876 <__sflush_r+0xa6>
 8000830:	f105 0344 	add.w	r3, r5, #68	; 0x44
 8000834:	4299      	cmp	r1, r3
 8000836:	d002      	beq.n	800083e <__sflush_r+0x6e>
 8000838:	4640      	mov	r0, r8
 800083a:	f000 fa81 	bl	8000d40 <_free_r>
 800083e:	2000      	movs	r0, #0
 8000840:	6368      	str	r0, [r5, #52]	; 0x34
 8000842:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000846:	690e      	ldr	r6, [r1, #16]
 8000848:	b1ae      	cbz	r6, 8000876 <__sflush_r+0xa6>
 800084a:	680c      	ldr	r4, [r1, #0]
 800084c:	600e      	str	r6, [r1, #0]
 800084e:	0798      	lsls	r0, r3, #30
 8000850:	bf0c      	ite	eq
 8000852:	694b      	ldreq	r3, [r1, #20]
 8000854:	2300      	movne	r3, #0
 8000856:	1ba4      	subs	r4, r4, r6
 8000858:	608b      	str	r3, [r1, #8]
 800085a:	e00a      	b.n	8000872 <__sflush_r+0xa2>
 800085c:	4623      	mov	r3, r4
 800085e:	4632      	mov	r2, r6
 8000860:	6aaf      	ldr	r7, [r5, #40]	; 0x28
 8000862:	6a29      	ldr	r1, [r5, #32]
 8000864:	4640      	mov	r0, r8
 8000866:	47b8      	blx	r7
 8000868:	2800      	cmp	r0, #0
 800086a:	eba4 0400 	sub.w	r4, r4, r0
 800086e:	4406      	add	r6, r0
 8000870:	dd04      	ble.n	800087c <__sflush_r+0xac>
 8000872:	2c00      	cmp	r4, #0
 8000874:	dcf2      	bgt.n	800085c <__sflush_r+0x8c>
 8000876:	2000      	movs	r0, #0
 8000878:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800087c:	89ab      	ldrh	r3, [r5, #12]
 800087e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000882:	81ab      	strh	r3, [r5, #12]
 8000884:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800088c:	f8d8 2000 	ldr.w	r2, [r8]
 8000890:	2a1d      	cmp	r2, #29
 8000892:	d8f3      	bhi.n	800087c <__sflush_r+0xac>
 8000894:	4b17      	ldr	r3, [pc, #92]	; (80008f4 <__sflush_r+0x124>)
 8000896:	40d3      	lsrs	r3, r2
 8000898:	43db      	mvns	r3, r3
 800089a:	f013 0301 	ands.w	r3, r3, #1
 800089e:	d1ed      	bne.n	800087c <__sflush_r+0xac>
 80008a0:	89a9      	ldrh	r1, [r5, #12]
 80008a2:	692c      	ldr	r4, [r5, #16]
 80008a4:	606b      	str	r3, [r5, #4]
 80008a6:	04c9      	lsls	r1, r1, #19
 80008a8:	602c      	str	r4, [r5, #0]
 80008aa:	d5bd      	bpl.n	8000828 <__sflush_r+0x58>
 80008ac:	2a00      	cmp	r2, #0
 80008ae:	d1bb      	bne.n	8000828 <__sflush_r+0x58>
 80008b0:	6568      	str	r0, [r5, #84]	; 0x54
 80008b2:	e7b9      	b.n	8000828 <__sflush_r+0x58>
 80008b4:	6c0a      	ldr	r2, [r1, #64]	; 0x40
 80008b6:	2a00      	cmp	r2, #0
 80008b8:	dc94      	bgt.n	80007e4 <__sflush_r+0x14>
 80008ba:	e7dc      	b.n	8000876 <__sflush_r+0xa6>
 80008bc:	2301      	movs	r3, #1
 80008be:	6a29      	ldr	r1, [r5, #32]
 80008c0:	4640      	mov	r0, r8
 80008c2:	47a0      	blx	r4
 80008c4:	1c43      	adds	r3, r0, #1
 80008c6:	4602      	mov	r2, r0
 80008c8:	d002      	beq.n	80008d0 <__sflush_r+0x100>
 80008ca:	89ab      	ldrh	r3, [r5, #12]
 80008cc:	6aec      	ldr	r4, [r5, #44]	; 0x2c
 80008ce:	e795      	b.n	80007fc <__sflush_r+0x2c>
 80008d0:	f8d8 3000 	ldr.w	r3, [r8]
 80008d4:	2b00      	cmp	r3, #0
 80008d6:	d0f8      	beq.n	80008ca <__sflush_r+0xfa>
 80008d8:	2b1d      	cmp	r3, #29
 80008da:	d001      	beq.n	80008e0 <__sflush_r+0x110>
 80008dc:	2b16      	cmp	r3, #22
 80008de:	d102      	bne.n	80008e6 <__sflush_r+0x116>
 80008e0:	f8c8 6000 	str.w	r6, [r8]
 80008e4:	e7c7      	b.n	8000876 <__sflush_r+0xa6>
 80008e6:	89ab      	ldrh	r3, [r5, #12]
 80008e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80008ec:	81ab      	strh	r3, [r5, #12]
 80008ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80008f2:	bf00      	nop
 80008f4:	20400001 	.word	0x20400001

080008f8 <_fflush_r>:
 80008f8:	690b      	ldr	r3, [r1, #16]
 80008fa:	b333      	cbz	r3, 800094a <_fflush_r+0x52>
 80008fc:	b510      	push	{r4, lr}
 80008fe:	4604      	mov	r4, r0
 8000900:	b082      	sub	sp, #8
 8000902:	b108      	cbz	r0, 8000908 <_fflush_r+0x10>
 8000904:	6983      	ldr	r3, [r0, #24]
 8000906:	b1ab      	cbz	r3, 8000934 <_fflush_r+0x3c>
 8000908:	4b11      	ldr	r3, [pc, #68]	; (8000950 <_fflush_r+0x58>)
 800090a:	4299      	cmp	r1, r3
 800090c:	d019      	beq.n	8000942 <_fflush_r+0x4a>
 800090e:	4b11      	ldr	r3, [pc, #68]	; (8000954 <_fflush_r+0x5c>)
 8000910:	4299      	cmp	r1, r3
 8000912:	d018      	beq.n	8000946 <_fflush_r+0x4e>
 8000914:	4b10      	ldr	r3, [pc, #64]	; (8000958 <_fflush_r+0x60>)
 8000916:	4299      	cmp	r1, r3
 8000918:	bf08      	it	eq
 800091a:	68e1      	ldreq	r1, [r4, #12]
 800091c:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
 8000920:	b913      	cbnz	r3, 8000928 <_fflush_r+0x30>
 8000922:	2000      	movs	r0, #0
 8000924:	b002      	add	sp, #8
 8000926:	bd10      	pop	{r4, pc}
 8000928:	4620      	mov	r0, r4
 800092a:	b002      	add	sp, #8
 800092c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000930:	f7ff bf4e 	b.w	80007d0 <__sflush_r>
 8000934:	9101      	str	r1, [sp, #4]
 8000936:	f000 f91b 	bl	8000b70 <__sinit>
 800093a:	9901      	ldr	r1, [sp, #4]
 800093c:	4b04      	ldr	r3, [pc, #16]	; (8000950 <_fflush_r+0x58>)
 800093e:	4299      	cmp	r1, r3
 8000940:	d1e5      	bne.n	800090e <_fflush_r+0x16>
 8000942:	6861      	ldr	r1, [r4, #4]
 8000944:	e7ea      	b.n	800091c <_fflush_r+0x24>
 8000946:	68a1      	ldr	r1, [r4, #8]
 8000948:	e7e8      	b.n	800091c <_fflush_r+0x24>
 800094a:	2000      	movs	r0, #0
 800094c:	4770      	bx	lr
 800094e:	bf00      	nop
 8000950:	08004010 	.word	0x08004010
 8000954:	08003ff0 	.word	0x08003ff0
 8000958:	08003fd0 	.word	0x08003fd0

0800095c <fflush>:
 800095c:	b120      	cbz	r0, 8000968 <fflush+0xc>
 800095e:	4b05      	ldr	r3, [pc, #20]	; (8000974 <fflush+0x18>)
 8000960:	4601      	mov	r1, r0
 8000962:	6818      	ldr	r0, [r3, #0]
 8000964:	f7ff bfc8 	b.w	80008f8 <_fflush_r>
 8000968:	4b03      	ldr	r3, [pc, #12]	; (8000978 <fflush+0x1c>)
 800096a:	4904      	ldr	r1, [pc, #16]	; (800097c <fflush+0x20>)
 800096c:	6818      	ldr	r0, [r3, #0]
 800096e:	f000 b945 	b.w	8000bfc <_fwalk_reent>
 8000972:	bf00      	nop
 8000974:	20000800 	.word	0x20000800
 8000978:	08003fc0 	.word	0x08003fc0
 800097c:	080008f9 	.word	0x080008f9

08000980 <__fp_unlock>:
 8000980:	2000      	movs	r0, #0
 8000982:	4770      	bx	lr

08000984 <_cleanup_r>:
 8000984:	4901      	ldr	r1, [pc, #4]	; (800098c <_cleanup_r+0x8>)
 8000986:	f000 b939 	b.w	8000bfc <_fwalk_reent>
 800098a:	bf00      	nop
 800098c:	080008f9 	.word	0x080008f9

08000990 <__fp_lock>:
 8000990:	2000      	movs	r0, #0
 8000992:	4770      	bx	lr

08000994 <__sfmoreglue>:
 8000994:	b570      	push	{r4, r5, r6, lr}
 8000996:	1e4a      	subs	r2, r1, #1
 8000998:	2568      	movs	r5, #104	; 0x68
 800099a:	fb05 f502 	mul.w	r5, r5, r2
 800099e:	460e      	mov	r6, r1
 80009a0:	f105 0174 	add.w	r1, r5, #116	; 0x74
 80009a4:	f000 fa14 	bl	8000dd0 <_malloc_r>
 80009a8:	4604      	mov	r4, r0
 80009aa:	b140      	cbz	r0, 80009be <__sfmoreglue+0x2a>
 80009ac:	2100      	movs	r1, #0
 80009ae:	300c      	adds	r0, #12
 80009b0:	6066      	str	r6, [r4, #4]
 80009b2:	f105 0268 	add.w	r2, r5, #104	; 0x68
 80009b6:	6021      	str	r1, [r4, #0]
 80009b8:	60a0      	str	r0, [r4, #8]
 80009ba:	f7ff fd29 	bl	8000410 <memset>
 80009be:	4620      	mov	r0, r4
 80009c0:	bd70      	pop	{r4, r5, r6, pc}
 80009c2:	bf00      	nop

080009c4 <__sfp>:
 80009c4:	4b20      	ldr	r3, [pc, #128]	; (8000a48 <__sfp+0x84>)
 80009c6:	b570      	push	{r4, r5, r6, lr}
 80009c8:	681d      	ldr	r5, [r3, #0]
 80009ca:	69ab      	ldr	r3, [r5, #24]
 80009cc:	4606      	mov	r6, r0
 80009ce:	b35b      	cbz	r3, 8000a28 <__sfp+0x64>
 80009d0:	3548      	adds	r5, #72	; 0x48
 80009d2:	686b      	ldr	r3, [r5, #4]
 80009d4:	68ac      	ldr	r4, [r5, #8]
 80009d6:	3b01      	subs	r3, #1
 80009d8:	d505      	bpl.n	80009e6 <__sfp+0x22>
 80009da:	e021      	b.n	8000a20 <__sfp+0x5c>
 80009dc:	3b01      	subs	r3, #1
 80009de:	1c5a      	adds	r2, r3, #1
 80009e0:	f104 0468 	add.w	r4, r4, #104	; 0x68
 80009e4:	d01c      	beq.n	8000a20 <__sfp+0x5c>
 80009e6:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80009ea:	2a00      	cmp	r2, #0
 80009ec:	d1f6      	bne.n	80009dc <__sfp+0x18>
 80009ee:	2500      	movs	r5, #0
 80009f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80009f4:	2301      	movs	r3, #1
 80009f6:	81e2      	strh	r2, [r4, #14]
 80009f8:	81a3      	strh	r3, [r4, #12]
 80009fa:	6665      	str	r5, [r4, #100]	; 0x64
 80009fc:	6025      	str	r5, [r4, #0]
 80009fe:	60a5      	str	r5, [r4, #8]
 8000a00:	6065      	str	r5, [r4, #4]
 8000a02:	6125      	str	r5, [r4, #16]
 8000a04:	6165      	str	r5, [r4, #20]
 8000a06:	61a5      	str	r5, [r4, #24]
 8000a08:	4629      	mov	r1, r5
 8000a0a:	2208      	movs	r2, #8
 8000a0c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8000a10:	f7ff fcfe 	bl	8000410 <memset>
 8000a14:	6365      	str	r5, [r4, #52]	; 0x34
 8000a16:	63a5      	str	r5, [r4, #56]	; 0x38
 8000a18:	64a5      	str	r5, [r4, #72]	; 0x48
 8000a1a:	64e5      	str	r5, [r4, #76]	; 0x4c
 8000a1c:	4620      	mov	r0, r4
 8000a1e:	bd70      	pop	{r4, r5, r6, pc}
 8000a20:	6828      	ldr	r0, [r5, #0]
 8000a22:	b128      	cbz	r0, 8000a30 <__sfp+0x6c>
 8000a24:	4605      	mov	r5, r0
 8000a26:	e7d4      	b.n	80009d2 <__sfp+0xe>
 8000a28:	4628      	mov	r0, r5
 8000a2a:	f000 f80f 	bl	8000a4c <__sinit.part.1>
 8000a2e:	e7cf      	b.n	80009d0 <__sfp+0xc>
 8000a30:	2104      	movs	r1, #4
 8000a32:	4630      	mov	r0, r6
 8000a34:	f7ff ffae 	bl	8000994 <__sfmoreglue>
 8000a38:	6028      	str	r0, [r5, #0]
 8000a3a:	2800      	cmp	r0, #0
 8000a3c:	d1f2      	bne.n	8000a24 <__sfp+0x60>
 8000a3e:	230c      	movs	r3, #12
 8000a40:	4604      	mov	r4, r0
 8000a42:	6033      	str	r3, [r6, #0]
 8000a44:	e7ea      	b.n	8000a1c <__sfp+0x58>
 8000a46:	bf00      	nop
 8000a48:	08003fc0 	.word	0x08003fc0

08000a4c <__sinit.part.1>:
 8000a4c:	4b3d      	ldr	r3, [pc, #244]	; (8000b44 <__sinit.part.1+0xf8>)
 8000a4e:	493e      	ldr	r1, [pc, #248]	; (8000b48 <__sinit.part.1+0xfc>)
 8000a50:	681a      	ldr	r2, [r3, #0]
 8000a52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000a56:	4290      	cmp	r0, r2
 8000a58:	f04f 0300 	mov.w	r3, #0
 8000a5c:	6483      	str	r3, [r0, #72]	; 0x48
 8000a5e:	64c3      	str	r3, [r0, #76]	; 0x4c
 8000a60:	6503      	str	r3, [r0, #80]	; 0x50
 8000a62:	bf08      	it	eq
 8000a64:	2301      	moveq	r3, #1
 8000a66:	b083      	sub	sp, #12
 8000a68:	bf08      	it	eq
 8000a6a:	6183      	streq	r3, [r0, #24]
 8000a6c:	6281      	str	r1, [r0, #40]	; 0x28
 8000a6e:	4607      	mov	r7, r0
 8000a70:	f7ff ffa8 	bl	80009c4 <__sfp>
 8000a74:	6078      	str	r0, [r7, #4]
 8000a76:	4638      	mov	r0, r7
 8000a78:	f7ff ffa4 	bl	80009c4 <__sfp>
 8000a7c:	60b8      	str	r0, [r7, #8]
 8000a7e:	4638      	mov	r0, r7
 8000a80:	f7ff ffa0 	bl	80009c4 <__sfp>
 8000a84:	687d      	ldr	r5, [r7, #4]
 8000a86:	60f8      	str	r0, [r7, #12]
 8000a88:	2400      	movs	r4, #0
 8000a8a:	2304      	movs	r3, #4
 8000a8c:	81ab      	strh	r3, [r5, #12]
 8000a8e:	602c      	str	r4, [r5, #0]
 8000a90:	606c      	str	r4, [r5, #4]
 8000a92:	60ac      	str	r4, [r5, #8]
 8000a94:	666c      	str	r4, [r5, #100]	; 0x64
 8000a96:	81ec      	strh	r4, [r5, #14]
 8000a98:	612c      	str	r4, [r5, #16]
 8000a9a:	616c      	str	r4, [r5, #20]
 8000a9c:	61ac      	str	r4, [r5, #24]
 8000a9e:	4621      	mov	r1, r4
 8000aa0:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 8000aa4:	2208      	movs	r2, #8
 8000aa6:	f7ff fcb3 	bl	8000410 <memset>
 8000aaa:	68be      	ldr	r6, [r7, #8]
 8000aac:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8000b4c <__sinit.part.1+0x100>
 8000ab0:	f8df a09c 	ldr.w	sl, [pc, #156]	; 8000b50 <__sinit.part.1+0x104>
 8000ab4:	f8df 909c 	ldr.w	r9, [pc, #156]	; 8000b54 <__sinit.part.1+0x108>
 8000ab8:	f8df 809c 	ldr.w	r8, [pc, #156]	; 8000b58 <__sinit.part.1+0x10c>
 8000abc:	f8c5 b024 	str.w	fp, [r5, #36]	; 0x24
 8000ac0:	2301      	movs	r3, #1
 8000ac2:	2209      	movs	r2, #9
 8000ac4:	f8c5 a028 	str.w	sl, [r5, #40]	; 0x28
 8000ac8:	f8c5 902c 	str.w	r9, [r5, #44]	; 0x2c
 8000acc:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
 8000ad0:	622d      	str	r5, [r5, #32]
 8000ad2:	4621      	mov	r1, r4
 8000ad4:	81f3      	strh	r3, [r6, #14]
 8000ad6:	81b2      	strh	r2, [r6, #12]
 8000ad8:	6034      	str	r4, [r6, #0]
 8000ada:	6074      	str	r4, [r6, #4]
 8000adc:	60b4      	str	r4, [r6, #8]
 8000ade:	6674      	str	r4, [r6, #100]	; 0x64
 8000ae0:	6134      	str	r4, [r6, #16]
 8000ae2:	6174      	str	r4, [r6, #20]
 8000ae4:	61b4      	str	r4, [r6, #24]
 8000ae6:	f106 005c 	add.w	r0, r6, #92	; 0x5c
 8000aea:	2208      	movs	r2, #8
 8000aec:	9301      	str	r3, [sp, #4]
 8000aee:	f7ff fc8f 	bl	8000410 <memset>
 8000af2:	68fd      	ldr	r5, [r7, #12]
 8000af4:	6236      	str	r6, [r6, #32]
 8000af6:	2012      	movs	r0, #18
 8000af8:	2202      	movs	r2, #2
 8000afa:	f8c6 b024 	str.w	fp, [r6, #36]	; 0x24
 8000afe:	f8c6 a028 	str.w	sl, [r6, #40]	; 0x28
 8000b02:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c
 8000b06:	f8c6 8030 	str.w	r8, [r6, #48]	; 0x30
 8000b0a:	4621      	mov	r1, r4
 8000b0c:	81a8      	strh	r0, [r5, #12]
 8000b0e:	81ea      	strh	r2, [r5, #14]
 8000b10:	602c      	str	r4, [r5, #0]
 8000b12:	606c      	str	r4, [r5, #4]
 8000b14:	60ac      	str	r4, [r5, #8]
 8000b16:	666c      	str	r4, [r5, #100]	; 0x64
 8000b18:	612c      	str	r4, [r5, #16]
 8000b1a:	616c      	str	r4, [r5, #20]
 8000b1c:	61ac      	str	r4, [r5, #24]
 8000b1e:	f105 005c 	add.w	r0, r5, #92	; 0x5c
 8000b22:	2208      	movs	r2, #8
 8000b24:	f7ff fc74 	bl	8000410 <memset>
 8000b28:	9b01      	ldr	r3, [sp, #4]
 8000b2a:	622d      	str	r5, [r5, #32]
 8000b2c:	f8c5 b024 	str.w	fp, [r5, #36]	; 0x24
 8000b30:	f8c5 a028 	str.w	sl, [r5, #40]	; 0x28
 8000b34:	f8c5 902c 	str.w	r9, [r5, #44]	; 0x2c
 8000b38:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
 8000b3c:	61bb      	str	r3, [r7, #24]
 8000b3e:	b003      	add	sp, #12
 8000b40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b44:	08003fc0 	.word	0x08003fc0
 8000b48:	08000985 	.word	0x08000985
 8000b4c:	08001571 	.word	0x08001571
 8000b50:	08001599 	.word	0x08001599
 8000b54:	080015d5 	.word	0x080015d5
 8000b58:	080015f5 	.word	0x080015f5

08000b5c <_cleanup>:
 8000b5c:	4b02      	ldr	r3, [pc, #8]	; (8000b68 <_cleanup+0xc>)
 8000b5e:	4903      	ldr	r1, [pc, #12]	; (8000b6c <_cleanup+0x10>)
 8000b60:	6818      	ldr	r0, [r3, #0]
 8000b62:	f000 b84b 	b.w	8000bfc <_fwalk_reent>
 8000b66:	bf00      	nop
 8000b68:	08003fc0 	.word	0x08003fc0
 8000b6c:	080008f9 	.word	0x080008f9

08000b70 <__sinit>:
 8000b70:	6983      	ldr	r3, [r0, #24]
 8000b72:	b903      	cbnz	r3, 8000b76 <__sinit+0x6>
 8000b74:	e76a      	b.n	8000a4c <__sinit.part.1>
 8000b76:	4770      	bx	lr

08000b78 <__sfp_lock_acquire>:
 8000b78:	4770      	bx	lr
 8000b7a:	bf00      	nop

08000b7c <__sfp_lock_release>:
 8000b7c:	4770      	bx	lr
 8000b7e:	bf00      	nop

08000b80 <__sinit_lock_acquire>:
 8000b80:	4770      	bx	lr
 8000b82:	bf00      	nop

08000b84 <__sinit_lock_release>:
 8000b84:	4770      	bx	lr
 8000b86:	bf00      	nop

08000b88 <__fp_lock_all>:
 8000b88:	4b02      	ldr	r3, [pc, #8]	; (8000b94 <__fp_lock_all+0xc>)
 8000b8a:	4903      	ldr	r1, [pc, #12]	; (8000b98 <__fp_lock_all+0x10>)
 8000b8c:	6818      	ldr	r0, [r3, #0]
 8000b8e:	f000 b80f 	b.w	8000bb0 <_fwalk>
 8000b92:	bf00      	nop
 8000b94:	20000800 	.word	0x20000800
 8000b98:	08000991 	.word	0x08000991

08000b9c <__fp_unlock_all>:
 8000b9c:	4b02      	ldr	r3, [pc, #8]	; (8000ba8 <__fp_unlock_all+0xc>)
 8000b9e:	4903      	ldr	r1, [pc, #12]	; (8000bac <__fp_unlock_all+0x10>)
 8000ba0:	6818      	ldr	r0, [r3, #0]
 8000ba2:	f000 b805 	b.w	8000bb0 <_fwalk>
 8000ba6:	bf00      	nop
 8000ba8:	20000800 	.word	0x20000800
 8000bac:	08000981 	.word	0x08000981

08000bb0 <_fwalk>:
 8000bb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000bb4:	f110 0748 	adds.w	r7, r0, #72	; 0x48
 8000bb8:	d01b      	beq.n	8000bf2 <_fwalk+0x42>
 8000bba:	4688      	mov	r8, r1
 8000bbc:	2600      	movs	r6, #0
 8000bbe:	687d      	ldr	r5, [r7, #4]
 8000bc0:	68bc      	ldr	r4, [r7, #8]
 8000bc2:	3d01      	subs	r5, #1
 8000bc4:	d40f      	bmi.n	8000be6 <_fwalk+0x36>
 8000bc6:	89a3      	ldrh	r3, [r4, #12]
 8000bc8:	2b01      	cmp	r3, #1
 8000bca:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
 8000bce:	d906      	bls.n	8000bde <_fwalk+0x2e>
 8000bd0:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8000bd4:	3301      	adds	r3, #1
 8000bd6:	4620      	mov	r0, r4
 8000bd8:	d001      	beq.n	8000bde <_fwalk+0x2e>
 8000bda:	47c0      	blx	r8
 8000bdc:	4306      	orrs	r6, r0
 8000bde:	1c6b      	adds	r3, r5, #1
 8000be0:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8000be4:	d1ef      	bne.n	8000bc6 <_fwalk+0x16>
 8000be6:	683f      	ldr	r7, [r7, #0]
 8000be8:	2f00      	cmp	r7, #0
 8000bea:	d1e8      	bne.n	8000bbe <_fwalk+0xe>
 8000bec:	4630      	mov	r0, r6
 8000bee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000bf2:	463e      	mov	r6, r7
 8000bf4:	4630      	mov	r0, r6
 8000bf6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000bfa:	bf00      	nop

08000bfc <_fwalk_reent>:
 8000bfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000c00:	f110 0748 	adds.w	r7, r0, #72	; 0x48
 8000c04:	d01f      	beq.n	8000c46 <_fwalk_reent+0x4a>
 8000c06:	4688      	mov	r8, r1
 8000c08:	4606      	mov	r6, r0
 8000c0a:	f04f 0900 	mov.w	r9, #0
 8000c0e:	687d      	ldr	r5, [r7, #4]
 8000c10:	68bc      	ldr	r4, [r7, #8]
 8000c12:	3d01      	subs	r5, #1
 8000c14:	d411      	bmi.n	8000c3a <_fwalk_reent+0x3e>
 8000c16:	89a3      	ldrh	r3, [r4, #12]
 8000c18:	2b01      	cmp	r3, #1
 8000c1a:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
 8000c1e:	d908      	bls.n	8000c32 <_fwalk_reent+0x36>
 8000c20:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8000c24:	3301      	adds	r3, #1
 8000c26:	4621      	mov	r1, r4
 8000c28:	4630      	mov	r0, r6
 8000c2a:	d002      	beq.n	8000c32 <_fwalk_reent+0x36>
 8000c2c:	47c0      	blx	r8
 8000c2e:	ea49 0900 	orr.w	r9, r9, r0
 8000c32:	1c6b      	adds	r3, r5, #1
 8000c34:	f104 0468 	add.w	r4, r4, #104	; 0x68
 8000c38:	d1ed      	bne.n	8000c16 <_fwalk_reent+0x1a>
 8000c3a:	683f      	ldr	r7, [r7, #0]
 8000c3c:	2f00      	cmp	r7, #0
 8000c3e:	d1e6      	bne.n	8000c0e <_fwalk_reent+0x12>
 8000c40:	4648      	mov	r0, r9
 8000c42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000c46:	46b9      	mov	r9, r7
 8000c48:	4648      	mov	r0, r9
 8000c4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000c4e:	bf00      	nop

08000c50 <__swhatbuf_r>:
 8000c50:	b570      	push	{r4, r5, r6, lr}
 8000c52:	460c      	mov	r4, r1
 8000c54:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8000c58:	2900      	cmp	r1, #0
 8000c5a:	b090      	sub	sp, #64	; 0x40
 8000c5c:	4615      	mov	r5, r2
 8000c5e:	461e      	mov	r6, r3
 8000c60:	db13      	blt.n	8000c8a <__swhatbuf_r+0x3a>
 8000c62:	aa01      	add	r2, sp, #4
 8000c64:	f001 fa64 	bl	8002130 <_fstat_r>
 8000c68:	2800      	cmp	r0, #0
 8000c6a:	db0e      	blt.n	8000c8a <__swhatbuf_r+0x3a>
 8000c6c:	9a02      	ldr	r2, [sp, #8]
 8000c6e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8000c72:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
 8000c76:	fab2 f282 	clz	r2, r2
 8000c7a:	0952      	lsrs	r2, r2, #5
 8000c7c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000c80:	2000      	movs	r0, #0
 8000c82:	6032      	str	r2, [r6, #0]
 8000c84:	602b      	str	r3, [r5, #0]
 8000c86:	b010      	add	sp, #64	; 0x40
 8000c88:	bd70      	pop	{r4, r5, r6, pc}
 8000c8a:	89a3      	ldrh	r3, [r4, #12]
 8000c8c:	2200      	movs	r2, #0
 8000c8e:	061b      	lsls	r3, r3, #24
 8000c90:	6032      	str	r2, [r6, #0]
 8000c92:	d504      	bpl.n	8000c9e <__swhatbuf_r+0x4e>
 8000c94:	2340      	movs	r3, #64	; 0x40
 8000c96:	2000      	movs	r0, #0
 8000c98:	602b      	str	r3, [r5, #0]
 8000c9a:	b010      	add	sp, #64	; 0x40
 8000c9c:	bd70      	pop	{r4, r5, r6, pc}
 8000c9e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000ca2:	2000      	movs	r0, #0
 8000ca4:	602b      	str	r3, [r5, #0]
 8000ca6:	b010      	add	sp, #64	; 0x40
 8000ca8:	bd70      	pop	{r4, r5, r6, pc}
 8000caa:	bf00      	nop

08000cac <__smakebuf_r>:
 8000cac:	898a      	ldrh	r2, [r1, #12]
 8000cae:	0792      	lsls	r2, r2, #30
 8000cb0:	460b      	mov	r3, r1
 8000cb2:	d506      	bpl.n	8000cc2 <__smakebuf_r+0x16>
 8000cb4:	f101 0247 	add.w	r2, r1, #71	; 0x47
 8000cb8:	2101      	movs	r1, #1
 8000cba:	601a      	str	r2, [r3, #0]
 8000cbc:	611a      	str	r2, [r3, #16]
 8000cbe:	6159      	str	r1, [r3, #20]
 8000cc0:	4770      	bx	lr
 8000cc2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cc4:	b083      	sub	sp, #12
 8000cc6:	ab01      	add	r3, sp, #4
 8000cc8:	466a      	mov	r2, sp
 8000cca:	460c      	mov	r4, r1
 8000ccc:	4605      	mov	r5, r0
 8000cce:	f7ff ffbf 	bl	8000c50 <__swhatbuf_r>
 8000cd2:	9900      	ldr	r1, [sp, #0]
 8000cd4:	4606      	mov	r6, r0
 8000cd6:	4628      	mov	r0, r5
 8000cd8:	f000 f87a 	bl	8000dd0 <_malloc_r>
 8000cdc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8000ce0:	b1d0      	cbz	r0, 8000d18 <__smakebuf_r+0x6c>
 8000ce2:	9a01      	ldr	r2, [sp, #4]
 8000ce4:	4f12      	ldr	r7, [pc, #72]	; (8000d30 <__smakebuf_r+0x84>)
 8000ce6:	9900      	ldr	r1, [sp, #0]
 8000ce8:	62af      	str	r7, [r5, #40]	; 0x28
 8000cea:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000cee:	81a3      	strh	r3, [r4, #12]
 8000cf0:	6020      	str	r0, [r4, #0]
 8000cf2:	6120      	str	r0, [r4, #16]
 8000cf4:	6161      	str	r1, [r4, #20]
 8000cf6:	b91a      	cbnz	r2, 8000d00 <__smakebuf_r+0x54>
 8000cf8:	4333      	orrs	r3, r6
 8000cfa:	81a3      	strh	r3, [r4, #12]
 8000cfc:	b003      	add	sp, #12
 8000cfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d00:	4628      	mov	r0, r5
 8000d02:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8000d06:	f001 fa1b 	bl	8002140 <_isatty_r>
 8000d0a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8000d0e:	2800      	cmp	r0, #0
 8000d10:	d0f2      	beq.n	8000cf8 <__smakebuf_r+0x4c>
 8000d12:	f043 0301 	orr.w	r3, r3, #1
 8000d16:	e7ef      	b.n	8000cf8 <__smakebuf_r+0x4c>
 8000d18:	059a      	lsls	r2, r3, #22
 8000d1a:	d4ef      	bmi.n	8000cfc <__smakebuf_r+0x50>
 8000d1c:	f104 0247 	add.w	r2, r4, #71	; 0x47
 8000d20:	f043 0302 	orr.w	r3, r3, #2
 8000d24:	2101      	movs	r1, #1
 8000d26:	81a3      	strh	r3, [r4, #12]
 8000d28:	6022      	str	r2, [r4, #0]
 8000d2a:	6122      	str	r2, [r4, #16]
 8000d2c:	6161      	str	r1, [r4, #20]
 8000d2e:	e7e5      	b.n	8000cfc <__smakebuf_r+0x50>
 8000d30:	08000985 	.word	0x08000985
	...

08000d40 <_free_r>:
 8000d40:	b191      	cbz	r1, 8000d68 <_free_r+0x28>
 8000d42:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000d46:	3904      	subs	r1, #4
 8000d48:	2b00      	cmp	r3, #0
 8000d4a:	bfb8      	it	lt
 8000d4c:	18c9      	addlt	r1, r1, r3
 8000d4e:	4b1f      	ldr	r3, [pc, #124]	; (8000dcc <_free_r+0x8c>)
 8000d50:	681a      	ldr	r2, [r3, #0]
 8000d52:	b1fa      	cbz	r2, 8000d94 <_free_r+0x54>
 8000d54:	428a      	cmp	r2, r1
 8000d56:	b430      	push	{r4, r5}
 8000d58:	d90a      	bls.n	8000d70 <_free_r+0x30>
 8000d5a:	6808      	ldr	r0, [r1, #0]
 8000d5c:	180c      	adds	r4, r1, r0
 8000d5e:	42a2      	cmp	r2, r4
 8000d60:	d026      	beq.n	8000db0 <_free_r+0x70>
 8000d62:	604a      	str	r2, [r1, #4]
 8000d64:	6019      	str	r1, [r3, #0]
 8000d66:	bc30      	pop	{r4, r5}
 8000d68:	4770      	bx	lr
 8000d6a:	428b      	cmp	r3, r1
 8000d6c:	d803      	bhi.n	8000d76 <_free_r+0x36>
 8000d6e:	461a      	mov	r2, r3
 8000d70:	6853      	ldr	r3, [r2, #4]
 8000d72:	2b00      	cmp	r3, #0
 8000d74:	d1f9      	bne.n	8000d6a <_free_r+0x2a>
 8000d76:	6814      	ldr	r4, [r2, #0]
 8000d78:	1915      	adds	r5, r2, r4
 8000d7a:	428d      	cmp	r5, r1
 8000d7c:	d00d      	beq.n	8000d9a <_free_r+0x5a>
 8000d7e:	d806      	bhi.n	8000d8e <_free_r+0x4e>
 8000d80:	6808      	ldr	r0, [r1, #0]
 8000d82:	180c      	adds	r4, r1, r0
 8000d84:	429c      	cmp	r4, r3
 8000d86:	d019      	beq.n	8000dbc <_free_r+0x7c>
 8000d88:	604b      	str	r3, [r1, #4]
 8000d8a:	6051      	str	r1, [r2, #4]
 8000d8c:	e7eb      	b.n	8000d66 <_free_r+0x26>
 8000d8e:	230c      	movs	r3, #12
 8000d90:	6003      	str	r3, [r0, #0]
 8000d92:	e7e8      	b.n	8000d66 <_free_r+0x26>
 8000d94:	604a      	str	r2, [r1, #4]
 8000d96:	6019      	str	r1, [r3, #0]
 8000d98:	4770      	bx	lr
 8000d9a:	6809      	ldr	r1, [r1, #0]
 8000d9c:	440c      	add	r4, r1
 8000d9e:	1911      	adds	r1, r2, r4
 8000da0:	4299      	cmp	r1, r3
 8000da2:	6014      	str	r4, [r2, #0]
 8000da4:	d1df      	bne.n	8000d66 <_free_r+0x26>
 8000da6:	cb0a      	ldmia	r3, {r1, r3}
 8000da8:	440c      	add	r4, r1
 8000daa:	6053      	str	r3, [r2, #4]
 8000dac:	6014      	str	r4, [r2, #0]
 8000dae:	e7da      	b.n	8000d66 <_free_r+0x26>
 8000db0:	6814      	ldr	r4, [r2, #0]
 8000db2:	6852      	ldr	r2, [r2, #4]
 8000db4:	604a      	str	r2, [r1, #4]
 8000db6:	4420      	add	r0, r4
 8000db8:	6008      	str	r0, [r1, #0]
 8000dba:	e7d3      	b.n	8000d64 <_free_r+0x24>
 8000dbc:	681c      	ldr	r4, [r3, #0]
 8000dbe:	685b      	ldr	r3, [r3, #4]
 8000dc0:	604b      	str	r3, [r1, #4]
 8000dc2:	4420      	add	r0, r4
 8000dc4:	6008      	str	r0, [r1, #0]
 8000dc6:	6051      	str	r1, [r2, #4]
 8000dc8:	e7cd      	b.n	8000d66 <_free_r+0x26>
 8000dca:	bf00      	nop
 8000dcc:	20000868 	.word	0x20000868

08000dd0 <_malloc_r>:
 8000dd0:	b570      	push	{r4, r5, r6, lr}
 8000dd2:	1ccc      	adds	r4, r1, #3
 8000dd4:	f024 0403 	bic.w	r4, r4, #3
 8000dd8:	3408      	adds	r4, #8
 8000dda:	2c0c      	cmp	r4, #12
 8000ddc:	bf38      	it	cc
 8000dde:	240c      	movcc	r4, #12
 8000de0:	2c00      	cmp	r4, #0
 8000de2:	4606      	mov	r6, r0
 8000de4:	db3b      	blt.n	8000e5e <_malloc_r+0x8e>
 8000de6:	42a1      	cmp	r1, r4
 8000de8:	d839      	bhi.n	8000e5e <_malloc_r+0x8e>
 8000dea:	4d27      	ldr	r5, [pc, #156]	; (8000e88 <_malloc_r+0xb8>)
 8000dec:	6829      	ldr	r1, [r5, #0]
 8000dee:	b151      	cbz	r1, 8000e06 <_malloc_r+0x36>
 8000df0:	680a      	ldr	r2, [r1, #0]
 8000df2:	1b12      	subs	r2, r2, r4
 8000df4:	d404      	bmi.n	8000e00 <_malloc_r+0x30>
 8000df6:	e036      	b.n	8000e66 <_malloc_r+0x96>
 8000df8:	681a      	ldr	r2, [r3, #0]
 8000dfa:	1b12      	subs	r2, r2, r4
 8000dfc:	d51a      	bpl.n	8000e34 <_malloc_r+0x64>
 8000dfe:	4619      	mov	r1, r3
 8000e00:	684b      	ldr	r3, [r1, #4]
 8000e02:	2b00      	cmp	r3, #0
 8000e04:	d1f8      	bne.n	8000df8 <_malloc_r+0x28>
 8000e06:	6869      	ldr	r1, [r5, #4]
 8000e08:	2900      	cmp	r1, #0
 8000e0a:	d037      	beq.n	8000e7c <_malloc_r+0xac>
 8000e0c:	4621      	mov	r1, r4
 8000e0e:	4630      	mov	r0, r6
 8000e10:	f001 f97e 	bl	8002110 <_sbrk_r>
 8000e14:	1c43      	adds	r3, r0, #1
 8000e16:	d022      	beq.n	8000e5e <_malloc_r+0x8e>
 8000e18:	1cc3      	adds	r3, r0, #3
 8000e1a:	f023 0503 	bic.w	r5, r3, #3
 8000e1e:	42a8      	cmp	r0, r5
 8000e20:	d005      	beq.n	8000e2e <_malloc_r+0x5e>
 8000e22:	1a29      	subs	r1, r5, r0
 8000e24:	4630      	mov	r0, r6
 8000e26:	f001 f973 	bl	8002110 <_sbrk_r>
 8000e2a:	3001      	adds	r0, #1
 8000e2c:	d017      	beq.n	8000e5e <_malloc_r+0x8e>
 8000e2e:	602c      	str	r4, [r5, #0]
 8000e30:	462b      	mov	r3, r5
 8000e32:	e004      	b.n	8000e3e <_malloc_r+0x6e>
 8000e34:	2a0b      	cmp	r2, #11
 8000e36:	d90d      	bls.n	8000e54 <_malloc_r+0x84>
 8000e38:	601a      	str	r2, [r3, #0]
 8000e3a:	4413      	add	r3, r2
 8000e3c:	601c      	str	r4, [r3, #0]
 8000e3e:	f103 000b 	add.w	r0, r3, #11
 8000e42:	f020 0007 	bic.w	r0, r0, #7
 8000e46:	1d1a      	adds	r2, r3, #4
 8000e48:	1a82      	subs	r2, r0, r2
 8000e4a:	d002      	beq.n	8000e52 <_malloc_r+0x82>
 8000e4c:	4251      	negs	r1, r2
 8000e4e:	5099      	str	r1, [r3, r2]
 8000e50:	bd70      	pop	{r4, r5, r6, pc}
 8000e52:	bd70      	pop	{r4, r5, r6, pc}
 8000e54:	428b      	cmp	r3, r1
 8000e56:	d00e      	beq.n	8000e76 <_malloc_r+0xa6>
 8000e58:	685a      	ldr	r2, [r3, #4]
 8000e5a:	604a      	str	r2, [r1, #4]
 8000e5c:	e7ef      	b.n	8000e3e <_malloc_r+0x6e>
 8000e5e:	230c      	movs	r3, #12
 8000e60:	6033      	str	r3, [r6, #0]
 8000e62:	2000      	movs	r0, #0
 8000e64:	bd70      	pop	{r4, r5, r6, pc}
 8000e66:	2a0b      	cmp	r2, #11
 8000e68:	d803      	bhi.n	8000e72 <_malloc_r+0xa2>
 8000e6a:	684a      	ldr	r2, [r1, #4]
 8000e6c:	460b      	mov	r3, r1
 8000e6e:	602a      	str	r2, [r5, #0]
 8000e70:	e7e5      	b.n	8000e3e <_malloc_r+0x6e>
 8000e72:	460b      	mov	r3, r1
 8000e74:	e7e0      	b.n	8000e38 <_malloc_r+0x68>
 8000e76:	460a      	mov	r2, r1
 8000e78:	460b      	mov	r3, r1
 8000e7a:	e7f8      	b.n	8000e6e <_malloc_r+0x9e>
 8000e7c:	4630      	mov	r0, r6
 8000e7e:	f001 f947 	bl	8002110 <_sbrk_r>
 8000e82:	6068      	str	r0, [r5, #4]
 8000e84:	e7c2      	b.n	8000e0c <_malloc_r+0x3c>
 8000e86:	bf00      	nop
 8000e88:	20000868 	.word	0x20000868
 8000e8c:	00000000 	.word	0x00000000

08000e90 <__sfputc_r>:
 8000e90:	6893      	ldr	r3, [r2, #8]
 8000e92:	3b01      	subs	r3, #1
 8000e94:	2b00      	cmp	r3, #0
 8000e96:	b410      	push	{r4}
 8000e98:	6093      	str	r3, [r2, #8]
 8000e9a:	db08      	blt.n	8000eae <__sfputc_r+0x1e>
 8000e9c:	b2cc      	uxtb	r4, r1
 8000e9e:	6813      	ldr	r3, [r2, #0]
 8000ea0:	1c58      	adds	r0, r3, #1
 8000ea2:	6010      	str	r0, [r2, #0]
 8000ea4:	7019      	strb	r1, [r3, #0]
 8000ea6:	4620      	mov	r0, r4
 8000ea8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000eac:	4770      	bx	lr
 8000eae:	6994      	ldr	r4, [r2, #24]
 8000eb0:	42a3      	cmp	r3, r4
 8000eb2:	db02      	blt.n	8000eba <__sfputc_r+0x2a>
 8000eb4:	b2cc      	uxtb	r4, r1
 8000eb6:	2c0a      	cmp	r4, #10
 8000eb8:	d1f1      	bne.n	8000e9e <__sfputc_r+0xe>
 8000eba:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000ebe:	f7ff bb9f 	b.w	8000600 <__swbuf_r>
 8000ec2:	bf00      	nop

08000ec4 <__sfputs_r>:
 8000ec4:	b193      	cbz	r3, 8000eec <__sfputs_r+0x28>
 8000ec6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000ec8:	4614      	mov	r4, r2
 8000eca:	460f      	mov	r7, r1
 8000ecc:	4606      	mov	r6, r0
 8000ece:	18d5      	adds	r5, r2, r3
 8000ed0:	e001      	b.n	8000ed6 <__sfputs_r+0x12>
 8000ed2:	42ac      	cmp	r4, r5
 8000ed4:	d008      	beq.n	8000ee8 <__sfputs_r+0x24>
 8000ed6:	463a      	mov	r2, r7
 8000ed8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8000edc:	4630      	mov	r0, r6
 8000ede:	f7ff ffd7 	bl	8000e90 <__sfputc_r>
 8000ee2:	1c43      	adds	r3, r0, #1
 8000ee4:	d1f5      	bne.n	8000ed2 <__sfputs_r+0xe>
 8000ee6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000ee8:	2000      	movs	r0, #0
 8000eea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000eec:	2000      	movs	r0, #0
 8000eee:	4770      	bx	lr

08000ef0 <__sprint_r>:
 8000ef0:	6893      	ldr	r3, [r2, #8]
 8000ef2:	b510      	push	{r4, lr}
 8000ef4:	4614      	mov	r4, r2
 8000ef6:	b913      	cbnz	r3, 8000efe <__sprint_r+0xe>
 8000ef8:	6053      	str	r3, [r2, #4]
 8000efa:	4618      	mov	r0, r3
 8000efc:	bd10      	pop	{r4, pc}
 8000efe:	f000 fb7f 	bl	8001600 <__sfvwrite_r>
 8000f02:	2300      	movs	r3, #0
 8000f04:	60a3      	str	r3, [r4, #8]
 8000f06:	6063      	str	r3, [r4, #4]
 8000f08:	bd10      	pop	{r4, pc}
 8000f0a:	bf00      	nop

08000f0c <_vfiprintf_r>:
 8000f0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000f10:	b09d      	sub	sp, #116	; 0x74
 8000f12:	4689      	mov	r9, r1
 8000f14:	4614      	mov	r4, r2
 8000f16:	9303      	str	r3, [sp, #12]
 8000f18:	4682      	mov	sl, r0
 8000f1a:	b118      	cbz	r0, 8000f24 <_vfiprintf_r+0x18>
 8000f1c:	6983      	ldr	r3, [r0, #24]
 8000f1e:	2b00      	cmp	r3, #0
 8000f20:	f000 810a 	beq.w	8001138 <_vfiprintf_r+0x22c>
 8000f24:	4b8a      	ldr	r3, [pc, #552]	; (8001150 <_vfiprintf_r+0x244>)
 8000f26:	4599      	cmp	r9, r3
 8000f28:	f000 810c 	beq.w	8001144 <_vfiprintf_r+0x238>
 8000f2c:	4b89      	ldr	r3, [pc, #548]	; (8001154 <_vfiprintf_r+0x248>)
 8000f2e:	4599      	cmp	r9, r3
 8000f30:	f000 810b 	beq.w	800114a <_vfiprintf_r+0x23e>
 8000f34:	4b88      	ldr	r3, [pc, #544]	; (8001158 <_vfiprintf_r+0x24c>)
 8000f36:	4599      	cmp	r9, r3
 8000f38:	bf08      	it	eq
 8000f3a:	f8da 900c 	ldreq.w	r9, [sl, #12]
 8000f3e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8000f42:	0718      	lsls	r0, r3, #28
 8000f44:	f140 80ee 	bpl.w	8001124 <_vfiprintf_r+0x218>
 8000f48:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8000f4c:	2b00      	cmp	r3, #0
 8000f4e:	f000 80e9 	beq.w	8001124 <_vfiprintf_r+0x218>
 8000f52:	2330      	movs	r3, #48	; 0x30
 8000f54:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8000f58:	7823      	ldrb	r3, [r4, #0]
 8000f5a:	4e80      	ldr	r6, [pc, #512]	; (800115c <_vfiprintf_r+0x250>)
 8000f5c:	2100      	movs	r1, #0
 8000f5e:	2220      	movs	r2, #32
 8000f60:	9109      	str	r1, [sp, #36]	; 0x24
 8000f62:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
 8000f66:	2701      	movs	r7, #1
 8000f68:	2b00      	cmp	r3, #0
 8000f6a:	f000 8084 	beq.w	8001076 <_vfiprintf_r+0x16a>
 8000f6e:	2b25      	cmp	r3, #37	; 0x25
 8000f70:	4625      	mov	r5, r4
 8000f72:	d103      	bne.n	8000f7c <_vfiprintf_r+0x70>
 8000f74:	e017      	b.n	8000fa6 <_vfiprintf_r+0x9a>
 8000f76:	2b25      	cmp	r3, #37	; 0x25
 8000f78:	f000 8085 	beq.w	8001086 <_vfiprintf_r+0x17a>
 8000f7c:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8000f80:	2b00      	cmp	r3, #0
 8000f82:	d1f8      	bne.n	8000f76 <_vfiprintf_r+0x6a>
 8000f84:	ebb5 0b04 	subs.w	fp, r5, r4
 8000f88:	d075      	beq.n	8001076 <_vfiprintf_r+0x16a>
 8000f8a:	4622      	mov	r2, r4
 8000f8c:	465b      	mov	r3, fp
 8000f8e:	4649      	mov	r1, r9
 8000f90:	4650      	mov	r0, sl
 8000f92:	f7ff ff97 	bl	8000ec4 <__sfputs_r>
 8000f96:	3001      	adds	r0, #1
 8000f98:	d06d      	beq.n	8001076 <_vfiprintf_r+0x16a>
 8000f9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000f9c:	782a      	ldrb	r2, [r5, #0]
 8000f9e:	445b      	add	r3, fp
 8000fa0:	9309      	str	r3, [sp, #36]	; 0x24
 8000fa2:	2a00      	cmp	r2, #0
 8000fa4:	d067      	beq.n	8001076 <_vfiprintf_r+0x16a>
 8000fa6:	2300      	movs	r3, #0
 8000fa8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000fac:	3501      	adds	r5, #1
 8000fae:	9304      	str	r3, [sp, #16]
 8000fb0:	9307      	str	r3, [sp, #28]
 8000fb2:	9306      	str	r3, [sp, #24]
 8000fb4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8000fb8:	931a      	str	r3, [sp, #104]	; 0x68
 8000fba:	9205      	str	r2, [sp, #20]
 8000fbc:	e004      	b.n	8000fc8 <_vfiprintf_r+0xbc>
 8000fbe:	9a04      	ldr	r2, [sp, #16]
 8000fc0:	fa07 f303 	lsl.w	r3, r7, r3
 8000fc4:	4313      	orrs	r3, r2
 8000fc6:	9304      	str	r3, [sp, #16]
 8000fc8:	7829      	ldrb	r1, [r5, #0]
 8000fca:	2205      	movs	r2, #5
 8000fcc:	4630      	mov	r0, r6
 8000fce:	f000 fc8f 	bl	80018f0 <memchr>
 8000fd2:	462c      	mov	r4, r5
 8000fd4:	1b83      	subs	r3, r0, r6
 8000fd6:	3501      	adds	r5, #1
 8000fd8:	2800      	cmp	r0, #0
 8000fda:	d1f0      	bne.n	8000fbe <_vfiprintf_r+0xb2>
 8000fdc:	9b04      	ldr	r3, [sp, #16]
 8000fde:	06d9      	lsls	r1, r3, #27
 8000fe0:	bf44      	itt	mi
 8000fe2:	2220      	movmi	r2, #32
 8000fe4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8000fe8:	7821      	ldrb	r1, [r4, #0]
 8000fea:	071a      	lsls	r2, r3, #28
 8000fec:	bf44      	itt	mi
 8000fee:	222b      	movmi	r2, #43	; 0x2b
 8000ff0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8000ff4:	292a      	cmp	r1, #42	; 0x2a
 8000ff6:	d069      	beq.n	80010cc <_vfiprintf_r+0x1c0>
 8000ff8:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 8000ffc:	2a09      	cmp	r2, #9
 8000ffe:	d80b      	bhi.n	8001018 <_vfiprintf_r+0x10c>
 8001000:	9b07      	ldr	r3, [sp, #28]
 8001002:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8001006:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800100a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 800100e:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 8001012:	2a09      	cmp	r2, #9
 8001014:	d9f5      	bls.n	8001002 <_vfiprintf_r+0xf6>
 8001016:	9307      	str	r3, [sp, #28]
 8001018:	292e      	cmp	r1, #46	; 0x2e
 800101a:	d03f      	beq.n	800109c <_vfiprintf_r+0x190>
 800101c:	4d50      	ldr	r5, [pc, #320]	; (8001160 <_vfiprintf_r+0x254>)
 800101e:	2203      	movs	r2, #3
 8001020:	4628      	mov	r0, r5
 8001022:	f000 fc65 	bl	80018f0 <memchr>
 8001026:	b138      	cbz	r0, 8001038 <_vfiprintf_r+0x12c>
 8001028:	9b04      	ldr	r3, [sp, #16]
 800102a:	1b40      	subs	r0, r0, r5
 800102c:	2240      	movs	r2, #64	; 0x40
 800102e:	fa02 f000 	lsl.w	r0, r2, r0
 8001032:	4303      	orrs	r3, r0
 8001034:	3401      	adds	r4, #1
 8001036:	9304      	str	r3, [sp, #16]
 8001038:	7821      	ldrb	r1, [r4, #0]
 800103a:	484a      	ldr	r0, [pc, #296]	; (8001164 <_vfiprintf_r+0x258>)
 800103c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8001040:	2206      	movs	r2, #6
 8001042:	3401      	adds	r4, #1
 8001044:	f000 fc54 	bl	80018f0 <memchr>
 8001048:	2800      	cmp	r0, #0
 800104a:	d049      	beq.n	80010e0 <_vfiprintf_r+0x1d4>
 800104c:	4b46      	ldr	r3, [pc, #280]	; (8001168 <_vfiprintf_r+0x25c>)
 800104e:	b1f3      	cbz	r3, 800108e <_vfiprintf_r+0x182>
 8001050:	ab03      	add	r3, sp, #12
 8001052:	9300      	str	r3, [sp, #0]
 8001054:	464a      	mov	r2, r9
 8001056:	4b45      	ldr	r3, [pc, #276]	; (800116c <_vfiprintf_r+0x260>)
 8001058:	a904      	add	r1, sp, #16
 800105a:	4650      	mov	r0, sl
 800105c:	f3af 8000 	nop.w
 8001060:	4680      	mov	r8, r0
 8001062:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
 8001066:	d006      	beq.n	8001076 <_vfiprintf_r+0x16a>
 8001068:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800106a:	4443      	add	r3, r8
 800106c:	9309      	str	r3, [sp, #36]	; 0x24
 800106e:	7823      	ldrb	r3, [r4, #0]
 8001070:	2b00      	cmp	r3, #0
 8001072:	f47f af7c 	bne.w	8000f6e <_vfiprintf_r+0x62>
 8001076:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 800107a:	065b      	lsls	r3, r3, #25
 800107c:	d459      	bmi.n	8001132 <_vfiprintf_r+0x226>
 800107e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8001080:	b01d      	add	sp, #116	; 0x74
 8001082:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001086:	ebb5 0b04 	subs.w	fp, r5, r4
 800108a:	d08c      	beq.n	8000fa6 <_vfiprintf_r+0x9a>
 800108c:	e77d      	b.n	8000f8a <_vfiprintf_r+0x7e>
 800108e:	9b03      	ldr	r3, [sp, #12]
 8001090:	3307      	adds	r3, #7
 8001092:	f023 0307 	bic.w	r3, r3, #7
 8001096:	3308      	adds	r3, #8
 8001098:	9303      	str	r3, [sp, #12]
 800109a:	e7e5      	b.n	8001068 <_vfiprintf_r+0x15c>
 800109c:	7861      	ldrb	r1, [r4, #1]
 800109e:	292a      	cmp	r1, #42	; 0x2a
 80010a0:	f104 0001 	add.w	r0, r4, #1
 80010a4:	d026      	beq.n	80010f4 <_vfiprintf_r+0x1e8>
 80010a6:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 80010aa:	2300      	movs	r3, #0
 80010ac:	2a09      	cmp	r2, #9
 80010ae:	9305      	str	r3, [sp, #20]
 80010b0:	4604      	mov	r4, r0
 80010b2:	d8b3      	bhi.n	800101c <_vfiprintf_r+0x110>
 80010b4:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80010b8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80010bc:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80010c0:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 80010c4:	2a09      	cmp	r2, #9
 80010c6:	d9f5      	bls.n	80010b4 <_vfiprintf_r+0x1a8>
 80010c8:	9305      	str	r3, [sp, #20]
 80010ca:	e7a7      	b.n	800101c <_vfiprintf_r+0x110>
 80010cc:	9a03      	ldr	r2, [sp, #12]
 80010ce:	6811      	ldr	r1, [r2, #0]
 80010d0:	3204      	adds	r2, #4
 80010d2:	2900      	cmp	r1, #0
 80010d4:	9203      	str	r2, [sp, #12]
 80010d6:	db1f      	blt.n	8001118 <_vfiprintf_r+0x20c>
 80010d8:	9107      	str	r1, [sp, #28]
 80010da:	7861      	ldrb	r1, [r4, #1]
 80010dc:	3401      	adds	r4, #1
 80010de:	e79b      	b.n	8001018 <_vfiprintf_r+0x10c>
 80010e0:	ab03      	add	r3, sp, #12
 80010e2:	9300      	str	r3, [sp, #0]
 80010e4:	464a      	mov	r2, r9
 80010e6:	4b21      	ldr	r3, [pc, #132]	; (800116c <_vfiprintf_r+0x260>)
 80010e8:	a904      	add	r1, sp, #16
 80010ea:	4650      	mov	r0, sl
 80010ec:	f000 f8ea 	bl	80012c4 <_printf_i>
 80010f0:	4680      	mov	r8, r0
 80010f2:	e7b6      	b.n	8001062 <_vfiprintf_r+0x156>
 80010f4:	9b03      	ldr	r3, [sp, #12]
 80010f6:	681a      	ldr	r2, [r3, #0]
 80010f8:	9205      	str	r2, [sp, #20]
 80010fa:	2a00      	cmp	r2, #0
 80010fc:	f103 0304 	add.w	r3, r3, #4
 8001100:	9303      	str	r3, [sp, #12]
 8001102:	bfb8      	it	lt
 8001104:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
 8001108:	f104 0302 	add.w	r3, r4, #2
 800110c:	bfae      	itee	ge
 800110e:	78a1      	ldrbge	r1, [r4, #2]
 8001110:	78a1      	ldrblt	r1, [r4, #2]
 8001112:	9205      	strlt	r2, [sp, #20]
 8001114:	461c      	mov	r4, r3
 8001116:	e781      	b.n	800101c <_vfiprintf_r+0x110>
 8001118:	4249      	negs	r1, r1
 800111a:	f043 0302 	orr.w	r3, r3, #2
 800111e:	9107      	str	r1, [sp, #28]
 8001120:	9304      	str	r3, [sp, #16]
 8001122:	e7da      	b.n	80010da <_vfiprintf_r+0x1ce>
 8001124:	4649      	mov	r1, r9
 8001126:	4650      	mov	r0, sl
 8001128:	f7ff fad2 	bl	80006d0 <__swsetup_r>
 800112c:	2800      	cmp	r0, #0
 800112e:	f43f af10 	beq.w	8000f52 <_vfiprintf_r+0x46>
 8001132:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001136:	e7a3      	b.n	8001080 <_vfiprintf_r+0x174>
 8001138:	f7ff fd1a 	bl	8000b70 <__sinit>
 800113c:	4b04      	ldr	r3, [pc, #16]	; (8001150 <_vfiprintf_r+0x244>)
 800113e:	4599      	cmp	r9, r3
 8001140:	f47f aef4 	bne.w	8000f2c <_vfiprintf_r+0x20>
 8001144:	f8da 9004 	ldr.w	r9, [sl, #4]
 8001148:	e6f9      	b.n	8000f3e <_vfiprintf_r+0x32>
 800114a:	f8da 9008 	ldr.w	r9, [sl, #8]
 800114e:	e6f6      	b.n	8000f3e <_vfiprintf_r+0x32>
 8001150:	08004010 	.word	0x08004010
 8001154:	08003ff0 	.word	0x08003ff0
 8001158:	08003fd0 	.word	0x08003fd0
 800115c:	08004180 	.word	0x08004180
 8001160:	08004188 	.word	0x08004188
 8001164:	0800418c 	.word	0x0800418c
 8001168:	00000000 	.word	0x00000000
 800116c:	08000ec5 	.word	0x08000ec5

08001170 <vfiprintf>:
 8001170:	b410      	push	{r4}
 8001172:	4c04      	ldr	r4, [pc, #16]	; (8001184 <vfiprintf+0x14>)
 8001174:	4613      	mov	r3, r2
 8001176:	460a      	mov	r2, r1
 8001178:	4601      	mov	r1, r0
 800117a:	6820      	ldr	r0, [r4, #0]
 800117c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001180:	f7ff bec4 	b.w	8000f0c <_vfiprintf_r>
 8001184:	20000800 	.word	0x20000800
	...

08001190 <_printf_common>:
 8001190:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001194:	460c      	mov	r4, r1
 8001196:	4691      	mov	r9, r2
 8001198:	690a      	ldr	r2, [r1, #16]
 800119a:	6889      	ldr	r1, [r1, #8]
 800119c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80011a0:	428a      	cmp	r2, r1
 80011a2:	bfb8      	it	lt
 80011a4:	460a      	movlt	r2, r1
 80011a6:	f8c9 2000 	str.w	r2, [r9]
 80011aa:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
 80011ae:	4606      	mov	r6, r0
 80011b0:	461f      	mov	r7, r3
 80011b2:	b111      	cbz	r1, 80011ba <_printf_common+0x2a>
 80011b4:	3201      	adds	r2, #1
 80011b6:	f8c9 2000 	str.w	r2, [r9]
 80011ba:	6823      	ldr	r3, [r4, #0]
 80011bc:	0699      	lsls	r1, r3, #26
 80011be:	d55d      	bpl.n	800127c <_printf_common+0xec>
 80011c0:	f8d9 2000 	ldr.w	r2, [r9]
 80011c4:	3202      	adds	r2, #2
 80011c6:	f8c9 2000 	str.w	r2, [r9]
 80011ca:	6823      	ldr	r3, [r4, #0]
 80011cc:	f013 0f06 	tst.w	r3, #6
 80011d0:	4619      	mov	r1, r3
 80011d2:	d11d      	bne.n	8001210 <_printf_common+0x80>
 80011d4:	68e1      	ldr	r1, [r4, #12]
 80011d6:	1a8a      	subs	r2, r1, r2
 80011d8:	2a00      	cmp	r2, #0
 80011da:	bfd8      	it	le
 80011dc:	4619      	movle	r1, r3
 80011de:	dd17      	ble.n	8001210 <_printf_common+0x80>
 80011e0:	f104 0a19 	add.w	sl, r4, #25
 80011e4:	2500      	movs	r5, #0
 80011e6:	e005      	b.n	80011f4 <_printf_common+0x64>
 80011e8:	68e3      	ldr	r3, [r4, #12]
 80011ea:	f8d9 2000 	ldr.w	r2, [r9]
 80011ee:	1a9b      	subs	r3, r3, r2
 80011f0:	42ab      	cmp	r3, r5
 80011f2:	dd0c      	ble.n	800120e <_printf_common+0x7e>
 80011f4:	2301      	movs	r3, #1
 80011f6:	4652      	mov	r2, sl
 80011f8:	4639      	mov	r1, r7
 80011fa:	4630      	mov	r0, r6
 80011fc:	47c0      	blx	r8
 80011fe:	3001      	adds	r0, #1
 8001200:	f105 0501 	add.w	r5, r5, #1
 8001204:	d1f0      	bne.n	80011e8 <_printf_common+0x58>
 8001206:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800120a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800120e:	6821      	ldr	r1, [r4, #0]
 8001210:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8001214:	3300      	adds	r3, #0
 8001216:	bf18      	it	ne
 8001218:	2301      	movne	r3, #1
 800121a:	068a      	lsls	r2, r1, #26
 800121c:	d50a      	bpl.n	8001234 <_printf_common+0xa4>
 800121e:	18e1      	adds	r1, r4, r3
 8001220:	1c5a      	adds	r2, r3, #1
 8001222:	2030      	movs	r0, #48	; 0x30
 8001224:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8001228:	4422      	add	r2, r4
 800122a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800122e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8001232:	3302      	adds	r3, #2
 8001234:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8001238:	4639      	mov	r1, r7
 800123a:	4630      	mov	r0, r6
 800123c:	47c0      	blx	r8
 800123e:	3001      	adds	r0, #1
 8001240:	d0e1      	beq.n	8001206 <_printf_common+0x76>
 8001242:	6823      	ldr	r3, [r4, #0]
 8001244:	f003 0306 	and.w	r3, r3, #6
 8001248:	2b04      	cmp	r3, #4
 800124a:	d029      	beq.n	80012a0 <_printf_common+0x110>
 800124c:	68a3      	ldr	r3, [r4, #8]
 800124e:	6922      	ldr	r2, [r4, #16]
 8001250:	4293      	cmp	r3, r2
 8001252:	bfc8      	it	gt
 8001254:	f04f 0900 	movgt.w	r9, #0
 8001258:	dd30      	ble.n	80012bc <_printf_common+0x12c>
 800125a:	1a9b      	subs	r3, r3, r2
 800125c:	4499      	add	r9, r3
 800125e:	341a      	adds	r4, #26
 8001260:	2500      	movs	r5, #0
 8001262:	e001      	b.n	8001268 <_printf_common+0xd8>
 8001264:	454d      	cmp	r5, r9
 8001266:	d029      	beq.n	80012bc <_printf_common+0x12c>
 8001268:	2301      	movs	r3, #1
 800126a:	4622      	mov	r2, r4
 800126c:	4639      	mov	r1, r7
 800126e:	4630      	mov	r0, r6
 8001270:	47c0      	blx	r8
 8001272:	3001      	adds	r0, #1
 8001274:	f105 0501 	add.w	r5, r5, #1
 8001278:	d1f4      	bne.n	8001264 <_printf_common+0xd4>
 800127a:	e7c4      	b.n	8001206 <_printf_common+0x76>
 800127c:	f013 0f06 	tst.w	r3, #6
 8001280:	d108      	bne.n	8001294 <_printf_common+0x104>
 8001282:	68e1      	ldr	r1, [r4, #12]
 8001284:	f8d9 2000 	ldr.w	r2, [r9]
 8001288:	1a8a      	subs	r2, r1, r2
 800128a:	2a00      	cmp	r2, #0
 800128c:	bfd8      	it	le
 800128e:	4619      	movle	r1, r3
 8001290:	dca6      	bgt.n	80011e0 <_printf_common+0x50>
 8001292:	e7bd      	b.n	8001210 <_printf_common+0x80>
 8001294:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8001298:	3300      	adds	r3, #0
 800129a:	bf18      	it	ne
 800129c:	2301      	movne	r3, #1
 800129e:	e7c9      	b.n	8001234 <_printf_common+0xa4>
 80012a0:	f8d9 1000 	ldr.w	r1, [r9]
 80012a4:	68e0      	ldr	r0, [r4, #12]
 80012a6:	68a3      	ldr	r3, [r4, #8]
 80012a8:	6922      	ldr	r2, [r4, #16]
 80012aa:	eba0 0901 	sub.w	r9, r0, r1
 80012ae:	4293      	cmp	r3, r2
 80012b0:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 80012b4:	dcd1      	bgt.n	800125a <_printf_common+0xca>
 80012b6:	f1b9 0f00 	cmp.w	r9, #0
 80012ba:	d1d0      	bne.n	800125e <_printf_common+0xce>
 80012bc:	2000      	movs	r0, #0
 80012be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80012c2:	bf00      	nop

080012c4 <_printf_i>:
 80012c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80012c8:	460c      	mov	r4, r1
 80012ca:	7e09      	ldrb	r1, [r1, #24]
 80012cc:	b085      	sub	sp, #20
 80012ce:	296e      	cmp	r1, #110	; 0x6e
 80012d0:	4606      	mov	r6, r0
 80012d2:	4617      	mov	r7, r2
 80012d4:	980c      	ldr	r0, [sp, #48]	; 0x30
 80012d6:	4698      	mov	r8, r3
 80012d8:	f104 0c43 	add.w	ip, r4, #67	; 0x43
 80012dc:	d055      	beq.n	800138a <_printf_i+0xc6>
 80012de:	d80f      	bhi.n	8001300 <_printf_i+0x3c>
 80012e0:	2963      	cmp	r1, #99	; 0x63
 80012e2:	f000 811b 	beq.w	800151c <_printf_i+0x258>
 80012e6:	f200 80d6 	bhi.w	8001496 <_printf_i+0x1d2>
 80012ea:	2900      	cmp	r1, #0
 80012ec:	d05c      	beq.n	80013a8 <_printf_i+0xe4>
 80012ee:	2958      	cmp	r1, #88	; 0x58
 80012f0:	f040 80e8 	bne.w	80014c4 <_printf_i+0x200>
 80012f4:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 80012f8:	6822      	ldr	r2, [r4, #0]
 80012fa:	f8df e260 	ldr.w	lr, [pc, #608]	; 800155c <_printf_i+0x298>
 80012fe:	e013      	b.n	8001328 <_printf_i+0x64>
 8001300:	2973      	cmp	r1, #115	; 0x73
 8001302:	f000 80fd 	beq.w	8001500 <_printf_i+0x23c>
 8001306:	f200 8089 	bhi.w	800141c <_printf_i+0x158>
 800130a:	296f      	cmp	r1, #111	; 0x6f
 800130c:	f000 80e4 	beq.w	80014d8 <_printf_i+0x214>
 8001310:	2970      	cmp	r1, #112	; 0x70
 8001312:	f040 80d7 	bne.w	80014c4 <_printf_i+0x200>
 8001316:	6822      	ldr	r2, [r4, #0]
 8001318:	f042 0220 	orr.w	r2, r2, #32
 800131c:	6022      	str	r2, [r4, #0]
 800131e:	2378      	movs	r3, #120	; 0x78
 8001320:	f8df e23c 	ldr.w	lr, [pc, #572]	; 8001560 <_printf_i+0x29c>
 8001324:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8001328:	6803      	ldr	r3, [r0, #0]
 800132a:	0615      	lsls	r5, r2, #24
 800132c:	f103 0104 	add.w	r1, r3, #4
 8001330:	f100 80ff 	bmi.w	8001532 <_printf_i+0x26e>
 8001334:	0655      	lsls	r5, r2, #25
 8001336:	bf4b      	itete	mi
 8001338:	881b      	ldrhmi	r3, [r3, #0]
 800133a:	681b      	ldrpl	r3, [r3, #0]
 800133c:	6001      	strmi	r1, [r0, #0]
 800133e:	6001      	strpl	r1, [r0, #0]
 8001340:	07d0      	lsls	r0, r2, #31
 8001342:	bf44      	itt	mi
 8001344:	f042 0220 	orrmi.w	r2, r2, #32
 8001348:	6022      	strmi	r2, [r4, #0]
 800134a:	2b00      	cmp	r3, #0
 800134c:	f040 8095 	bne.w	800147a <_printf_i+0x1b6>
 8001350:	6822      	ldr	r2, [r4, #0]
 8001352:	f022 0220 	bic.w	r2, r2, #32
 8001356:	6022      	str	r2, [r4, #0]
 8001358:	2110      	movs	r1, #16
 800135a:	2200      	movs	r2, #0
 800135c:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8001360:	6860      	ldr	r0, [r4, #4]
 8001362:	60a0      	str	r0, [r4, #8]
 8001364:	2800      	cmp	r0, #0
 8001366:	f2c0 808d 	blt.w	8001484 <_printf_i+0x1c0>
 800136a:	6822      	ldr	r2, [r4, #0]
 800136c:	f022 0204 	bic.w	r2, r2, #4
 8001370:	6022      	str	r2, [r4, #0]
 8001372:	2b00      	cmp	r3, #0
 8001374:	d167      	bne.n	8001446 <_printf_i+0x182>
 8001376:	2800      	cmp	r0, #0
 8001378:	f040 8086 	bne.w	8001488 <_printf_i+0x1c4>
 800137c:	4665      	mov	r5, ip
 800137e:	2908      	cmp	r1, #8
 8001380:	d06f      	beq.n	8001462 <_printf_i+0x19e>
 8001382:	ebac 0305 	sub.w	r3, ip, r5
 8001386:	6123      	str	r3, [r4, #16]
 8001388:	e011      	b.n	80013ae <_printf_i+0xea>
 800138a:	6823      	ldr	r3, [r4, #0]
 800138c:	061a      	lsls	r2, r3, #24
 800138e:	f100 80d3 	bmi.w	8001538 <_printf_i+0x274>
 8001392:	f013 0f40 	tst.w	r3, #64	; 0x40
 8001396:	6803      	ldr	r3, [r0, #0]
 8001398:	6962      	ldr	r2, [r4, #20]
 800139a:	f103 0104 	add.w	r1, r3, #4
 800139e:	6001      	str	r1, [r0, #0]
 80013a0:	681b      	ldr	r3, [r3, #0]
 80013a2:	bf14      	ite	ne
 80013a4:	801a      	strhne	r2, [r3, #0]
 80013a6:	601a      	streq	r2, [r3, #0]
 80013a8:	2300      	movs	r3, #0
 80013aa:	4665      	mov	r5, ip
 80013ac:	6123      	str	r3, [r4, #16]
 80013ae:	f8cd 8000 	str.w	r8, [sp]
 80013b2:	463b      	mov	r3, r7
 80013b4:	aa03      	add	r2, sp, #12
 80013b6:	4621      	mov	r1, r4
 80013b8:	4630      	mov	r0, r6
 80013ba:	f7ff fee9 	bl	8001190 <_printf_common>
 80013be:	3001      	adds	r0, #1
 80013c0:	d021      	beq.n	8001406 <_printf_i+0x142>
 80013c2:	462a      	mov	r2, r5
 80013c4:	6923      	ldr	r3, [r4, #16]
 80013c6:	4639      	mov	r1, r7
 80013c8:	4630      	mov	r0, r6
 80013ca:	47c0      	blx	r8
 80013cc:	3001      	adds	r0, #1
 80013ce:	d01a      	beq.n	8001406 <_printf_i+0x142>
 80013d0:	6823      	ldr	r3, [r4, #0]
 80013d2:	68e0      	ldr	r0, [r4, #12]
 80013d4:	f013 0f02 	tst.w	r3, #2
 80013d8:	9b03      	ldr	r3, [sp, #12]
 80013da:	d019      	beq.n	8001410 <_printf_i+0x14c>
 80013dc:	1ac2      	subs	r2, r0, r3
 80013de:	2a00      	cmp	r2, #0
 80013e0:	dd16      	ble.n	8001410 <_printf_i+0x14c>
 80013e2:	f104 0919 	add.w	r9, r4, #25
 80013e6:	2500      	movs	r5, #0
 80013e8:	e004      	b.n	80013f4 <_printf_i+0x130>
 80013ea:	68e0      	ldr	r0, [r4, #12]
 80013ec:	9b03      	ldr	r3, [sp, #12]
 80013ee:	1ac2      	subs	r2, r0, r3
 80013f0:	42aa      	cmp	r2, r5
 80013f2:	dd0d      	ble.n	8001410 <_printf_i+0x14c>
 80013f4:	2301      	movs	r3, #1
 80013f6:	464a      	mov	r2, r9
 80013f8:	4639      	mov	r1, r7
 80013fa:	4630      	mov	r0, r6
 80013fc:	47c0      	blx	r8
 80013fe:	3001      	adds	r0, #1
 8001400:	f105 0501 	add.w	r5, r5, #1
 8001404:	d1f1      	bne.n	80013ea <_printf_i+0x126>
 8001406:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800140a:	b005      	add	sp, #20
 800140c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001410:	4298      	cmp	r0, r3
 8001412:	bfb8      	it	lt
 8001414:	4618      	movlt	r0, r3
 8001416:	b005      	add	sp, #20
 8001418:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800141c:	2975      	cmp	r1, #117	; 0x75
 800141e:	d05b      	beq.n	80014d8 <_printf_i+0x214>
 8001420:	2978      	cmp	r1, #120	; 0x78
 8001422:	d14f      	bne.n	80014c4 <_printf_i+0x200>
 8001424:	6822      	ldr	r2, [r4, #0]
 8001426:	e77a      	b.n	800131e <_printf_i+0x5a>
 8001428:	6861      	ldr	r1, [r4, #4]
 800142a:	60a1      	str	r1, [r4, #8]
 800142c:	202d      	movs	r0, #45	; 0x2d
 800142e:	2900      	cmp	r1, #0
 8001430:	f1c3 0300 	rsb	r3, r3, #0
 8001434:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8001438:	db21      	blt.n	800147e <_printf_i+0x1ba>
 800143a:	f022 0204 	bic.w	r2, r2, #4
 800143e:	f8df e11c 	ldr.w	lr, [pc, #284]	; 800155c <_printf_i+0x298>
 8001442:	6022      	str	r2, [r4, #0]
 8001444:	210a      	movs	r1, #10
 8001446:	4665      	mov	r5, ip
 8001448:	fbb3 f2f1 	udiv	r2, r3, r1
 800144c:	fb01 3012 	mls	r0, r1, r2, r3
 8001450:	4613      	mov	r3, r2
 8001452:	f81e 2000 	ldrb.w	r2, [lr, r0]
 8001456:	f805 2d01 	strb.w	r2, [r5, #-1]!
 800145a:	2b00      	cmp	r3, #0
 800145c:	d1f4      	bne.n	8001448 <_printf_i+0x184>
 800145e:	2908      	cmp	r1, #8
 8001460:	d18f      	bne.n	8001382 <_printf_i+0xbe>
 8001462:	6823      	ldr	r3, [r4, #0]
 8001464:	07d9      	lsls	r1, r3, #31
 8001466:	d58c      	bpl.n	8001382 <_printf_i+0xbe>
 8001468:	6862      	ldr	r2, [r4, #4]
 800146a:	6923      	ldr	r3, [r4, #16]
 800146c:	429a      	cmp	r2, r3
 800146e:	dc88      	bgt.n	8001382 <_printf_i+0xbe>
 8001470:	2330      	movs	r3, #48	; 0x30
 8001472:	f805 3c01 	strb.w	r3, [r5, #-1]
 8001476:	3d01      	subs	r5, #1
 8001478:	e783      	b.n	8001382 <_printf_i+0xbe>
 800147a:	2110      	movs	r1, #16
 800147c:	e76d      	b.n	800135a <_printf_i+0x96>
 800147e:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 800155c <_printf_i+0x298>
 8001482:	210a      	movs	r1, #10
 8001484:	2b00      	cmp	r3, #0
 8001486:	d1de      	bne.n	8001446 <_printf_i+0x182>
 8001488:	f89e 3000 	ldrb.w	r3, [lr]
 800148c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8001490:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8001494:	e773      	b.n	800137e <_printf_i+0xba>
 8001496:	2964      	cmp	r1, #100	; 0x64
 8001498:	d001      	beq.n	800149e <_printf_i+0x1da>
 800149a:	2969      	cmp	r1, #105	; 0x69
 800149c:	d112      	bne.n	80014c4 <_printf_i+0x200>
 800149e:	6822      	ldr	r2, [r4, #0]
 80014a0:	6803      	ldr	r3, [r0, #0]
 80014a2:	0615      	lsls	r5, r2, #24
 80014a4:	f103 0104 	add.w	r1, r3, #4
 80014a8:	d452      	bmi.n	8001550 <_printf_i+0x28c>
 80014aa:	0655      	lsls	r5, r2, #25
 80014ac:	bf4b      	itete	mi
 80014ae:	f9b3 3000 	ldrshmi.w	r3, [r3]
 80014b2:	681b      	ldrpl	r3, [r3, #0]
 80014b4:	6001      	strmi	r1, [r0, #0]
 80014b6:	6001      	strpl	r1, [r0, #0]
 80014b8:	2b00      	cmp	r3, #0
 80014ba:	dbb5      	blt.n	8001428 <_printf_i+0x164>
 80014bc:	f8df e09c 	ldr.w	lr, [pc, #156]	; 800155c <_printf_i+0x298>
 80014c0:	210a      	movs	r1, #10
 80014c2:	e74d      	b.n	8001360 <_printf_i+0x9c>
 80014c4:	2301      	movs	r3, #1
 80014c6:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 80014ca:	6123      	str	r3, [r4, #16]
 80014cc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80014d0:	2300      	movs	r3, #0
 80014d2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80014d6:	e76a      	b.n	80013ae <_printf_i+0xea>
 80014d8:	6823      	ldr	r3, [r4, #0]
 80014da:	061a      	lsls	r2, r3, #24
 80014dc:	d433      	bmi.n	8001546 <_printf_i+0x282>
 80014de:	f013 0f40 	tst.w	r3, #64	; 0x40
 80014e2:	6803      	ldr	r3, [r0, #0]
 80014e4:	f103 0204 	add.w	r2, r3, #4
 80014e8:	bf15      	itete	ne
 80014ea:	881b      	ldrhne	r3, [r3, #0]
 80014ec:	681b      	ldreq	r3, [r3, #0]
 80014ee:	6002      	strne	r2, [r0, #0]
 80014f0:	6002      	streq	r2, [r0, #0]
 80014f2:	296f      	cmp	r1, #111	; 0x6f
 80014f4:	bf14      	ite	ne
 80014f6:	210a      	movne	r1, #10
 80014f8:	2108      	moveq	r1, #8
 80014fa:	f8df e060 	ldr.w	lr, [pc, #96]	; 800155c <_printf_i+0x298>
 80014fe:	e72c      	b.n	800135a <_printf_i+0x96>
 8001500:	6803      	ldr	r3, [r0, #0]
 8001502:	6862      	ldr	r2, [r4, #4]
 8001504:	1d19      	adds	r1, r3, #4
 8001506:	6001      	str	r1, [r0, #0]
 8001508:	681d      	ldr	r5, [r3, #0]
 800150a:	2100      	movs	r1, #0
 800150c:	4628      	mov	r0, r5
 800150e:	f000 f9ef 	bl	80018f0 <memchr>
 8001512:	b300      	cbz	r0, 8001556 <_printf_i+0x292>
 8001514:	1b40      	subs	r0, r0, r5
 8001516:	6060      	str	r0, [r4, #4]
 8001518:	6120      	str	r0, [r4, #16]
 800151a:	e7d9      	b.n	80014d0 <_printf_i+0x20c>
 800151c:	6803      	ldr	r3, [r0, #0]
 800151e:	681a      	ldr	r2, [r3, #0]
 8001520:	1d19      	adds	r1, r3, #4
 8001522:	2301      	movs	r3, #1
 8001524:	6001      	str	r1, [r0, #0]
 8001526:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800152a:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 800152e:	6123      	str	r3, [r4, #16]
 8001530:	e7ce      	b.n	80014d0 <_printf_i+0x20c>
 8001532:	6001      	str	r1, [r0, #0]
 8001534:	681b      	ldr	r3, [r3, #0]
 8001536:	e703      	b.n	8001340 <_printf_i+0x7c>
 8001538:	6803      	ldr	r3, [r0, #0]
 800153a:	6962      	ldr	r2, [r4, #20]
 800153c:	1d19      	adds	r1, r3, #4
 800153e:	6001      	str	r1, [r0, #0]
 8001540:	681b      	ldr	r3, [r3, #0]
 8001542:	601a      	str	r2, [r3, #0]
 8001544:	e730      	b.n	80013a8 <_printf_i+0xe4>
 8001546:	6803      	ldr	r3, [r0, #0]
 8001548:	1d1a      	adds	r2, r3, #4
 800154a:	6002      	str	r2, [r0, #0]
 800154c:	681b      	ldr	r3, [r3, #0]
 800154e:	e7d0      	b.n	80014f2 <_printf_i+0x22e>
 8001550:	6001      	str	r1, [r0, #0]
 8001552:	681b      	ldr	r3, [r3, #0]
 8001554:	e7b0      	b.n	80014b8 <_printf_i+0x1f4>
 8001556:	6860      	ldr	r0, [r4, #4]
 8001558:	e7de      	b.n	8001518 <_printf_i+0x254>
 800155a:	bf00      	nop
 800155c:	080041a0 	.word	0x080041a0
 8001560:	080041b4 	.word	0x080041b4
	...

08001570 <__sread>:
 8001570:	b510      	push	{r4, lr}
 8001572:	460c      	mov	r4, r1
 8001574:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8001578:	f000 fdaa 	bl	80020d0 <_read_r>
 800157c:	2800      	cmp	r0, #0
 800157e:	db03      	blt.n	8001588 <__sread+0x18>
 8001580:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001582:	4403      	add	r3, r0
 8001584:	6563      	str	r3, [r4, #84]	; 0x54
 8001586:	bd10      	pop	{r4, pc}
 8001588:	89a3      	ldrh	r3, [r4, #12]
 800158a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800158e:	81a3      	strh	r3, [r4, #12]
 8001590:	bd10      	pop	{r4, pc}
 8001592:	bf00      	nop

08001594 <__seofread>:
 8001594:	2000      	movs	r0, #0
 8001596:	4770      	bx	lr

08001598 <__swrite>:
 8001598:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800159c:	4616      	mov	r6, r2
 800159e:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80015a2:	461f      	mov	r7, r3
 80015a4:	05d3      	lsls	r3, r2, #23
 80015a6:	460c      	mov	r4, r1
 80015a8:	4605      	mov	r5, r0
 80015aa:	d507      	bpl.n	80015bc <__swrite+0x24>
 80015ac:	2200      	movs	r2, #0
 80015ae:	2302      	movs	r3, #2
 80015b0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80015b4:	f000 fd94 	bl	80020e0 <_lseek_r>
 80015b8:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80015bc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80015c0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80015c4:	81a2      	strh	r2, [r4, #12]
 80015c6:	463b      	mov	r3, r7
 80015c8:	4632      	mov	r2, r6
 80015ca:	4628      	mov	r0, r5
 80015cc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80015d0:	f000 bd8e 	b.w	80020f0 <_write_r>

080015d4 <__sseek>:
 80015d4:	b510      	push	{r4, lr}
 80015d6:	460c      	mov	r4, r1
 80015d8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80015dc:	f000 fd80 	bl	80020e0 <_lseek_r>
 80015e0:	89a3      	ldrh	r3, [r4, #12]
 80015e2:	1c42      	adds	r2, r0, #1
 80015e4:	bf0e      	itee	eq
 80015e6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80015ea:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80015ee:	6560      	strne	r0, [r4, #84]	; 0x54
 80015f0:	81a3      	strh	r3, [r4, #12]
 80015f2:	bd10      	pop	{r4, pc}

080015f4 <__sclose>:
 80015f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80015f8:	f000 bd82 	b.w	8002100 <_close_r>
 80015fc:	0000      	movs	r0, r0
	...

08001600 <__sfvwrite_r>:
 8001600:	6893      	ldr	r3, [r2, #8]
 8001602:	2b00      	cmp	r3, #0
 8001604:	d073      	beq.n	80016ee <__sfvwrite_r+0xee>
 8001606:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800160a:	898b      	ldrh	r3, [r1, #12]
 800160c:	b083      	sub	sp, #12
 800160e:	460c      	mov	r4, r1
 8001610:	0719      	lsls	r1, r3, #28
 8001612:	9000      	str	r0, [sp, #0]
 8001614:	4616      	mov	r6, r2
 8001616:	d526      	bpl.n	8001666 <__sfvwrite_r+0x66>
 8001618:	6922      	ldr	r2, [r4, #16]
 800161a:	b322      	cbz	r2, 8001666 <__sfvwrite_r+0x66>
 800161c:	f013 0002 	ands.w	r0, r3, #2
 8001620:	6835      	ldr	r5, [r6, #0]
 8001622:	d02c      	beq.n	800167e <__sfvwrite_r+0x7e>
 8001624:	f04f 0900 	mov.w	r9, #0
 8001628:	4fb0      	ldr	r7, [pc, #704]	; (80018ec <__sfvwrite_r+0x2ec>)
 800162a:	46c8      	mov	r8, r9
 800162c:	46b2      	mov	sl, r6
 800162e:	45b8      	cmp	r8, r7
 8001630:	4643      	mov	r3, r8
 8001632:	464a      	mov	r2, r9
 8001634:	bf28      	it	cs
 8001636:	463b      	movcs	r3, r7
 8001638:	9800      	ldr	r0, [sp, #0]
 800163a:	f1b8 0f00 	cmp.w	r8, #0
 800163e:	d050      	beq.n	80016e2 <__sfvwrite_r+0xe2>
 8001640:	6a21      	ldr	r1, [r4, #32]
 8001642:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8001644:	47b0      	blx	r6
 8001646:	2800      	cmp	r0, #0
 8001648:	dd58      	ble.n	80016fc <__sfvwrite_r+0xfc>
 800164a:	f8da 3008 	ldr.w	r3, [sl, #8]
 800164e:	1a1b      	subs	r3, r3, r0
 8001650:	4481      	add	r9, r0
 8001652:	eba8 0800 	sub.w	r8, r8, r0
 8001656:	f8ca 3008 	str.w	r3, [sl, #8]
 800165a:	2b00      	cmp	r3, #0
 800165c:	d1e7      	bne.n	800162e <__sfvwrite_r+0x2e>
 800165e:	2000      	movs	r0, #0
 8001660:	b003      	add	sp, #12
 8001662:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001666:	4621      	mov	r1, r4
 8001668:	9800      	ldr	r0, [sp, #0]
 800166a:	f7ff f831 	bl	80006d0 <__swsetup_r>
 800166e:	2800      	cmp	r0, #0
 8001670:	f040 8133 	bne.w	80018da <__sfvwrite_r+0x2da>
 8001674:	89a3      	ldrh	r3, [r4, #12]
 8001676:	6835      	ldr	r5, [r6, #0]
 8001678:	f013 0002 	ands.w	r0, r3, #2
 800167c:	d1d2      	bne.n	8001624 <__sfvwrite_r+0x24>
 800167e:	f013 0901 	ands.w	r9, r3, #1
 8001682:	d145      	bne.n	8001710 <__sfvwrite_r+0x110>
 8001684:	464f      	mov	r7, r9
 8001686:	9601      	str	r6, [sp, #4]
 8001688:	b337      	cbz	r7, 80016d8 <__sfvwrite_r+0xd8>
 800168a:	059a      	lsls	r2, r3, #22
 800168c:	f8d4 8008 	ldr.w	r8, [r4, #8]
 8001690:	f140 8083 	bpl.w	800179a <__sfvwrite_r+0x19a>
 8001694:	4547      	cmp	r7, r8
 8001696:	46c3      	mov	fp, r8
 8001698:	f0c0 80ab 	bcc.w	80017f2 <__sfvwrite_r+0x1f2>
 800169c:	f413 6f90 	tst.w	r3, #1152	; 0x480
 80016a0:	f040 80ac 	bne.w	80017fc <__sfvwrite_r+0x1fc>
 80016a4:	6820      	ldr	r0, [r4, #0]
 80016a6:	46ba      	mov	sl, r7
 80016a8:	465a      	mov	r2, fp
 80016aa:	4649      	mov	r1, r9
 80016ac:	f000 f970 	bl	8001990 <memmove>
 80016b0:	68a2      	ldr	r2, [r4, #8]
 80016b2:	6823      	ldr	r3, [r4, #0]
 80016b4:	eba2 0208 	sub.w	r2, r2, r8
 80016b8:	445b      	add	r3, fp
 80016ba:	60a2      	str	r2, [r4, #8]
 80016bc:	6023      	str	r3, [r4, #0]
 80016be:	9a01      	ldr	r2, [sp, #4]
 80016c0:	6893      	ldr	r3, [r2, #8]
 80016c2:	eba3 030a 	sub.w	r3, r3, sl
 80016c6:	44d1      	add	r9, sl
 80016c8:	eba7 070a 	sub.w	r7, r7, sl
 80016cc:	6093      	str	r3, [r2, #8]
 80016ce:	2b00      	cmp	r3, #0
 80016d0:	d0c5      	beq.n	800165e <__sfvwrite_r+0x5e>
 80016d2:	89a3      	ldrh	r3, [r4, #12]
 80016d4:	2f00      	cmp	r7, #0
 80016d6:	d1d8      	bne.n	800168a <__sfvwrite_r+0x8a>
 80016d8:	f8d5 9000 	ldr.w	r9, [r5]
 80016dc:	686f      	ldr	r7, [r5, #4]
 80016de:	3508      	adds	r5, #8
 80016e0:	e7d2      	b.n	8001688 <__sfvwrite_r+0x88>
 80016e2:	f8d5 9000 	ldr.w	r9, [r5]
 80016e6:	f8d5 8004 	ldr.w	r8, [r5, #4]
 80016ea:	3508      	adds	r5, #8
 80016ec:	e79f      	b.n	800162e <__sfvwrite_r+0x2e>
 80016ee:	2000      	movs	r0, #0
 80016f0:	4770      	bx	lr
 80016f2:	4621      	mov	r1, r4
 80016f4:	9800      	ldr	r0, [sp, #0]
 80016f6:	f7ff f8ff 	bl	80008f8 <_fflush_r>
 80016fa:	b370      	cbz	r0, 800175a <__sfvwrite_r+0x15a>
 80016fc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8001700:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001704:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001708:	81a3      	strh	r3, [r4, #12]
 800170a:	b003      	add	sp, #12
 800170c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001710:	4681      	mov	r9, r0
 8001712:	4633      	mov	r3, r6
 8001714:	464e      	mov	r6, r9
 8001716:	46a8      	mov	r8, r5
 8001718:	469a      	mov	sl, r3
 800171a:	464d      	mov	r5, r9
 800171c:	b34e      	cbz	r6, 8001772 <__sfvwrite_r+0x172>
 800171e:	b380      	cbz	r0, 8001782 <__sfvwrite_r+0x182>
 8001720:	6820      	ldr	r0, [r4, #0]
 8001722:	6923      	ldr	r3, [r4, #16]
 8001724:	6962      	ldr	r2, [r4, #20]
 8001726:	45b1      	cmp	r9, r6
 8001728:	46cb      	mov	fp, r9
 800172a:	bf28      	it	cs
 800172c:	46b3      	movcs	fp, r6
 800172e:	4298      	cmp	r0, r3
 8001730:	465f      	mov	r7, fp
 8001732:	d904      	bls.n	800173e <__sfvwrite_r+0x13e>
 8001734:	68a3      	ldr	r3, [r4, #8]
 8001736:	4413      	add	r3, r2
 8001738:	459b      	cmp	fp, r3
 800173a:	f300 80a6 	bgt.w	800188a <__sfvwrite_r+0x28a>
 800173e:	4593      	cmp	fp, r2
 8001740:	db4b      	blt.n	80017da <__sfvwrite_r+0x1da>
 8001742:	4613      	mov	r3, r2
 8001744:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 8001746:	6a21      	ldr	r1, [r4, #32]
 8001748:	9800      	ldr	r0, [sp, #0]
 800174a:	462a      	mov	r2, r5
 800174c:	47b8      	blx	r7
 800174e:	1e07      	subs	r7, r0, #0
 8001750:	ddd4      	ble.n	80016fc <__sfvwrite_r+0xfc>
 8001752:	ebb9 0907 	subs.w	r9, r9, r7
 8001756:	d0cc      	beq.n	80016f2 <__sfvwrite_r+0xf2>
 8001758:	2001      	movs	r0, #1
 800175a:	f8da 3008 	ldr.w	r3, [sl, #8]
 800175e:	1bdb      	subs	r3, r3, r7
 8001760:	443d      	add	r5, r7
 8001762:	1bf6      	subs	r6, r6, r7
 8001764:	f8ca 3008 	str.w	r3, [sl, #8]
 8001768:	2b00      	cmp	r3, #0
 800176a:	f43f af78 	beq.w	800165e <__sfvwrite_r+0x5e>
 800176e:	2e00      	cmp	r6, #0
 8001770:	d1d5      	bne.n	800171e <__sfvwrite_r+0x11e>
 8001772:	f108 0308 	add.w	r3, r8, #8
 8001776:	e913 0060 	ldmdb	r3, {r5, r6}
 800177a:	4698      	mov	r8, r3
 800177c:	3308      	adds	r3, #8
 800177e:	2e00      	cmp	r6, #0
 8001780:	d0f9      	beq.n	8001776 <__sfvwrite_r+0x176>
 8001782:	4632      	mov	r2, r6
 8001784:	210a      	movs	r1, #10
 8001786:	4628      	mov	r0, r5
 8001788:	f000 f8b2 	bl	80018f0 <memchr>
 800178c:	2800      	cmp	r0, #0
 800178e:	f000 80a1 	beq.w	80018d4 <__sfvwrite_r+0x2d4>
 8001792:	3001      	adds	r0, #1
 8001794:	eba0 0905 	sub.w	r9, r0, r5
 8001798:	e7c2      	b.n	8001720 <__sfvwrite_r+0x120>
 800179a:	6820      	ldr	r0, [r4, #0]
 800179c:	6923      	ldr	r3, [r4, #16]
 800179e:	4298      	cmp	r0, r3
 80017a0:	d802      	bhi.n	80017a8 <__sfvwrite_r+0x1a8>
 80017a2:	6963      	ldr	r3, [r4, #20]
 80017a4:	429f      	cmp	r7, r3
 80017a6:	d25d      	bcs.n	8001864 <__sfvwrite_r+0x264>
 80017a8:	45b8      	cmp	r8, r7
 80017aa:	bf28      	it	cs
 80017ac:	46b8      	movcs	r8, r7
 80017ae:	4642      	mov	r2, r8
 80017b0:	4649      	mov	r1, r9
 80017b2:	f000 f8ed 	bl	8001990 <memmove>
 80017b6:	68a3      	ldr	r3, [r4, #8]
 80017b8:	6822      	ldr	r2, [r4, #0]
 80017ba:	eba3 0308 	sub.w	r3, r3, r8
 80017be:	4442      	add	r2, r8
 80017c0:	60a3      	str	r3, [r4, #8]
 80017c2:	6022      	str	r2, [r4, #0]
 80017c4:	b10b      	cbz	r3, 80017ca <__sfvwrite_r+0x1ca>
 80017c6:	46c2      	mov	sl, r8
 80017c8:	e779      	b.n	80016be <__sfvwrite_r+0xbe>
 80017ca:	4621      	mov	r1, r4
 80017cc:	9800      	ldr	r0, [sp, #0]
 80017ce:	f7ff f893 	bl	80008f8 <_fflush_r>
 80017d2:	2800      	cmp	r0, #0
 80017d4:	d192      	bne.n	80016fc <__sfvwrite_r+0xfc>
 80017d6:	46c2      	mov	sl, r8
 80017d8:	e771      	b.n	80016be <__sfvwrite_r+0xbe>
 80017da:	465a      	mov	r2, fp
 80017dc:	4629      	mov	r1, r5
 80017de:	f000 f8d7 	bl	8001990 <memmove>
 80017e2:	68a2      	ldr	r2, [r4, #8]
 80017e4:	6823      	ldr	r3, [r4, #0]
 80017e6:	eba2 020b 	sub.w	r2, r2, fp
 80017ea:	445b      	add	r3, fp
 80017ec:	60a2      	str	r2, [r4, #8]
 80017ee:	6023      	str	r3, [r4, #0]
 80017f0:	e7af      	b.n	8001752 <__sfvwrite_r+0x152>
 80017f2:	6820      	ldr	r0, [r4, #0]
 80017f4:	46b8      	mov	r8, r7
 80017f6:	46ba      	mov	sl, r7
 80017f8:	46bb      	mov	fp, r7
 80017fa:	e755      	b.n	80016a8 <__sfvwrite_r+0xa8>
 80017fc:	6962      	ldr	r2, [r4, #20]
 80017fe:	6820      	ldr	r0, [r4, #0]
 8001800:	6921      	ldr	r1, [r4, #16]
 8001802:	eb02 0842 	add.w	r8, r2, r2, lsl #1
 8001806:	eba0 0a01 	sub.w	sl, r0, r1
 800180a:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
 800180e:	f10a 0001 	add.w	r0, sl, #1
 8001812:	ea4f 0868 	mov.w	r8, r8, asr #1
 8001816:	4438      	add	r0, r7
 8001818:	4540      	cmp	r0, r8
 800181a:	4642      	mov	r2, r8
 800181c:	bf84      	itt	hi
 800181e:	4680      	movhi	r8, r0
 8001820:	4642      	movhi	r2, r8
 8001822:	055b      	lsls	r3, r3, #21
 8001824:	d544      	bpl.n	80018b0 <__sfvwrite_r+0x2b0>
 8001826:	4611      	mov	r1, r2
 8001828:	9800      	ldr	r0, [sp, #0]
 800182a:	f7ff fad1 	bl	8000dd0 <_malloc_r>
 800182e:	4683      	mov	fp, r0
 8001830:	2800      	cmp	r0, #0
 8001832:	d055      	beq.n	80018e0 <__sfvwrite_r+0x2e0>
 8001834:	4652      	mov	r2, sl
 8001836:	6921      	ldr	r1, [r4, #16]
 8001838:	f7fe fd4a 	bl	80002d0 <memcpy>
 800183c:	89a3      	ldrh	r3, [r4, #12]
 800183e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8001842:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001846:	81a3      	strh	r3, [r4, #12]
 8001848:	eb0b 000a 	add.w	r0, fp, sl
 800184c:	eba8 030a 	sub.w	r3, r8, sl
 8001850:	f8c4 b010 	str.w	fp, [r4, #16]
 8001854:	f8c4 8014 	str.w	r8, [r4, #20]
 8001858:	6020      	str	r0, [r4, #0]
 800185a:	60a3      	str	r3, [r4, #8]
 800185c:	46b8      	mov	r8, r7
 800185e:	46ba      	mov	sl, r7
 8001860:	46bb      	mov	fp, r7
 8001862:	e721      	b.n	80016a8 <__sfvwrite_r+0xa8>
 8001864:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8001868:	42b9      	cmp	r1, r7
 800186a:	bf28      	it	cs
 800186c:	4639      	movcs	r1, r7
 800186e:	464a      	mov	r2, r9
 8001870:	fb91 f1f3 	sdiv	r1, r1, r3
 8001874:	9800      	ldr	r0, [sp, #0]
 8001876:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8001878:	fb03 f301 	mul.w	r3, r3, r1
 800187c:	6a21      	ldr	r1, [r4, #32]
 800187e:	47b0      	blx	r6
 8001880:	f1b0 0a00 	subs.w	sl, r0, #0
 8001884:	f73f af1b 	bgt.w	80016be <__sfvwrite_r+0xbe>
 8001888:	e738      	b.n	80016fc <__sfvwrite_r+0xfc>
 800188a:	461a      	mov	r2, r3
 800188c:	4629      	mov	r1, r5
 800188e:	9301      	str	r3, [sp, #4]
 8001890:	f000 f87e 	bl	8001990 <memmove>
 8001894:	6822      	ldr	r2, [r4, #0]
 8001896:	9b01      	ldr	r3, [sp, #4]
 8001898:	9800      	ldr	r0, [sp, #0]
 800189a:	441a      	add	r2, r3
 800189c:	6022      	str	r2, [r4, #0]
 800189e:	4621      	mov	r1, r4
 80018a0:	f7ff f82a 	bl	80008f8 <_fflush_r>
 80018a4:	9b01      	ldr	r3, [sp, #4]
 80018a6:	2800      	cmp	r0, #0
 80018a8:	f47f af28 	bne.w	80016fc <__sfvwrite_r+0xfc>
 80018ac:	461f      	mov	r7, r3
 80018ae:	e750      	b.n	8001752 <__sfvwrite_r+0x152>
 80018b0:	9800      	ldr	r0, [sp, #0]
 80018b2:	f000 f8d5 	bl	8001a60 <_realloc_r>
 80018b6:	4683      	mov	fp, r0
 80018b8:	2800      	cmp	r0, #0
 80018ba:	d1c5      	bne.n	8001848 <__sfvwrite_r+0x248>
 80018bc:	9d00      	ldr	r5, [sp, #0]
 80018be:	6921      	ldr	r1, [r4, #16]
 80018c0:	4628      	mov	r0, r5
 80018c2:	f7ff fa3d 	bl	8000d40 <_free_r>
 80018c6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80018ca:	220c      	movs	r2, #12
 80018cc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80018d0:	602a      	str	r2, [r5, #0]
 80018d2:	e715      	b.n	8001700 <__sfvwrite_r+0x100>
 80018d4:	f106 0901 	add.w	r9, r6, #1
 80018d8:	e722      	b.n	8001720 <__sfvwrite_r+0x120>
 80018da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80018de:	e6bf      	b.n	8001660 <__sfvwrite_r+0x60>
 80018e0:	9a00      	ldr	r2, [sp, #0]
 80018e2:	230c      	movs	r3, #12
 80018e4:	6013      	str	r3, [r2, #0]
 80018e6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80018ea:	e709      	b.n	8001700 <__sfvwrite_r+0x100>
 80018ec:	7ffffc00 	.word	0x7ffffc00

080018f0 <memchr>:
 80018f0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80018f4:	2a10      	cmp	r2, #16
 80018f6:	db2b      	blt.n	8001950 <memchr+0x60>
 80018f8:	f010 0f07 	tst.w	r0, #7
 80018fc:	d008      	beq.n	8001910 <memchr+0x20>
 80018fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8001902:	3a01      	subs	r2, #1
 8001904:	428b      	cmp	r3, r1
 8001906:	d02d      	beq.n	8001964 <memchr+0x74>
 8001908:	f010 0f07 	tst.w	r0, #7
 800190c:	b342      	cbz	r2, 8001960 <memchr+0x70>
 800190e:	d1f6      	bne.n	80018fe <memchr+0xe>
 8001910:	b4f0      	push	{r4, r5, r6, r7}
 8001912:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8001916:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800191a:	f022 0407 	bic.w	r4, r2, #7
 800191e:	f07f 0700 	mvns.w	r7, #0
 8001922:	2300      	movs	r3, #0
 8001924:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8001928:	3c08      	subs	r4, #8
 800192a:	ea85 0501 	eor.w	r5, r5, r1
 800192e:	ea86 0601 	eor.w	r6, r6, r1
 8001932:	fa85 f547 	uadd8	r5, r5, r7
 8001936:	faa3 f587 	sel	r5, r3, r7
 800193a:	fa86 f647 	uadd8	r6, r6, r7
 800193e:	faa5 f687 	sel	r6, r5, r7
 8001942:	b98e      	cbnz	r6, 8001968 <memchr+0x78>
 8001944:	d1ee      	bne.n	8001924 <memchr+0x34>
 8001946:	bcf0      	pop	{r4, r5, r6, r7}
 8001948:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800194c:	f002 0207 	and.w	r2, r2, #7
 8001950:	b132      	cbz	r2, 8001960 <memchr+0x70>
 8001952:	f810 3b01 	ldrb.w	r3, [r0], #1
 8001956:	3a01      	subs	r2, #1
 8001958:	ea83 0301 	eor.w	r3, r3, r1
 800195c:	b113      	cbz	r3, 8001964 <memchr+0x74>
 800195e:	d1f8      	bne.n	8001952 <memchr+0x62>
 8001960:	2000      	movs	r0, #0
 8001962:	4770      	bx	lr
 8001964:	3801      	subs	r0, #1
 8001966:	4770      	bx	lr
 8001968:	2d00      	cmp	r5, #0
 800196a:	bf06      	itte	eq
 800196c:	4635      	moveq	r5, r6
 800196e:	3803      	subeq	r0, #3
 8001970:	3807      	subne	r0, #7
 8001972:	f015 0f01 	tst.w	r5, #1
 8001976:	d107      	bne.n	8001988 <memchr+0x98>
 8001978:	3001      	adds	r0, #1
 800197a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800197e:	bf02      	ittt	eq
 8001980:	3001      	addeq	r0, #1
 8001982:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8001986:	3001      	addeq	r0, #1
 8001988:	bcf0      	pop	{r4, r5, r6, r7}
 800198a:	3801      	subs	r0, #1
 800198c:	4770      	bx	lr
 800198e:	bf00      	nop

08001990 <memmove>:
 8001990:	4288      	cmp	r0, r1
 8001992:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001994:	d90d      	bls.n	80019b2 <memmove+0x22>
 8001996:	188b      	adds	r3, r1, r2
 8001998:	4298      	cmp	r0, r3
 800199a:	d20a      	bcs.n	80019b2 <memmove+0x22>
 800199c:	1884      	adds	r4, r0, r2
 800199e:	2a00      	cmp	r2, #0
 80019a0:	d051      	beq.n	8001a46 <memmove+0xb6>
 80019a2:	4622      	mov	r2, r4
 80019a4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80019a8:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80019ac:	4299      	cmp	r1, r3
 80019ae:	d1f9      	bne.n	80019a4 <memmove+0x14>
 80019b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80019b2:	2a0f      	cmp	r2, #15
 80019b4:	d948      	bls.n	8001a48 <memmove+0xb8>
 80019b6:	ea41 0300 	orr.w	r3, r1, r0
 80019ba:	079b      	lsls	r3, r3, #30
 80019bc:	d146      	bne.n	8001a4c <memmove+0xbc>
 80019be:	f100 0410 	add.w	r4, r0, #16
 80019c2:	f101 0310 	add.w	r3, r1, #16
 80019c6:	4615      	mov	r5, r2
 80019c8:	f853 6c10 	ldr.w	r6, [r3, #-16]
 80019cc:	f844 6c10 	str.w	r6, [r4, #-16]
 80019d0:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 80019d4:	f844 6c0c 	str.w	r6, [r4, #-12]
 80019d8:	f853 6c08 	ldr.w	r6, [r3, #-8]
 80019dc:	f844 6c08 	str.w	r6, [r4, #-8]
 80019e0:	3d10      	subs	r5, #16
 80019e2:	f853 6c04 	ldr.w	r6, [r3, #-4]
 80019e6:	f844 6c04 	str.w	r6, [r4, #-4]
 80019ea:	2d0f      	cmp	r5, #15
 80019ec:	f103 0310 	add.w	r3, r3, #16
 80019f0:	f104 0410 	add.w	r4, r4, #16
 80019f4:	d8e8      	bhi.n	80019c8 <memmove+0x38>
 80019f6:	f1a2 0310 	sub.w	r3, r2, #16
 80019fa:	f023 030f 	bic.w	r3, r3, #15
 80019fe:	f002 0e0f 	and.w	lr, r2, #15
 8001a02:	3310      	adds	r3, #16
 8001a04:	f1be 0f03 	cmp.w	lr, #3
 8001a08:	4419      	add	r1, r3
 8001a0a:	4403      	add	r3, r0
 8001a0c:	d921      	bls.n	8001a52 <memmove+0xc2>
 8001a0e:	1f1e      	subs	r6, r3, #4
 8001a10:	460d      	mov	r5, r1
 8001a12:	4674      	mov	r4, lr
 8001a14:	3c04      	subs	r4, #4
 8001a16:	f855 7b04 	ldr.w	r7, [r5], #4
 8001a1a:	f846 7f04 	str.w	r7, [r6, #4]!
 8001a1e:	2c03      	cmp	r4, #3
 8001a20:	d8f8      	bhi.n	8001a14 <memmove+0x84>
 8001a22:	f1ae 0404 	sub.w	r4, lr, #4
 8001a26:	f024 0403 	bic.w	r4, r4, #3
 8001a2a:	3404      	adds	r4, #4
 8001a2c:	4421      	add	r1, r4
 8001a2e:	4423      	add	r3, r4
 8001a30:	f002 0203 	and.w	r2, r2, #3
 8001a34:	b162      	cbz	r2, 8001a50 <memmove+0xc0>
 8001a36:	3b01      	subs	r3, #1
 8001a38:	440a      	add	r2, r1
 8001a3a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8001a3e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8001a42:	428a      	cmp	r2, r1
 8001a44:	d1f9      	bne.n	8001a3a <memmove+0xaa>
 8001a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a48:	4603      	mov	r3, r0
 8001a4a:	e7f3      	b.n	8001a34 <memmove+0xa4>
 8001a4c:	4603      	mov	r3, r0
 8001a4e:	e7f2      	b.n	8001a36 <memmove+0xa6>
 8001a50:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a52:	4672      	mov	r2, lr
 8001a54:	e7ee      	b.n	8001a34 <memmove+0xa4>
 8001a56:	bf00      	nop
	...

08001a60 <_realloc_r>:
 8001a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a62:	4614      	mov	r4, r2
 8001a64:	b1f9      	cbz	r1, 8001aa6 <_realloc_r+0x46>
 8001a66:	b1c2      	cbz	r2, 8001a9a <_realloc_r+0x3a>
 8001a68:	4606      	mov	r6, r0
 8001a6a:	460d      	mov	r5, r1
 8001a6c:	f000 f820 	bl	8001ab0 <_malloc_usable_size_r>
 8001a70:	4284      	cmp	r4, r0
 8001a72:	d801      	bhi.n	8001a78 <_realloc_r+0x18>
 8001a74:	4628      	mov	r0, r5
 8001a76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a78:	4621      	mov	r1, r4
 8001a7a:	4630      	mov	r0, r6
 8001a7c:	f7ff f9a8 	bl	8000dd0 <_malloc_r>
 8001a80:	4607      	mov	r7, r0
 8001a82:	b170      	cbz	r0, 8001aa2 <_realloc_r+0x42>
 8001a84:	4622      	mov	r2, r4
 8001a86:	4629      	mov	r1, r5
 8001a88:	f7fe fc22 	bl	80002d0 <memcpy>
 8001a8c:	4629      	mov	r1, r5
 8001a8e:	4630      	mov	r0, r6
 8001a90:	463d      	mov	r5, r7
 8001a92:	f7ff f955 	bl	8000d40 <_free_r>
 8001a96:	4628      	mov	r0, r5
 8001a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a9a:	f7ff f951 	bl	8000d40 <_free_r>
 8001a9e:	4625      	mov	r5, r4
 8001aa0:	e7e8      	b.n	8001a74 <_realloc_r+0x14>
 8001aa2:	4605      	mov	r5, r0
 8001aa4:	e7e6      	b.n	8001a74 <_realloc_r+0x14>
 8001aa6:	4611      	mov	r1, r2
 8001aa8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8001aac:	f7ff b990 	b.w	8000dd0 <_malloc_r>

08001ab0 <_malloc_usable_size_r>:
 8001ab0:	f851 0c04 	ldr.w	r0, [r1, #-4]
 8001ab4:	2800      	cmp	r0, #0
 8001ab6:	f1a0 0004 	sub.w	r0, r0, #4
 8001aba:	bfbc      	itt	lt
 8001abc:	580b      	ldrlt	r3, [r1, r0]
 8001abe:	18c0      	addlt	r0, r0, r3
 8001ac0:	4770      	bx	lr
 8001ac2:	bf00      	nop
	...

08001ad0 <Thread_blink>:
	}
}


static THD_WORKING_AREA(waThread_blink, 128);
static THD_FUNCTION(Thread_blink, arg) {
 8001ad0:	b570      	push	{r4, r5, r6, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001ad2:	4b13      	ldr	r3, [pc, #76]	; (8001b20 <Thread_blink+0x50>)
 8001ad4:	4a13      	ldr	r2, [pc, #76]	; (8001b24 <Thread_blink+0x54>)
 8001ad6:	699b      	ldr	r3, [r3, #24]
	(void)arg;
	int i=0;
	chRegSetThreadName("blinker");
	SendDataUSART2("Thread_blink run\n", 17);
 8001ad8:	4813      	ldr	r0, [pc, #76]	; (8001b28 <Thread_blink+0x58>)
 8001ada:	619a      	str	r2, [r3, #24]
 8001adc:	2111      	movs	r1, #17
	//printf("Thread_blink run\n");
    SET_LED_RED;
	SET_LED_BLUE;
	SET_LED_GREEN;
 8001ade:	4e13      	ldr	r6, [pc, #76]	; (8001b2c <Thread_blink+0x5c>)

	while (1) {
		chThdSleepMilliseconds(100);
		i++;
		switch (i % 3) {
 8001ae0:	4d13      	ldr	r5, [pc, #76]	; (8001b30 <Thread_blink+0x60>)
	SendDataUSART2("Thread_blink run\n", 17);
 8001ae2:	f000 fb6d 	bl	80021c0 <SendDataUSART2>
	SET_LED_GREEN;
 8001ae6:	2320      	movs	r3, #32
 8001ae8:	61b3      	str	r3, [r6, #24]
	int i=0;
 8001aea:	2400      	movs	r4, #0
		i++;
 8001aec:	3401      	adds	r4, #1
		chThdSleepMilliseconds(100);
 8001aee:	2064      	movs	r0, #100	; 0x64
 8001af0:	f002 f90e 	bl	8003d10 <chThdSleep>
		switch (i % 3) {
 8001af4:	fb85 2304 	smull	r2, r3, r5, r4
 8001af8:	eba3 73e4 	sub.w	r3, r3, r4, asr #31
 8001afc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8001b00:	1ae3      	subs	r3, r4, r3
 8001b02:	2b01      	cmp	r3, #1
 8001b04:	d007      	beq.n	8001b16 <Thread_blink+0x46>
 8001b06:	2b02      	cmp	r3, #2
		  	  	SET_LED_RED;
		  	  	RESET_LED_GREEN;
		  	  	break;
		case 2: RESET_LED_BLUE;
		  	  	RESET_LED_RED;
		  	  	SET_LED_GREEN;
 8001b08:	f04f 0220 	mov.w	r2, #32
				RESET_LED_GREEN;
 8001b0c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
		switch (i % 3) {
 8001b10:	d103      	bne.n	8001b1a <Thread_blink+0x4a>
		  	  	SET_LED_GREEN;
 8001b12:	61b2      	str	r2, [r6, #24]
		  	  	break;
 8001b14:	e7ea      	b.n	8001aec <Thread_blink+0x1c>
		  	  	RESET_LED_GREEN;
 8001b16:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8001b1a:	61b3      	str	r3, [r6, #24]
		  	  	break;
 8001b1c:	e7e6      	b.n	8001aec <Thread_blink+0x1c>
 8001b1e:	bf00      	nop
 8001b20:	200012e0 	.word	0x200012e0
 8001b24:	08004030 	.word	0x08004030
 8001b28:	08004038 	.word	0x08004038
 8001b2c:	40020000 	.word	0x40020000
 8001b30:	55555556 	.word	0x55555556
	...

08001b40 <Thread_uart>:
static THD_FUNCTION(Thread_uart, arg) {
 8001b40:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001b44:	4a31      	ldr	r2, [pc, #196]	; (8001c0c <Thread_uart+0xcc>)
	sprintf(s,"Thread_uart run");
 8001b46:	4b32      	ldr	r3, [pc, #200]	; (8001c10 <Thread_uart+0xd0>)
 8001b48:	6992      	ldr	r2, [r2, #24]
 8001b4a:	4932      	ldr	r1, [pc, #200]	; (8001c14 <Thread_uart+0xd4>)
 8001b4c:	6191      	str	r1, [r2, #24]
 8001b4e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8001b50:	4c31      	ldr	r4, [pc, #196]	; (8001c18 <Thread_uart+0xd8>)
 8001b52:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8001c34 <Thread_uart+0xf4>
 8001b56:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 8001c38 <Thread_uart+0xf8>
 8001b5a:	4e30      	ldr	r6, [pc, #192]	; (8001c1c <Thread_uart+0xdc>)
 8001b5c:	4d30      	ldr	r5, [pc, #192]	; (8001c20 <Thread_uart+0xe0>)
 8001b5e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	printf("%s %d\n",s,len);
 8001b62:	4621      	mov	r1, r4
 8001b64:	220f      	movs	r2, #15
 8001b66:	482f      	ldr	r0, [pc, #188]	; (8001c24 <Thread_uart+0xe4>)
 8001b68:	4c2f      	ldr	r4, [pc, #188]	; (8001c28 <Thread_uart+0xe8>)
 8001b6a:	f7fe fcb7 	bl	80004dc <iprintf>
	int i=0, j=0;
 8001b6e:	f04f 0b00 	mov.w	fp, #0
 8001b72:	465f      	mov	r7, fp
		  rxidl2=-1;
 8001b74:	f64f 79ff 	movw	r9, #65535	; 0xffff
	  if (rxidl2>0) {
 8001b78:	f8b8 2000 	ldrh.w	r2, [r8]
 8001b7c:	b212      	sxth	r2, r2
 8001b7e:	2a00      	cmp	r2, #0
 8001b80:	dd16      	ble.n	8001bb0 <Thread_uart+0x70>
		  printf("idle");
 8001b82:	482a      	ldr	r0, [pc, #168]	; (8001c2c <Thread_uart+0xec>)
 8001b84:	f7fe fcaa 	bl	80004dc <iprintf>
		  rxidl2=-1;
 8001b88:	f8a8 9000 	strh.w	r9, [r8]
 8001b8c:	e010      	b.n	8001bb0 <Thread_uart+0x70>
#ifdef __SCLE
	if ((_p->_flags & __SCLE) && _c == '\n')
	  __sputc_r (_ptr, '\r', _p);
#endif
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
		return (*_p->_p++ = _c);
 8001b8e:	681a      	ldr	r2, [r3, #0]
 8001b90:	1c51      	adds	r1, r2, #1
 8001b92:	6019      	str	r1, [r3, #0]
 8001b94:	f882 c000 	strb.w	ip, [r2]
		  rxrp2++;
 8001b98:	8822      	ldrh	r2, [r4, #0]
 8001b9a:	3201      	adds	r2, #1
 8001b9c:	b212      	sxth	r2, r2
 8001b9e:	8022      	strh	r2, [r4, #0]
		  if (rxrp2>=RXBUFSIZE) rxrp2=0;
 8001ba0:	8822      	ldrh	r2, [r4, #0]
 8001ba2:	b212      	sxth	r2, r2
		  j=0;
 8001ba4:	f04f 0b00 	mov.w	fp, #0
		  if (rxrp2>=RXBUFSIZE) rxrp2=0;
 8001ba8:	2aff      	cmp	r2, #255	; 0xff
 8001baa:	bfc8      	it	gt
 8001bac:	f8a4 b000 	strhgt.w	fp, [r4]
	  while (rxbp2 != rxrp2) {
 8001bb0:	8828      	ldrh	r0, [r5, #0]
 8001bb2:	8822      	ldrh	r2, [r4, #0]
 8001bb4:	b200      	sxth	r0, r0
 8001bb6:	b212      	sxth	r2, r2
 8001bb8:	4290      	cmp	r0, r2
 8001bba:	d015      	beq.n	8001be8 <Thread_uart+0xa8>
		  putchar(c);
 8001bbc:	6830      	ldr	r0, [r6, #0]
		  c=rxbuf2[rxrp2];
 8001bbe:	8821      	ldrh	r1, [r4, #0]
		  putchar(c);
 8001bc0:	6883      	ldr	r3, [r0, #8]
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
 8001bc2:	689a      	ldr	r2, [r3, #8]
		  c=rxbuf2[rxrp2];
 8001bc4:	b209      	sxth	r1, r1
 8001bc6:	3a01      	subs	r2, #1
 8001bc8:	2a00      	cmp	r2, #0
 8001bca:	f81a c001 	ldrb.w	ip, [sl, r1]
 8001bce:	609a      	str	r2, [r3, #8]
 8001bd0:	dadd      	bge.n	8001b8e <Thread_uart+0x4e>
 8001bd2:	6999      	ldr	r1, [r3, #24]
 8001bd4:	428a      	cmp	r2, r1
	else
		return (__swbuf_r(_ptr, _c, _p));
 8001bd6:	461a      	mov	r2, r3
 8001bd8:	4661      	mov	r1, ip
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
 8001bda:	db02      	blt.n	8001be2 <Thread_uart+0xa2>
 8001bdc:	f1bc 0f0a 	cmp.w	ip, #10
 8001be0:	d1d5      	bne.n	8001b8e <Thread_uart+0x4e>
		return (__swbuf_r(_ptr, _c, _p));
 8001be2:	f7fe fd0d 	bl	8000600 <__swbuf_r>
 8001be6:	e7d7      	b.n	8001b98 <Thread_uart+0x58>
	  j++;
 8001be8:	f10b 0b01 	add.w	fp, fp, #1
	  chThdSleepMilliseconds(100);
 8001bec:	2064      	movs	r0, #100	; 0x64
 8001bee:	f002 f88f 	bl	8003d10 <chThdSleep>
	  if (j>=10) {
 8001bf2:	f1bb 0f09 	cmp.w	fp, #9
	  i++;
 8001bf6:	f107 0701 	add.w	r7, r7, #1
	  if (j>=10) {
 8001bfa:	ddbd      	ble.n	8001b78 <Thread_uart+0x38>
		  printf("running %d\n",i);
 8001bfc:	4639      	mov	r1, r7
 8001bfe:	480c      	ldr	r0, [pc, #48]	; (8001c30 <Thread_uart+0xf0>)
 8001c00:	f7fe fc6c 	bl	80004dc <iprintf>
		  j=0;
 8001c04:	f04f 0b00 	mov.w	fp, #0
 8001c08:	e7b6      	b.n	8001b78 <Thread_uart+0x38>
 8001c0a:	bf00      	nop
 8001c0c:	200012e0 	.word	0x200012e0
 8001c10:	08004058 	.word	0x08004058
 8001c14:	08004050 	.word	0x08004050
 8001c18:	20000870 	.word	0x20000870
 8001c1c:	20000800 	.word	0x20000800
 8001c20:	200010cc 	.word	0x200010cc
 8001c24:	08004068 	.word	0x08004068
 8001c28:	200011d2 	.word	0x200011d2
 8001c2c:	08004070 	.word	0x08004070
 8001c30:	08004078 	.word	0x08004078
 8001c34:	200011d0 	.word	0x200011d0
 8001c38:	200010d0 	.word	0x200010d0
 8001c3c:	00000000 	.word	0x00000000

08001c40 <main1>:
	}
}


int main1(void)
{
 8001c40:	b500      	push	{lr}
 8001c42:	b083      	sub	sp, #12

	  chSysInit();
 8001c44:	f001 fdd4 	bl	80037f0 <chSysInit>
	  init_USART2();
 8001c48:	f000 fa82 	bl	8002150 <init_USART2>
	  printf("Hello World 2\n");
 8001c4c:	480f      	ldr	r0, [pc, #60]	; (8001c8c <main1+0x4c>)
 8001c4e:	f7fe fccf 	bl	80005f0 <puts>
	  SendDataUSART2("Hello world 1\n", 14);


	  chThdCreateStatic(waThread_blink, sizeof(waThread_blink), NORMALPRIO, Thread_blink, NULL);
 8001c52:	2400      	movs	r4, #0
	  SendDataUSART2("Hello world 1\n", 14);
 8001c54:	210e      	movs	r1, #14
 8001c56:	480e      	ldr	r0, [pc, #56]	; (8001c90 <main1+0x50>)
 8001c58:	f000 fab2 	bl	80021c0 <SendDataUSART2>
	  chThdCreateStatic(waThread_blink, sizeof(waThread_blink), NORMALPRIO, Thread_blink, NULL);
 8001c5c:	4b0d      	ldr	r3, [pc, #52]	; (8001c94 <main1+0x54>)
 8001c5e:	9400      	str	r4, [sp, #0]
 8001c60:	2240      	movs	r2, #64	; 0x40
 8001c62:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8001c66:	480c      	ldr	r0, [pc, #48]	; (8001c98 <main1+0x58>)
 8001c68:	f001 fffa 	bl	8003c60 <chThdCreateStatic>
	  chThdCreateStatic(waThread_uart, sizeof(waThread_uart), NORMALPRIO, Thread_uart, NULL);
 8001c6c:	9400      	str	r4, [sp, #0]
 8001c6e:	4b0b      	ldr	r3, [pc, #44]	; (8001c9c <main1+0x5c>)
 8001c70:	480b      	ldr	r0, [pc, #44]	; (8001ca0 <main1+0x60>)
 8001c72:	2240      	movs	r2, #64	; 0x40
 8001c74:	f44f 61aa 	mov.w	r1, #1360	; 0x550
 8001c78:	f001 fff2 	bl	8003c60 <chThdCreateStatic>
	  chThdSetPriority(LOWPRIO);
 8001c7c:	2002      	movs	r0, #2
 8001c7e:	f002 f827 	bl	8003cd0 <chThdSetPriority>

	  while (1)
	  {
		    chThdSleepMilliseconds(10);
 8001c82:	200a      	movs	r0, #10
 8001c84:	f002 f844 	bl	8003d10 <chThdSleep>
 8001c88:	e7fb      	b.n	8001c82 <main1+0x42>
 8001c8a:	bf00      	nop
 8001c8c:	08004090 	.word	0x08004090
 8001c90:	080040a0 	.word	0x080040a0
 8001c94:	08001ad1 	.word	0x08001ad1
 8001c98:	200008f0 	.word	0x200008f0
 8001c9c:	08001b41 	.word	0x08001b41
 8001ca0:	20000ac0 	.word	0x20000ac0
	...

08001cb0 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 8001cb0:	b530      	push	{r4, r5, lr}
  RTC_DateTypeDef sDate;
  RTC_AlarmTypeDef sAlarm;

    /**Initialize RTC and set the Time and Date 
    */
  hrtc.Instance = RTC;
 8001cb2:	4d1f      	ldr	r5, [pc, #124]	; (8001d30 <MX_RTC_Init+0x80>)
 8001cb4:	4b1f      	ldr	r3, [pc, #124]	; (8001d34 <MX_RTC_Init+0x84>)
 8001cb6:	602b      	str	r3, [r5, #0]
{
 8001cb8:	b091      	sub	sp, #68	; 0x44
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8001cba:	2400      	movs	r4, #0
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
 8001cbc:	23ff      	movs	r3, #255	; 0xff
  hrtc.Init.AsynchPrediv = 127;
 8001cbe:	227f      	movs	r2, #127	; 0x7f
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  HAL_RTC_Init(&hrtc);
 8001cc0:	4628      	mov	r0, r5
  hrtc.Init.SynchPrediv = 255;
 8001cc2:	60eb      	str	r3, [r5, #12]
  hrtc.Init.AsynchPrediv = 127;
 8001cc4:	60aa      	str	r2, [r5, #8]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8001cc6:	606c      	str	r4, [r5, #4]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8001cc8:	612c      	str	r4, [r5, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8001cca:	616c      	str	r4, [r5, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8001ccc:	61ac      	str	r4, [r5, #24]
  HAL_RTC_Init(&hrtc);
 8001cce:	f001 f967 	bl	8002fa0 <HAL_RTC_Init>
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);
 8001cd2:	a901      	add	r1, sp, #4
 8001cd4:	4628      	mov	r0, r5
 8001cd6:	2201      	movs	r2, #1
  sTime.Hours = 0x0;
 8001cd8:	f88d 4004 	strb.w	r4, [sp, #4]
  sTime.Minutes = 0x0;
 8001cdc:	f88d 4005 	strb.w	r4, [sp, #5]
  sTime.Seconds = 0x0;
 8001ce0:	f88d 4006 	strb.w	r4, [sp, #6]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8001ce4:	9404      	str	r4, [sp, #16]
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8001ce6:	9405      	str	r4, [sp, #20]
  HAL_RTC_SetTime(&hrtc, &sTime, FORMAT_BCD);
 8001ce8:	f001 f9ba 	bl	8003060 <HAL_RTC_SetTime>

  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 8001cec:	a910      	add	r1, sp, #64	; 0x40
 8001cee:	4b12      	ldr	r3, [pc, #72]	; (8001d38 <MX_RTC_Init+0x88>)
 8001cf0:	f841 3d40 	str.w	r3, [r1, #-64]!
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  HAL_RTC_SetDate(&hrtc, &sDate, FORMAT_BCD);
 8001cf4:	4628      	mov	r0, r5
 8001cf6:	2201      	movs	r2, #1
 8001cf8:	f001 fa7a 	bl	80031f0 <HAL_RTC_SetDate>
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
  sAlarm.AlarmDateWeekDay = 0x1;
 8001cfc:	2301      	movs	r3, #1
  sAlarm.Alarm = RTC_ALARM_A;
  HAL_RTC_SetAlarm(&hrtc, &sAlarm, FORMAT_BCD);
 8001cfe:	4628      	mov	r0, r5
 8001d00:	461a      	mov	r2, r3
  sAlarm.Alarm = RTC_ALARM_A;
 8001d02:	f44f 7580 	mov.w	r5, #256	; 0x100
  HAL_RTC_SetAlarm(&hrtc, &sAlarm, FORMAT_BCD);
 8001d06:	a906      	add	r1, sp, #24
  sAlarm.AlarmTime.Hours = 0x0;
 8001d08:	f88d 4018 	strb.w	r4, [sp, #24]
  sAlarm.AlarmTime.Minutes = 0x0;
 8001d0c:	f88d 4019 	strb.w	r4, [sp, #25]
  sAlarm.AlarmTime.Seconds = 0x0;
 8001d10:	f88d 401a 	strb.w	r4, [sp, #26]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8001d14:	9407      	str	r4, [sp, #28]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8001d16:	9409      	str	r4, [sp, #36]	; 0x24
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8001d18:	940a      	str	r4, [sp, #40]	; 0x28
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8001d1a:	940b      	str	r4, [sp, #44]	; 0x2c
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 8001d1c:	940c      	str	r4, [sp, #48]	; 0x30
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 8001d1e:	940d      	str	r4, [sp, #52]	; 0x34
  sAlarm.AlarmDateWeekDay = 0x1;
 8001d20:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
  sAlarm.Alarm = RTC_ALARM_A;
 8001d24:	950f      	str	r5, [sp, #60]	; 0x3c
  HAL_RTC_SetAlarm(&hrtc, &sAlarm, FORMAT_BCD);
 8001d26:	f001 fb0b 	bl	8003340 <HAL_RTC_SetAlarm>

}
 8001d2a:	b011      	add	sp, #68	; 0x44
 8001d2c:	bd30      	pop	{r4, r5, pc}
 8001d2e:	bf00      	nop
 8001d30:	20001010 	.word	0x20001010
 8001d34:	40002800 	.word	0x40002800
 8001d38:	00010101 	.word	0x00010101
 8001d3c:	00000000 	.word	0x00000000

08001d40 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{

  if(hrtc->Instance==RTC)
 8001d40:	6802      	ldr	r2, [r0, #0]
 8001d42:	4b04      	ldr	r3, [pc, #16]	; (8001d54 <HAL_RTC_MspInit+0x14>)
 8001d44:	429a      	cmp	r2, r3
 8001d46:	d000      	beq.n	8001d4a <HAL_RTC_MspInit+0xa>
 8001d48:	4770      	bx	lr
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 8001d4a:	4b03      	ldr	r3, [pc, #12]	; (8001d58 <HAL_RTC_MspInit+0x18>)
 8001d4c:	2201      	movs	r2, #1
 8001d4e:	601a      	str	r2, [r3, #0]
 8001d50:	4770      	bx	lr
 8001d52:	bf00      	nop
 8001d54:	40002800 	.word	0x40002800
 8001d58:	42470e3c 	.word	0x42470e3c
 8001d5c:	00000000 	.word	0x00000000

08001d60 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001d60:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001d62:	2003      	movs	r0, #3
 8001d64:	f001 f834 	bl	8002dd0 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 2, 0);
 8001d68:	2200      	movs	r2, #0
 8001d6a:	2102      	movs	r1, #2
 8001d6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001d70:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_NVIC_SetPriority(SysTick_IRQn, 2, 0);
 8001d74:	f001 b844 	b.w	8002e00 <HAL_NVIC_SetPriority>
	...

08001d80 <MX_GPIO_Init>:
        * EXTI
        * Free pins are configured automatically as Analog (this feature is enabled through 
        * the Code Generation settings)
*/
void MX_GPIO_Init(void)
{
 8001d80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001d82:	b08b      	sub	sp, #44	; 0x2c

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOC_CLK_ENABLE();
 8001d84:	2400      	movs	r4, #0
 8001d86:	4b31      	ldr	r3, [pc, #196]	; (8001e4c <MX_GPIO_Init+0xcc>)
 8001d88:	9401      	str	r4, [sp, #4]
 8001d8a:	6b1a      	ldr	r2, [r3, #48]	; 0x30

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001d8c:	4f30      	ldr	r7, [pc, #192]	; (8001e50 <MX_GPIO_Init+0xd0>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_6 
                          |GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d8e:	4d31      	ldr	r5, [pc, #196]	; (8001e54 <MX_GPIO_Init+0xd4>)
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8001d90:	4e31      	ldr	r6, [pc, #196]	; (8001e58 <MX_GPIO_Init+0xd8>)
  __GPIOC_CLK_ENABLE();
 8001d92:	f042 0204 	orr.w	r2, r2, #4
 8001d96:	631a      	str	r2, [r3, #48]	; 0x30
 8001d98:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001d9a:	f002 0204 	and.w	r2, r2, #4
 8001d9e:	9201      	str	r2, [sp, #4]
 8001da0:	9a01      	ldr	r2, [sp, #4]
  __GPIOH_CLK_ENABLE();
 8001da2:	9402      	str	r4, [sp, #8]
 8001da4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001da6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001daa:	631a      	str	r2, [r3, #48]	; 0x30
 8001dac:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001dae:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8001db2:	9202      	str	r2, [sp, #8]
 8001db4:	9a02      	ldr	r2, [sp, #8]
  __GPIOA_CLK_ENABLE();
 8001db6:	9403      	str	r4, [sp, #12]
 8001db8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001dba:	f042 0201 	orr.w	r2, r2, #1
 8001dbe:	631a      	str	r2, [r3, #48]	; 0x30
 8001dc0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001dc2:	f002 0201 	and.w	r2, r2, #1
 8001dc6:	9203      	str	r2, [sp, #12]
 8001dc8:	9a03      	ldr	r2, [sp, #12]
  __GPIOB_CLK_ENABLE();
 8001dca:	9404      	str	r4, [sp, #16]
 8001dcc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001dce:	f042 0202 	orr.w	r2, r2, #2
 8001dd2:	631a      	str	r2, [r3, #48]	; 0x30
 8001dd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8001dd6:	9606      	str	r6, [sp, #24]
  __GPIOB_CLK_ENABLE();
 8001dd8:	f003 0302 	and.w	r3, r3, #2
 8001ddc:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001dde:	4638      	mov	r0, r7
 8001de0:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin = B1_Pin;
 8001de2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  __GPIOB_CLK_ENABLE();
 8001de6:	9a04      	ldr	r2, [sp, #16]
  GPIO_InitStruct.Pin = B1_Pin;
 8001de8:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001dea:	2603      	movs	r6, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001dec:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
 8001dee:	f000 ff17 	bl	8002c20 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001df2:	4638      	mov	r0, r7
 8001df4:	a905      	add	r1, sp, #20
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 8001df6:	f641 73ff 	movw	r3, #8191	; 0x1fff
 8001dfa:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001dfc:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001dfe:	9606      	str	r6, [sp, #24]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001e00:	f000 ff0e 	bl	8002c20 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001e04:	a905      	add	r1, sp, #20
 8001e06:	4628      	mov	r0, r5
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_6 
 8001e08:	f649 73d3 	movw	r3, #40915	; 0x9fd3
 8001e0c:	9305      	str	r3, [sp, #20]

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LD2_Pin;
 8001e0e:	2720      	movs	r7, #32
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001e10:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001e12:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001e14:	f000 ff04 	bl	8002c20 <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 8001e18:	a905      	add	r1, sp, #20
 8001e1a:	4628      	mov	r0, r5
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001e1c:	2301      	movs	r3, #1
 8001e1e:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001e20:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8001e22:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pin = LD2_Pin;
 8001e24:	9705      	str	r7, [sp, #20]
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
 8001e26:	f000 fefb 	bl	8002c20 <HAL_GPIO_Init>

  /*Configure GPIO pins : PB0 PB1 PB2 PB10 
                           PB12 PB13 PB14 PB15 
                           PB11 PB4 PB5 PB6 
                           PB7 PB8 PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10 
 8001e2a:	f64f 73f7 	movw	r3, #65527	; 0xfff7
                          |GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15 
                          |GPIO_PIN_11|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6 
                          |GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001e2e:	a905      	add	r1, sp, #20
 8001e30:	480a      	ldr	r0, [pc, #40]	; (8001e5c <MX_GPIO_Init+0xdc>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10 
 8001e32:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001e34:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001e36:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001e38:	f000 fef2 	bl	8002c20 <HAL_GPIO_Init>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
 8001e3c:	4622      	mov	r2, r4
 8001e3e:	4639      	mov	r1, r7
 8001e40:	4628      	mov	r0, r5
 8001e42:	f000 ffbd 	bl	8002dc0 <HAL_GPIO_WritePin>

}
 8001e46:	b00b      	add	sp, #44	; 0x2c
 8001e48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001e4a:	bf00      	nop
 8001e4c:	40023800 	.word	0x40023800
 8001e50:	40020800 	.word	0x40020800
 8001e54:	40020000 	.word	0x40020000
 8001e58:	10210000 	.word	0x10210000
 8001e5c:	40020400 	.word	0x40020400

08001e60 <MX_DMA_Init>:

/** 
  * Enable DMA controller clock
  */
void MX_DMA_Init(void) 
{
 8001e60:	b500      	push	{lr}
 8001e62:	b083      	sub	sp, #12
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001e64:	2200      	movs	r2, #0
 8001e66:	4b0a      	ldr	r3, [pc, #40]	; (8001e90 <MX_DMA_Init+0x30>)
 8001e68:	9201      	str	r2, [sp, #4]
 8001e6a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001e6c:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8001e70:	6319      	str	r1, [r3, #48]	; 0x30
 8001e72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001e74:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001e78:	9301      	str	r3, [sp, #4]

  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 2, 0);
 8001e7a:	2102      	movs	r1, #2
 8001e7c:	2011      	movs	r0, #17
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001e7e:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 2, 0);
 8001e80:	f000 ffbe 	bl	8002e00 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
 8001e84:	2011      	movs	r0, #17
 8001e86:	f000 fff3 	bl	8002e70 <HAL_NVIC_EnableIRQ>

}
 8001e8a:	b003      	add	sp, #12
 8001e8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e90:	40023800 	.word	0x40023800
	...

08001ea0 <MX_USART2_UART_Init>:
/* USART2 init function */

void MX_USART2_UART_Init(void)
{

  huart2.Instance = USART2;
 8001ea0:	4b09      	ldr	r3, [pc, #36]	; (8001ec8 <MX_USART2_UART_Init+0x28>)
 8001ea2:	4a0a      	ldr	r2, [pc, #40]	; (8001ecc <MX_USART2_UART_Init+0x2c>)
{
 8001ea4:	b410      	push	{r4}
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001ea6:	210c      	movs	r1, #12
  huart2.Instance = USART2;
 8001ea8:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 8001eaa:	f44f 34e1 	mov.w	r4, #115200	; 0x1c200
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8001eae:	2200      	movs	r2, #0
  huart2.Init.BaudRate = 115200;
 8001eb0:	605c      	str	r4, [r3, #4]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001eb2:	6159      	str	r1, [r3, #20]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8001eb4:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001eb6:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8001eb8:	611a      	str	r2, [r3, #16]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001eba:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8001ebc:	61da      	str	r2, [r3, #28]
  HAL_UART_Init(&huart2);
 8001ebe:	4618      	mov	r0, r3

}
 8001ec0:	f85d 4b04 	ldr.w	r4, [sp], #4
  HAL_UART_Init(&huart2);
 8001ec4:	f000 be74 	b.w	8002bb0 <HAL_UART_Init>
 8001ec8:	20001088 	.word	0x20001088
 8001ecc:	40004400 	.word	0x40004400

08001ed0 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if(huart->Instance==USART2)
 8001ed0:	4b21      	ldr	r3, [pc, #132]	; (8001f58 <HAL_UART_MspInit+0x88>)
 8001ed2:	6802      	ldr	r2, [r0, #0]
 8001ed4:	429a      	cmp	r2, r3
 8001ed6:	d000      	beq.n	8001eda <HAL_UART_MspInit+0xa>
 8001ed8:	4770      	bx	lr
{
 8001eda:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001edc:	b087      	sub	sp, #28
  {
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
    /* Peripheral clock enable */
    __USART2_CLK_ENABLE();
 8001ede:	2600      	movs	r6, #0
 8001ee0:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 8001ee4:	9600      	str	r6, [sp, #0]
 8001ee6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral DMA init*/
  
    hdma_usart2_tx.Instance = DMA1_Stream6;
 8001ee8:	4d1c      	ldr	r5, [pc, #112]	; (8001f5c <HAL_UART_MspInit+0x8c>)
    __USART2_CLK_ENABLE();
 8001eea:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001eee:	641a      	str	r2, [r3, #64]	; 0x40
 8001ef0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001ef2:	9603      	str	r6, [sp, #12]
    __USART2_CLK_ENABLE();
 8001ef4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 8001ef8:	210c      	movs	r1, #12
 8001efa:	4604      	mov	r4, r0
    __USART2_CLK_ENABLE();
 8001efc:	9300      	str	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001efe:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8001f00:	2203      	movs	r2, #3
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8001f02:	2307      	movs	r3, #7
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 8001f04:	9101      	str	r1, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001f06:	4816      	ldr	r0, [pc, #88]	; (8001f60 <HAL_UART_MspInit+0x90>)
    __USART2_CLK_ENABLE();
 8001f08:	f8dd e000 	ldr.w	lr, [sp]
    GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8001f0c:	9204      	str	r2, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001f0e:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8001f10:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001f12:	9702      	str	r7, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001f14:	f000 fe84 	bl	8002c20 <HAL_GPIO_Init>
    hdma_usart2_tx.Instance = DMA1_Stream6;
 8001f18:	4812      	ldr	r0, [pc, #72]	; (8001f64 <HAL_UART_MspInit+0x94>)
 8001f1a:	6028      	str	r0, [r5, #0]
    hdma_usart2_tx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001f1c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    hdma_usart2_tx.Init.Channel = DMA_CHANNEL_4;
 8001f20:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001f24:	2240      	movs	r2, #64	; 0x40
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
    hdma_usart2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    HAL_DMA_Init(&hdma_usart2_tx);
 8001f26:	4628      	mov	r0, r5
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001f28:	612b      	str	r3, [r5, #16]
    hdma_usart2_tx.Init.Channel = DMA_CHANNEL_4;
 8001f2a:	6069      	str	r1, [r5, #4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001f2c:	60aa      	str	r2, [r5, #8]
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001f2e:	60ee      	str	r6, [r5, #12]
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001f30:	616e      	str	r6, [r5, #20]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001f32:	61ae      	str	r6, [r5, #24]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 8001f34:	61ee      	str	r6, [r5, #28]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 8001f36:	622e      	str	r6, [r5, #32]
    hdma_usart2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8001f38:	626e      	str	r6, [r5, #36]	; 0x24
    HAL_DMA_Init(&hdma_usart2_tx);
 8001f3a:	f000 ffd9 	bl	8002ef0 <HAL_DMA_Init>

    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 8001f3e:	6325      	str	r5, [r4, #48]	; 0x30

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 8001f40:	4632      	mov	r2, r6
 8001f42:	4639      	mov	r1, r7
 8001f44:	2026      	movs	r0, #38	; 0x26
    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 8001f46:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 8001f48:	f000 ff5a 	bl	8002e00 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8001f4c:	2026      	movs	r0, #38	; 0x26
 8001f4e:	f000 ff8f 	bl	8002e70 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 8001f52:	b007      	add	sp, #28
 8001f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f56:	bf00      	nop
 8001f58:	40004400 	.word	0x40004400
 8001f5c:	20001030 	.word	0x20001030
 8001f60:	40020000 	.word	0x40020000
 8001f64:	400260a0 	.word	0x400260a0
	...

08001f70 <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 8001f70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f72:	b09b      	sub	sp, #108	; 0x6c

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

  __PWR_CLK_ENABLE();
 8001f74:	2500      	movs	r5, #0
 8001f76:	4a2a      	ldr	r2, [pc, #168]	; (8002020 <SystemClock_Config+0xb0>)
 8001f78:	9500      	str	r5, [sp, #0]
 8001f7a:	6c11      	ldr	r1, [r2, #64]	; 0x40

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001f7c:	4b29      	ldr	r3, [pc, #164]	; (8002024 <SystemClock_Config+0xb4>)
  __PWR_CLK_ENABLE();
 8001f7e:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001f82:	6411      	str	r1, [r2, #64]	; 0x40
 8001f84:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001f86:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8001f8a:	9200      	str	r2, [sp, #0]
 8001f8c:	9a00      	ldr	r2, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001f8e:	9501      	str	r5, [sp, #4]
 8001f90:	681a      	ldr	r2, [r3, #0]
 8001f92:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8001f96:	601a      	str	r2, [r3, #0]
 8001f98:	681b      	ldr	r3, [r3, #0]
 8001f9a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8001f9e:	9301      	str	r3, [sp, #4]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001fa0:	f04f 0e01 	mov.w	lr, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001fa4:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 400;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 8001fa6:	2604      	movs	r6, #4
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
 8001fa8:	2305      	movs	r3, #5
  RCC_OscInitStruct.PLL.PLLM = 8;
 8001faa:	2108      	movs	r1, #8
  RCC_OscInitStruct.PLL.PLLN = 400;
 8001fac:	f44f 72c8 	mov.w	r2, #400	; 0x190
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001fb0:	9801      	ldr	r0, [sp, #4]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001fb2:	f8cd e03c 	str.w	lr, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001fb6:	f44f 0780 	mov.w	r7, #4194304	; 0x400000
  RCC_OscInitStruct.PLL.PLLQ = 4;
  RCC_OscInitStruct.PLL.PLLR = 2;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001fba:	a80d      	add	r0, sp, #52	; 0x34
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
 8001fbc:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
 8001fbe:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLM = 8;
 8001fc0:	9115      	str	r1, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLN = 400;
 8001fc2:	9216      	str	r2, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001fc4:	9413      	str	r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLR = 2;
 8001fc6:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001fc8:	9714      	str	r7, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 8001fca:	9617      	str	r6, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8001fcc:	9618      	str	r6, [sp, #96]	; 0x60
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8001fce:	f000 fa77 	bl	80024c0 <HAL_RCC_OscConfig>
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001fd2:	4621      	mov	r1, r4
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001fd4:	220f      	movs	r2, #15
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8001fd6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001fda:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001fdc:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8001fde:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001fe0:	9403      	str	r4, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001fe2:	9504      	str	r5, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8001fe4:	9506      	str	r5, [sp, #24]
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
 8001fe6:	f001 faa3 	bl	8003530 <HAL_RCC_ClockConfig>

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8001fea:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001fee:	a807      	add	r0, sp, #28
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8001ff0:	9309      	str	r3, [sp, #36]	; 0x24
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8001ff2:	9607      	str	r6, [sp, #28]
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8001ff4:	f000 f9c4 	bl	8002380 <HAL_RCCEx_PeriphCLKConfig>

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001ff8:	f001 fb82 	bl	8003700 <HAL_RCC_GetHCLKFreq>
 8001ffc:	4b0a      	ldr	r3, [pc, #40]	; (8002028 <SystemClock_Config+0xb8>)
 8001ffe:	fba3 3000 	umull	r3, r0, r3, r0
 8002002:	0980      	lsrs	r0, r0, #6
 8002004:	f000 ff44 	bl	8002e90 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8002008:	4630      	mov	r0, r6
 800200a:	f000 ff61 	bl	8002ed0 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 2, 0);
 800200e:	462a      	mov	r2, r5
 8002010:	4621      	mov	r1, r4
 8002012:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002016:	f000 fef3 	bl	8002e00 <HAL_NVIC_SetPriority>
}
 800201a:	b01b      	add	sp, #108	; 0x6c
 800201c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800201e:	bf00      	nop
 8002020:	40023800 	.word	0x40023800
 8002024:	40007000 	.word	0x40007000
 8002028:	10624dd3 	.word	0x10624dd3
 800202c:	00000000 	.word	0x00000000

08002030 <main>:
{
 8002030:	b508      	push	{r3, lr}
  HAL_Init();
 8002032:	f000 fc15 	bl	8002860 <HAL_Init>
  SystemClock_Config();
 8002036:	f7ff ff9b 	bl	8001f70 <SystemClock_Config>
  MX_GPIO_Init();
 800203a:	f7ff fea1 	bl	8001d80 <MX_GPIO_Init>
  MX_DMA_Init();
 800203e:	f7ff ff0f 	bl	8001e60 <MX_DMA_Init>
  MX_RTC_Init();
 8002042:	f7ff fe35 	bl	8001cb0 <MX_RTC_Init>
  MX_USART2_UART_Init();
 8002046:	f7ff ff2b 	bl	8001ea0 <MX_USART2_UART_Init>
main1();
 800204a:	f7ff fdf9 	bl	8001c40 <main1>
 800204e:	e7fe      	b.n	800204e <main+0x1e>

08002050 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8002050:	b410      	push	{r4}
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8002052:	4910      	ldr	r1, [pc, #64]	; (8002094 <SystemInit+0x44>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8002054:	4b10      	ldr	r3, [pc, #64]	; (8002098 <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8002056:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800205a:	4c10      	ldr	r4, [pc, #64]	; (800209c <SystemInit+0x4c>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800205c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8002060:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
 8002064:	681a      	ldr	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8002066:	2000      	movs	r0, #0
  RCC->CR |= (uint32_t)0x00000001;
 8002068:	f042 0201 	orr.w	r2, r2, #1
 800206c:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 800206e:	6098      	str	r0, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8002070:	681a      	ldr	r2, [r3, #0]
 8002072:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8002076:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800207a:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 800207c:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800207e:	681a      	ldr	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8002080:	f04f 6400 	mov.w	r4, #134217728	; 0x8000000
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8002084:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002088:	601a      	str	r2, [r3, #0]
  RCC->CIR = 0x00000000;
 800208a:	60d8      	str	r0, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800208c:	608c      	str	r4, [r1, #8]
#endif
}
 800208e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002092:	4770      	bx	lr
 8002094:	e000ed00 	.word	0xe000ed00
 8002098:	40023800 	.word	0x40023800
 800209c:	24003010 	.word	0x24003010

080020a0 <__late_init>:

void SystemInit(void);

void __late_init(void) {
	// call STM HAL SystemInit()
	SystemInit();
 80020a0:	f7ff bfd6 	b.w	8002050 <SystemInit>
	...

080020b0 <SysTick_Handler>:

// SysTick_Handler required for Chibios in classic (non-tickless) mode
// Call STM HAL_ functions from here (if required)

void SysTick_Handler(void)
{
 80020b0:	b508      	push	{r3, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80020b2:	2320      	movs	r3, #32
 80020b4:	f383 8811 	msr	BASEPRI, r3
	  CH_IRQ_PROLOGUE();

	  chSysLockFromISR();
	  chSysTimerHandlerI();
 80020b8:	f001 fbea 	bl	8003890 <chSysTimerHandlerI>
 80020bc:	2300      	movs	r3, #0
 80020be:	f383 8811 	msr	BASEPRI, r3
	  chSysUnlockFromISR();

	  CH_IRQ_EPILOGUE();
 80020c2:	f001 ff05 	bl	8003ed0 <_port_irq_epilogue>

	  HAL_IncTick();
	  //HAL_SYSTICK_IRQHandler();

}
 80020c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	  HAL_IncTick();
 80020ca:	f000 bbe9 	b.w	80028a0 <HAL_IncTick>
 80020ce:	bf00      	nop

080020d0 <_read_r>:
{
  (void)r;
  (void)file;
  (void)ptr;
  (void)len;
  __errno_r(r) = EINVAL;
 80020d0:	2316      	movs	r3, #22
 80020d2:	6003      	str	r3, [r0, #0]
  return -1;
}
 80020d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80020d8:	4770      	bx	lr
 80020da:	bf00      	nop
 80020dc:	0000      	movs	r0, r0
	...

080020e0 <_lseek_r>:
  (void)file;
  (void)ptr;
  (void)dir;

  return 0;
}
 80020e0:	2000      	movs	r0, #0
 80020e2:	4770      	bx	lr
	...

080020f0 <_write_r>:

/***************************************************************************/

int _write_r(struct _reent *r, int file, char * ptr, int len)
{
 80020f0:	b510      	push	{r4, lr}
  (void)file;
  (void)ptr;
#if STDOUT_USART == 1
  SendDataUSART1(ptr, (size_t)len);
#elif STDOUT_USART == 2
  SendDataUSART2(ptr, (size_t)len);
 80020f2:	4610      	mov	r0, r2
{
 80020f4:	461c      	mov	r4, r3
  SendDataUSART2(ptr, (size_t)len);
 80020f6:	4619      	mov	r1, r3
 80020f8:	f000 f862 	bl	80021c0 <SendDataUSART2>
  SendDataUSART3(ptr, (size_t)len);
#elif STDOUT_USART == 6
  SendDataUSART6(ptr, (size_t)len);
#endif
  return len;
}
 80020fc:	4620      	mov	r0, r4
 80020fe:	bd10      	pop	{r4, pc}

08002100 <_close_r>:
{
  (void)r;
  (void)file;

  return 0;
}
 8002100:	2000      	movs	r0, #0
 8002102:	4770      	bx	lr
	...

08002110 <_sbrk_r>:
/***************************************************************************/

#ifdef USE_CHIBIOS

caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8002110:	b510      	push	{r4, lr}
 8002112:	4604      	mov	r4, r0
  void *p;

  //chDbgCheck(incr > 0, "_sbrk_r");

  (void)r;
  p = chCoreAlloc((size_t)incr);
 8002114:	4608      	mov	r0, r1
 8002116:	f001 fe93 	bl	8003e40 <chCoreAlloc>
  if (p == NULL) {
 800211a:	b100      	cbz	r0, 800211e <_sbrk_r+0xe>
  return (caddr_t)p;
#else
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 800211c:	bd10      	pop	{r4, pc}
    __errno_r(r) = ENOMEM;
 800211e:	230c      	movs	r3, #12
 8002120:	6023      	str	r3, [r4, #0]
    return (caddr_t)-1;
 8002122:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002126:	bd10      	pop	{r4, pc}
	...

08002130 <_fstat_r>:
#endif

/***************************************************************************/

int _fstat_r(struct _reent *r, int file, struct stat * st)
{
 8002130:	b508      	push	{r3, lr}
  (void)r;
  (void)file;

  memset(st, 0, sizeof(*st));
 8002132:	4610      	mov	r0, r2
 8002134:	2100      	movs	r1, #0
 8002136:	223c      	movs	r2, #60	; 0x3c
 8002138:	f7fe f96a 	bl	8000410 <memset>
  //st->st_mode = S_IFCHR;
  return 0;
}
 800213c:	2000      	movs	r0, #0
 800213e:	bd08      	pop	{r3, pc}

08002140 <_isatty_r>:
{
  (void)r;
  (void)fd;

  return 1;
}
 8002140:	2001      	movs	r0, #1
 8002142:	4770      	bx	lr
	...

08002150 <init_USART2>:
#define USARTx_TDR TDR
#define USARTx_ISR ISR
#endif

void init_USARTx(void)
{
 8002150:	b570      	push	{r4, r5, r6, lr}
	/* Assume: usart and dma basically initialized by cube generated fw */
  rxbpx=0; rxrpx=0; txrx=0;
  huartx.Init.BaudRate = USARTx_BAUD;
 8002152:	4c15      	ldr	r4, [pc, #84]	; (80021a8 <init_USART2+0x58>)
  rxbpx=0; rxrpx=0; txrx=0;
 8002154:	4915      	ldr	r1, [pc, #84]	; (80021ac <init_USART2+0x5c>)
 8002156:	4e16      	ldr	r6, [pc, #88]	; (80021b0 <init_USART2+0x60>)
 8002158:	4d16      	ldr	r5, [pc, #88]	; (80021b4 <init_USART2+0x64>)
 800215a:	2300      	movs	r3, #0
  huartx.Init.BaudRate = USARTx_BAUD;
 800215c:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
  huartx.Init.WordLength = UART_WORDLENGTH_8B;
  huartx.Init.StopBits = UART_STOPBITS_1;
  huartx.Init.Parity = UART_PARITY_NONE;
  UART_SetConfig(&huartx);
 8002160:	4620      	mov	r0, r4
  rxbpx=0; rxrpx=0; txrx=0;
 8002162:	8033      	strh	r3, [r6, #0]
  huartx.Init.WordLength = UART_WORDLENGTH_8B;
 8002164:	60a3      	str	r3, [r4, #8]
  rxbpx=0; rxrpx=0; txrx=0;
 8002166:	802b      	strh	r3, [r5, #0]
  huartx.Init.StopBits = UART_STOPBITS_1;
 8002168:	60e3      	str	r3, [r4, #12]
  rxbpx=0; rxrpx=0; txrx=0;
 800216a:	800b      	strh	r3, [r1, #0]
  huartx.Init.Parity = UART_PARITY_NONE;
 800216c:	6123      	str	r3, [r4, #16]
  huartx.Init.BaudRate = USARTx_BAUD;
 800216e:	6062      	str	r2, [r4, #4]
  UART_SetConfig(&huartx);
 8002170:	f000 fba6 	bl	80028c0 <UART_SetConfig>
#ifdef DMAv2
  USARTx_Tx_DMA->FCR &= ~(DMA_IT_FE);
 8002174:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002176:	681a      	ldr	r2, [r3, #0]
 8002178:	6953      	ldr	r3, [r2, #20]
 800217a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800217e:	6153      	str	r3, [r2, #20]
  USARTx_Tx_DMA->CR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE | DMA_IT_DME);
 8002180:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002182:	681a      	ldr	r2, [r3, #0]
 8002184:	6813      	ldr	r3, [r2, #0]
 8002186:	f023 031e 	bic.w	r3, r3, #30
 800218a:	6013      	str	r3, [r2, #0]
#endif
  huartx.Instance->CR3 |= USART_CR3_DMAT;
 800218c:	6823      	ldr	r3, [r4, #0]
 800218e:	695a      	ldr	r2, [r3, #20]
  USARTx_CLRTC;
 8002190:	f06f 0140 	mvn.w	r1, #64	; 0x40
  huartx.Instance->CR3 |= USART_CR3_DMAT;
 8002194:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8002198:	615a      	str	r2, [r3, #20]
  USARTx_CLRTC;
 800219a:	6019      	str	r1, [r3, #0]
  __HAL_USART_ENABLE_IT(&huartx, USART_IT_RXNE);
 800219c:	6822      	ldr	r2, [r4, #0]
 800219e:	68d3      	ldr	r3, [r2, #12]
 80021a0:	f043 0320 	orr.w	r3, r3, #32
 80021a4:	60d3      	str	r3, [r2, #12]
 80021a6:	bd70      	pop	{r4, r5, r6, pc}
 80021a8:	20001088 	.word	0x20001088
 80021ac:	200012d4 	.word	0x200012d4
 80021b0:	200010cc 	.word	0x200010cc
 80021b4:	200011d2 	.word	0x200011d2
	...

080021c0 <SendDataUSART2>:
}

void SendDataUSARTx(char *USARTx_TxBuffer, int Length)
{
 80021c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  int wf=1;
  if (txrx) WaitUSARTx();
 80021c4:	4c33      	ldr	r4, [pc, #204]	; (8002294 <SendDataUSART2+0xd4>)
 80021c6:	8823      	ldrh	r3, [r4, #0]
 80021c8:	b21b      	sxth	r3, r3
{
 80021ca:	4606      	mov	r6, r0
 80021cc:	460d      	mov	r5, r1
  if (txrx) WaitUSARTx();
 80021ce:	2b00      	cmp	r3, #0
 80021d0:	d147      	bne.n	8002262 <SendDataUSART2+0xa2>
  txrx=Length;
 80021d2:	b22b      	sxth	r3, r5
  if ((Length <= sizeof(txbufx)) && (USARTx_TxBuffer!=txbufx)) {
 80021d4:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
  txrx=Length;
 80021d8:	8023      	strh	r3, [r4, #0]
  if ((Length <= sizeof(txbufx)) && (USARTx_TxBuffer!=txbufx)) {
 80021da:	d80a      	bhi.n	80021f2 <SendDataUSART2+0x32>
 80021dc:	4b2e      	ldr	r3, [pc, #184]	; (8002298 <SendDataUSART2+0xd8>)
 80021de:	429e      	cmp	r6, r3
 80021e0:	d007      	beq.n	80021f2 <SendDataUSART2+0x32>
    memcpy(txbufx, USARTx_TxBuffer, Length);
 80021e2:	4631      	mov	r1, r6
 80021e4:	462a      	mov	r2, r5
 80021e6:	4618      	mov	r0, r3
 80021e8:	f7fe f872 	bl	80002d0 <memcpy>
	USARTx_TxBuffer = txbufx;
 80021ec:	4606      	mov	r6, r0
	wf=0;
 80021ee:	2000      	movs	r0, #0
 80021f0:	e000      	b.n	80021f4 <SendDataUSART2+0x34>
  int wf=1;
 80021f2:	2001      	movs	r0, #1
  }
  // Set DE
  USARTx_DE_ON;
#ifdef DMAv2
  USARTx_Tx_DMA->CR &= ~(DMA_SxCR_EN | DMA_SxCR_DBM);
 80021f4:	4b29      	ldr	r3, [pc, #164]	; (800229c <SendDataUSART2+0xdc>)
 80021f6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80021f8:	6811      	ldr	r1, [r2, #0]
 80021fa:	680a      	ldr	r2, [r1, #0]
 80021fc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002200:	f022 0201 	bic.w	r2, r2, #1
 8002204:	600a      	str	r2, [r1, #0]
  USARTx_Tx_DMA->NDTR = Length;
 8002206:	6b19      	ldr	r1, [r3, #48]	; 0x30
  USARTx_Tx_DMA->PAR  = (unsigned long)&huartx.Instance->USARTx_TDR;
 8002208:	681a      	ldr	r2, [r3, #0]
  USARTx_Tx_DMA->NDTR = Length;
 800220a:	6809      	ldr	r1, [r1, #0]
 800220c:	604d      	str	r5, [r1, #4]
  USARTx_Tx_DMA->PAR  = (unsigned long)&huartx.Instance->USARTx_TDR;
 800220e:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8002210:	6809      	ldr	r1, [r1, #0]
 8002212:	3204      	adds	r2, #4
 8002214:	608a      	str	r2, [r1, #8]
  USARTx_Tx_DMA->M0AR = (unsigned long)USARTx_TxBuffer;
 8002216:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002218:	6812      	ldr	r2, [r2, #0]
 800221a:	60d6      	str	r6, [r2, #12]
  USARTx_Tx_DMA->CR |= (DMA_IT_TC | DMA_SxCR_EN);
 800221c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800221e:	681a      	ldr	r2, [r3, #0]
 8002220:	6813      	ldr	r3, [r2, #0]
 8002222:	f043 0311 	orr.w	r3, r3, #17
 8002226:	6013      	str	r3, [r2, #0]
  USARTx_Tx_DMA->CNDTR = Length;
  USARTx_Tx_DMA->CPAR  = (unsigned long)&huartx.Instance->USARTx_TDR;
  USARTx_Tx_DMA->CMAR = (unsigned long)USARTx_TxBuffer;
  USARTx_Tx_DMA->CCR |= (DMA_IT_TC | 0x0001);
#endif
  if (wf) WaitUSARTx();
 8002228:	b908      	cbnz	r0, 800222e <SendDataUSART2+0x6e>
 800222a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

#ifdef USE_CHIBIOS

void WaitUSARTx(void)
{
	tprio_t oldp = chThdSetPriority(HIGHPRIO);
 800222e:	207f      	movs	r0, #127	; 0x7f
 8002230:	f001 fd4e 	bl	8003cd0 <chThdSetPriority>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002234:	4a1a      	ldr	r2, [pc, #104]	; (80022a0 <SendDataUSART2+0xe0>)
    USARTx_t = chThdGetSelfX();
	while (txrx) chEvtWaitAnyTimeout(USARTx_tx_EVT,10);
 8002236:	8823      	ldrh	r3, [r4, #0]
    USARTx_t = chThdGetSelfX();
 8002238:	4f1a      	ldr	r7, [pc, #104]	; (80022a4 <SendDataUSART2+0xe4>)
 800223a:	6992      	ldr	r2, [r2, #24]
 800223c:	603a      	str	r2, [r7, #0]
	while (txrx) chEvtWaitAnyTimeout(USARTx_tx_EVT,10);
 800223e:	b21b      	sxth	r3, r3
	tprio_t oldp = chThdSetPriority(HIGHPRIO);
 8002240:	4605      	mov	r5, r0
	while (txrx) chEvtWaitAnyTimeout(USARTx_tx_EVT,10);
 8002242:	b13b      	cbz	r3, 8002254 <SendDataUSART2+0x94>
 8002244:	210a      	movs	r1, #10
 8002246:	2002      	movs	r0, #2
 8002248:	f001 fdba 	bl	8003dc0 <chEvtWaitAnyTimeout>
 800224c:	8823      	ldrh	r3, [r4, #0]
 800224e:	b21b      	sxth	r3, r3
 8002250:	2b00      	cmp	r3, #0
 8002252:	d1f7      	bne.n	8002244 <SendDataUSART2+0x84>
	chThdSetPriority(oldp);
 8002254:	4628      	mov	r0, r5
 8002256:	f001 fd3b 	bl	8003cd0 <chThdSetPriority>
    USARTx_t = NULL;
 800225a:	2300      	movs	r3, #0
 800225c:	603b      	str	r3, [r7, #0]
 800225e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tprio_t oldp = chThdSetPriority(HIGHPRIO);
 8002262:	207f      	movs	r0, #127	; 0x7f
 8002264:	f001 fd34 	bl	8003cd0 <chThdSetPriority>
 8002268:	4a0d      	ldr	r2, [pc, #52]	; (80022a0 <SendDataUSART2+0xe0>)
	while (txrx) chEvtWaitAnyTimeout(USARTx_tx_EVT,10);
 800226a:	8823      	ldrh	r3, [r4, #0]
    USARTx_t = chThdGetSelfX();
 800226c:	4f0d      	ldr	r7, [pc, #52]	; (80022a4 <SendDataUSART2+0xe4>)
 800226e:	6992      	ldr	r2, [r2, #24]
 8002270:	603a      	str	r2, [r7, #0]
	while (txrx) chEvtWaitAnyTimeout(USARTx_tx_EVT,10);
 8002272:	b21b      	sxth	r3, r3
	tprio_t oldp = chThdSetPriority(HIGHPRIO);
 8002274:	4680      	mov	r8, r0
	while (txrx) chEvtWaitAnyTimeout(USARTx_tx_EVT,10);
 8002276:	b13b      	cbz	r3, 8002288 <SendDataUSART2+0xc8>
 8002278:	210a      	movs	r1, #10
 800227a:	2002      	movs	r0, #2
 800227c:	f001 fda0 	bl	8003dc0 <chEvtWaitAnyTimeout>
 8002280:	8823      	ldrh	r3, [r4, #0]
 8002282:	b21b      	sxth	r3, r3
 8002284:	2b00      	cmp	r3, #0
 8002286:	d1f7      	bne.n	8002278 <SendDataUSART2+0xb8>
	chThdSetPriority(oldp);
 8002288:	4640      	mov	r0, r8
 800228a:	f001 fd21 	bl	8003cd0 <chThdSetPriority>
    USARTx_t = NULL;
 800228e:	2300      	movs	r3, #0
 8002290:	603b      	str	r3, [r7, #0]
 8002292:	e79e      	b.n	80021d2 <SendDataUSART2+0x12>
 8002294:	200012d4 	.word	0x200012d4
 8002298:	200011d4 	.word	0x200011d4
 800229c:	20001088 	.word	0x20001088
 80022a0:	200012e0 	.word	0x200012e0
 80022a4:	200010c8 	.word	0x200010c8
	...

080022b0 <Vector84>:
#ifndef DMA_IRQ_USARTx_TX
#error usartx dma not defined
#endif

void DMA_IRQ_USARTx_TX(void)
{
 80022b0:	b510      	push	{r4, lr}
#ifdef USE_CHIBIOS
  CH_IRQ_PROLOGUE();
#endif
  if (TCIF_USARTx_TX)
 80022b2:	4b12      	ldr	r3, [pc, #72]	; (80022fc <Vector84+0x4c>)
 80022b4:	685a      	ldr	r2, [r3, #4]
 80022b6:	0292      	lsls	r2, r2, #10
 80022b8:	d510      	bpl.n	80022dc <Vector84+0x2c>
  {
	  /* Enable USART Transmit complete interrupt */
	  USARTx_CLRTC;
 80022ba:	4a11      	ldr	r2, [pc, #68]	; (8002300 <Vector84+0x50>)
	  __HAL_USART_ENABLE_IT(&huartx, USART_IT_TC);

	  /* Clear DMA TC pending bit */
	  CTCIF_USARTx_TX;
	  txrx=0;
 80022bc:	4811      	ldr	r0, [pc, #68]	; (8002304 <Vector84+0x54>)
	  USARTx_CLRTC;
 80022be:	6811      	ldr	r1, [r2, #0]
 80022c0:	f06f 0440 	mvn.w	r4, #64	; 0x40
 80022c4:	600c      	str	r4, [r1, #0]
	  __HAL_USART_ENABLE_IT(&huartx, USART_IT_TC);
 80022c6:	6811      	ldr	r1, [r2, #0]
 80022c8:	68ca      	ldr	r2, [r1, #12]
 80022ca:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80022ce:	60ca      	str	r2, [r1, #12]
	  CTCIF_USARTx_TX;
 80022d0:	68da      	ldr	r2, [r3, #12]
	  txrx=0;
 80022d2:	2100      	movs	r1, #0
	  CTCIF_USARTx_TX;
 80022d4:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80022d8:	60da      	str	r2, [r3, #12]
	  txrx=0;
 80022da:	8001      	strh	r1, [r0, #0]
 80022dc:	2320      	movs	r3, #32
 80022de:	f383 8811 	msr	BASEPRI, r3
  };
#ifdef USE_CHIBIOS
  chSysLockFromISR();
  if (USARTx_t) chEvtSignalI(USARTx_t, USARTx_tx_EVT);
 80022e2:	4b09      	ldr	r3, [pc, #36]	; (8002308 <Vector84+0x58>)
 80022e4:	6818      	ldr	r0, [r3, #0]
 80022e6:	b110      	cbz	r0, 80022ee <Vector84+0x3e>
 80022e8:	2102      	movs	r1, #2
 80022ea:	f001 fd51 	bl	8003d90 <chEvtSignalI>
 80022ee:	2300      	movs	r3, #0
 80022f0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlockFromISR();
  CH_IRQ_EPILOGUE();
#endif
}
 80022f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CH_IRQ_EPILOGUE();
 80022f8:	f001 bdea 	b.w	8003ed0 <_port_irq_epilogue>
 80022fc:	40026000 	.word	0x40026000
 8002300:	20001088 	.word	0x20001088
 8002304:	200012d4 	.word	0x200012d4
 8002308:	200010c8 	.word	0x200010c8
 800230c:	00000000 	.word	0x00000000

08002310 <VectorD8>:

/* Override the HAL / cube generated ISR */

void USARTx_IRQHandler(void)
{
 8002310:	b410      	push	{r4}
#ifdef USE_CHIBIOS
  CH_IRQ_PROLOGUE();
#endif
	/* Transfer Complete: Reset DE */
	/* STM32F7 usarts have their own DE line, but I continue to use the old style here */
  int sr = huartx.Instance->USARTx_ISR;
 8002312:	4915      	ldr	r1, [pc, #84]	; (8002368 <VectorD8+0x58>)
 8002314:	680a      	ldr	r2, [r1, #0]
 8002316:	6813      	ldr	r3, [r2, #0]
  if (sr & USART_FLAG_TC) {
 8002318:	0658      	lsls	r0, r3, #25
 800231a:	d505      	bpl.n	8002328 <VectorD8+0x18>
	  USARTx_DE_OFF;
	  __HAL_USART_DISABLE_IT(&huartx, USART_IT_TC);
 800231c:	68d0      	ldr	r0, [r2, #12]
	  USARTx_CLRTC;
 800231e:	f06f 0440 	mvn.w	r4, #64	; 0x40
	  __HAL_USART_DISABLE_IT(&huartx, USART_IT_TC);
 8002322:	4020      	ands	r0, r4
 8002324:	60d0      	str	r0, [r2, #12]
	  USARTx_CLRTC;
 8002326:	6014      	str	r4, [r2, #0]
  };

  if (sr & USART_FLAG_RXNE) {
 8002328:	069a      	lsls	r2, r3, #26
 800232a:	d514      	bpl.n	8002356 <VectorD8+0x46>
	  if (sr & USART_FLAG_IDLE) {
 800232c:	f013 0f10 	tst.w	r3, #16
		rxidlx=rxbpx;  // IDLE
 8002330:	4b0e      	ldr	r3, [pc, #56]	; (800236c <VectorD8+0x5c>)
	  if (sr & USART_FLAG_IDLE) {
 8002332:	d114      	bne.n	800235e <VectorD8+0x4e>
	  }
      rxbufx[rxbpx] = huartx.Instance->USARTx_RDR;
 8002334:	680a      	ldr	r2, [r1, #0]
 8002336:	8819      	ldrh	r1, [r3, #0]
 8002338:	6854      	ldr	r4, [r2, #4]
	  rxbpx++;
 800233a:	881a      	ldrh	r2, [r3, #0]
      rxbufx[rxbpx] = huartx.Instance->USARTx_RDR;
 800233c:	480c      	ldr	r0, [pc, #48]	; (8002370 <VectorD8+0x60>)
	  rxbpx++;
 800233e:	3201      	adds	r2, #1
 8002340:	b212      	sxth	r2, r2
 8002342:	801a      	strh	r2, [r3, #0]
	  if (rxbpx>=RXBUFSIZE) rxbpx=0;
 8002344:	881a      	ldrh	r2, [r3, #0]
      rxbufx[rxbpx] = huartx.Instance->USARTx_RDR;
 8002346:	b209      	sxth	r1, r1
	  if (rxbpx>=RXBUFSIZE) rxbpx=0;
 8002348:	b212      	sxth	r2, r2
 800234a:	2aff      	cmp	r2, #255	; 0xff
 800234c:	bfc8      	it	gt
 800234e:	2200      	movgt	r2, #0
      rxbufx[rxbpx] = huartx.Instance->USARTx_RDR;
 8002350:	5444      	strb	r4, [r0, r1]
	  if (rxbpx>=RXBUFSIZE) rxbpx=0;
 8002352:	bfc8      	it	gt
 8002354:	801a      	strhgt	r2, [r3, #0]
  }
#ifdef USE_CHIBIOS
  CH_IRQ_EPILOGUE();
#endif
}
 8002356:	f85d 4b04 	ldr.w	r4, [sp], #4
  CH_IRQ_EPILOGUE();
 800235a:	f001 bdb9 	b.w	8003ed0 <_port_irq_epilogue>
		rxidlx=rxbpx;  // IDLE
 800235e:	4a05      	ldr	r2, [pc, #20]	; (8002374 <VectorD8+0x64>)
 8002360:	8818      	ldrh	r0, [r3, #0]
 8002362:	8010      	strh	r0, [r2, #0]
 8002364:	e7e6      	b.n	8002334 <VectorD8+0x24>
 8002366:	bf00      	nop
 8002368:	20001088 	.word	0x20001088
 800236c:	200010cc 	.word	0x200010cc
 8002370:	200010d0 	.word	0x200010d0
 8002374:	200011d0 	.word	0x200011d0
	...

08002380 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *              
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002380:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002382:	4604      	mov	r4, r0
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8002384:	6800      	ldr	r0, [r0, #0]
 8002386:	0743      	lsls	r3, r0, #29
{
 8002388:	b083      	sub	sp, #12
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800238a:	d42d      	bmi.n	80023e8 <HAL_RCCEx_PeriphCLKConfig+0x68>
    }
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800238c:	0781      	lsls	r1, r0, #30
 800238e:	d503      	bpl.n	8002398 <HAL_RCCEx_PeriphCLKConfig+0x18>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8002390:	4b45      	ldr	r3, [pc, #276]	; (80024a8 <HAL_RCCEx_PeriphCLKConfig+0x128>)
 8002392:	7d22      	ldrb	r2, [r4, #20]
 8002394:	601a      	str	r2, [r3, #0]
 8002396:	6820      	ldr	r0, [r4, #0]
  }
  /*--------------------------------------------------------------------------*/
    
  /*---------------------------- FMPI2C1 Configuration -----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMPI2C1) == RCC_PERIPHCLK_FMPI2C1)
 8002398:	0702      	lsls	r2, r0, #28
 800239a:	d509      	bpl.n	80023b0 <HAL_RCCEx_PeriphCLKConfig+0x30>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMPI2C1CLKSOURCE(PeriphClkInit->Fmpi2c1ClockSelection));
    
    /* Configure the FMPI2C1 clock source */
    __HAL_RCC_FMPI2C1_CONFIG(PeriphClkInit->Fmpi2c1ClockSelection);
 800239c:	4a43      	ldr	r2, [pc, #268]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 800239e:	6921      	ldr	r1, [r4, #16]
 80023a0:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 80023a4:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 80023a8:	430b      	orrs	r3, r1
 80023aa:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80023ae:	6820      	ldr	r0, [r4, #0]
  }
  /*--------------------------------------------------------------------------*/
  
  /*---------------------------- LPTIM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 80023b0:	06c3      	lsls	r3, r0, #27
 80023b2:	d40e      	bmi.n	80023d2 <HAL_RCCEx_PeriphCLKConfig+0x52>
    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
  }

  /*---------------------------- I2S Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 80023b4:	f010 0001 	ands.w	r0, r0, #1
 80023b8:	d009      	beq.n	80023ce <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SAPBCLKSOURCE(PeriphClkInit->I2SClockSelection));
    
    /* Configure the I2S clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2SClockSelection);
 80023ba:	4a3c      	ldr	r2, [pc, #240]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 80023bc:	6861      	ldr	r1, [r4, #4]
 80023be:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 80023c2:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 80023c6:	430b      	orrs	r3, r1
 80023c8:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  }

  return HAL_OK;
 80023cc:	2000      	movs	r0, #0
}
 80023ce:	b003      	add	sp, #12
 80023d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80023d2:	4a36      	ldr	r2, [pc, #216]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 80023d4:	68e1      	ldr	r1, [r4, #12]
 80023d6:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 80023da:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 80023de:	430b      	orrs	r3, r1
 80023e0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 80023e4:	6820      	ldr	r0, [r4, #0]
 80023e6:	e7e5      	b.n	80023b4 <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_PWR_CLK_ENABLE();
 80023e8:	4b30      	ldr	r3, [pc, #192]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
    PWR->CR |= PWR_CR_DBP;
 80023ea:	4d31      	ldr	r5, [pc, #196]	; (80024b0 <HAL_RCCEx_PeriphCLKConfig+0x130>)
    __HAL_RCC_PWR_CLK_ENABLE();
 80023ec:	2200      	movs	r2, #0
 80023ee:	9201      	str	r2, [sp, #4]
 80023f0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80023f2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80023f6:	641a      	str	r2, [r3, #64]	; 0x40
 80023f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80023fa:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80023fe:	9301      	str	r3, [sp, #4]
 8002400:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8002402:	682b      	ldr	r3, [r5, #0]
 8002404:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002408:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 800240a:	f000 fa51 	bl	80028b0 <HAL_GetTick>
 800240e:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8002410:	e004      	b.n	800241c <HAL_RCCEx_PeriphCLKConfig+0x9c>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002412:	f000 fa4d 	bl	80028b0 <HAL_GetTick>
 8002416:	1b80      	subs	r0, r0, r6
 8002418:	2802      	cmp	r0, #2
 800241a:	d836      	bhi.n	800248a <HAL_RCCEx_PeriphCLKConfig+0x10a>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800241c:	682b      	ldr	r3, [r5, #0]
 800241e:	05df      	lsls	r7, r3, #23
 8002420:	d5f7      	bpl.n	8002412 <HAL_RCCEx_PeriphCLKConfig+0x92>
    if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8002422:	4b22      	ldr	r3, [pc, #136]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 8002424:	68a1      	ldr	r1, [r4, #8]
 8002426:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002428:	404a      	eors	r2, r1
 800242a:	f412 7f40 	tst.w	r2, #768	; 0x300
 800242e:	d01c      	beq.n	800246a <HAL_RCCEx_PeriphCLKConfig+0xea>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002430:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8002432:	4920      	ldr	r1, [pc, #128]	; (80024b4 <HAL_RCCEx_PeriphCLKConfig+0x134>)
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002434:	2500      	movs	r5, #0
      __HAL_RCC_BACKUPRESET_FORCE();
 8002436:	2601      	movs	r6, #1
 8002438:	600e      	str	r6, [r1, #0]
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800243a:	f422 7040 	bic.w	r0, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_RELEASE();
 800243e:	600d      	str	r5, [r1, #0]
      if(HAL_IS_BIT_SET(tmpreg1, RCC_BDCR_LSERDY))
 8002440:	0795      	lsls	r5, r2, #30
      RCC->BDCR = tmpreg1;
 8002442:	6718      	str	r0, [r3, #112]	; 0x70
      if(HAL_IS_BIT_SET(tmpreg1, RCC_BDCR_LSERDY))
 8002444:	d413      	bmi.n	800246e <HAL_RCCEx_PeriphCLKConfig+0xee>
      __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002446:	68a3      	ldr	r3, [r4, #8]
 8002448:	f403 7240 	and.w	r2, r3, #768	; 0x300
 800244c:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8002450:	d01e      	beq.n	8002490 <HAL_RCCEx_PeriphCLKConfig+0x110>
 8002452:	4a16      	ldr	r2, [pc, #88]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 8002454:	6893      	ldr	r3, [r2, #8]
 8002456:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 800245a:	6093      	str	r3, [r2, #8]
 800245c:	4a13      	ldr	r2, [pc, #76]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 800245e:	68a3      	ldr	r3, [r4, #8]
 8002460:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002462:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002466:	430b      	orrs	r3, r1
 8002468:	6713      	str	r3, [r2, #112]	; 0x70
 800246a:	6820      	ldr	r0, [r4, #0]
 800246c:	e78e      	b.n	800238c <HAL_RCCEx_PeriphCLKConfig+0xc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800246e:	461d      	mov	r5, r3
        tickstart = HAL_GetTick();
 8002470:	f000 fa1e 	bl	80028b0 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002474:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8002478:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800247a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800247c:	0798      	lsls	r0, r3, #30
 800247e:	d4e2      	bmi.n	8002446 <HAL_RCCEx_PeriphCLKConfig+0xc6>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002480:	f000 fa16 	bl	80028b0 <HAL_GetTick>
 8002484:	1bc0      	subs	r0, r0, r7
 8002486:	42b0      	cmp	r0, r6
 8002488:	d9f7      	bls.n	800247a <HAL_RCCEx_PeriphCLKConfig+0xfa>
        return HAL_TIMEOUT;
 800248a:	2003      	movs	r0, #3
}
 800248c:	b003      	add	sp, #12
 800248e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002490:	4906      	ldr	r1, [pc, #24]	; (80024ac <HAL_RCCEx_PeriphCLKConfig+0x12c>)
 8002492:	688a      	ldr	r2, [r1, #8]
 8002494:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8002498:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800249c:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80024a0:	4313      	orrs	r3, r2
 80024a2:	608b      	str	r3, [r1, #8]
 80024a4:	e7da      	b.n	800245c <HAL_RCCEx_PeriphCLKConfig+0xdc>
 80024a6:	bf00      	nop
 80024a8:	424711e0 	.word	0x424711e0
 80024ac:	40023800 	.word	0x40023800
 80024b0:	40007000 	.word	0x40007000
 80024b4:	42470e40 	.word	0x42470e40
	...

080024c0 <HAL_RCC_OscConfig>:
  * @note   This function add the PLL/PLLR factor management during PLL configuration this feature 
  *         is only available in STM32F410xx/STM32F446xx/STM32F469xx/STM32F479xx devices 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80024c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80024c2:	6803      	ldr	r3, [r0, #0]
 80024c4:	07de      	lsls	r6, r3, #31
{
 80024c6:	b083      	sub	sp, #12
 80024c8:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80024ca:	d533      	bpl.n	8002534 <HAL_RCC_OscConfig+0x74>
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 80024cc:	49a2      	ldr	r1, [pc, #648]	; (8002758 <HAL_RCC_OscConfig+0x298>)
 80024ce:	688a      	ldr	r2, [r1, #8]
 80024d0:	f002 020c 	and.w	r2, r2, #12
 80024d4:	2a04      	cmp	r2, #4
 80024d6:	f000 80ef 	beq.w	80026b8 <HAL_RCC_OscConfig+0x1f8>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80024da:	688a      	ldr	r2, [r1, #8]
 80024dc:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)                                                                     ||\
 80024e0:	2a08      	cmp	r2, #8
 80024e2:	f000 80e5 	beq.w	80026b0 <HAL_RCC_OscConfig+0x1f0>
      }
    }
    else
    {
      /* Reset HSEON and HSEBYP bits before configuring the HSE --------------*/
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 80024e6:	4b9d      	ldr	r3, [pc, #628]	; (800275c <HAL_RCC_OscConfig+0x29c>)
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till HSE is disabled */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80024e8:	4d9b      	ldr	r5, [pc, #620]	; (8002758 <HAL_RCC_OscConfig+0x298>)
      __HAL_RCC_HSE_CONFIG(RCC_HSE_OFF);
 80024ea:	2200      	movs	r2, #0
 80024ec:	701a      	strb	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80024ee:	f000 f9df 	bl	80028b0 <HAL_GetTick>
 80024f2:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80024f4:	e005      	b.n	8002502 <HAL_RCC_OscConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80024f6:	f000 f9db 	bl	80028b0 <HAL_GetTick>
 80024fa:	1b80      	subs	r0, r0, r6
 80024fc:	2864      	cmp	r0, #100	; 0x64
 80024fe:	f200 80c6 	bhi.w	800268e <HAL_RCC_OscConfig+0x1ce>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002502:	682b      	ldr	r3, [r5, #0]
 8002504:	0399      	lsls	r1, r3, #14
 8002506:	d4f6      	bmi.n	80024f6 <HAL_RCC_OscConfig+0x36>
          return HAL_TIMEOUT;
        }       
      }
      
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002508:	4b94      	ldr	r3, [pc, #592]	; (800275c <HAL_RCC_OscConfig+0x29c>)
 800250a:	7922      	ldrb	r2, [r4, #4]
 800250c:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800250e:	6863      	ldr	r3, [r4, #4]
 8002510:	2b00      	cmp	r3, #0
 8002512:	f000 810e 	beq.w	8002732 <HAL_RCC_OscConfig+0x272>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002516:	f000 f9cb 	bl	80028b0 <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800251a:	4d8f      	ldr	r5, [pc, #572]	; (8002758 <HAL_RCC_OscConfig+0x298>)
        tickstart = HAL_GetTick();
 800251c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800251e:	e005      	b.n	800252c <HAL_RCC_OscConfig+0x6c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002520:	f000 f9c6 	bl	80028b0 <HAL_GetTick>
 8002524:	1b80      	subs	r0, r0, r6
 8002526:	2864      	cmp	r0, #100	; 0x64
 8002528:	f200 80b1 	bhi.w	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800252c:	682b      	ldr	r3, [r5, #0]
 800252e:	039a      	lsls	r2, r3, #14
 8002530:	d5f6      	bpl.n	8002520 <HAL_RCC_OscConfig+0x60>
 8002532:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002534:	079f      	lsls	r7, r3, #30
 8002536:	d52d      	bpl.n	8002594 <HAL_RCC_OscConfig+0xd4>
#if defined(STM32F446xx)
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLLR) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
#else
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 8002538:	4b87      	ldr	r3, [pc, #540]	; (8002758 <HAL_RCC_OscConfig+0x298>)
 800253a:	689a      	ldr	r2, [r3, #8]
 800253c:	f012 0f0c 	tst.w	r2, #12
 8002540:	f000 80ac 	beq.w	800269c <HAL_RCC_OscConfig+0x1dc>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002544:	689a      	ldr	r2, [r3, #8]
 8002546:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)                                                                     ||\
 800254a:	2a08      	cmp	r2, #8
 800254c:	f000 80a2 	beq.w	8002694 <HAL_RCC_OscConfig+0x1d4>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8002550:	68e3      	ldr	r3, [r4, #12]
 8002552:	2b00      	cmp	r3, #0
 8002554:	f000 80dc 	beq.w	8002710 <HAL_RCC_OscConfig+0x250>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8002558:	4b81      	ldr	r3, [pc, #516]	; (8002760 <HAL_RCC_OscConfig+0x2a0>)

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800255a:	4d7f      	ldr	r5, [pc, #508]	; (8002758 <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_ENABLE();
 800255c:	2201      	movs	r2, #1
 800255e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8002560:	f000 f9a6 	bl	80028b0 <HAL_GetTick>
 8002564:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002566:	e005      	b.n	8002574 <HAL_RCC_OscConfig+0xb4>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002568:	f000 f9a2 	bl	80028b0 <HAL_GetTick>
 800256c:	1b80      	subs	r0, r0, r6
 800256e:	2802      	cmp	r0, #2
 8002570:	f200 808d 	bhi.w	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002574:	682b      	ldr	r3, [r5, #0]
 8002576:	0798      	lsls	r0, r3, #30
 8002578:	d5f6      	bpl.n	8002568 <HAL_RCC_OscConfig+0xa8>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800257a:	6829      	ldr	r1, [r5, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800257c:	22f8      	movs	r2, #248	; 0xf8
 800257e:	fa92 f2a2 	rbit	r2, r2
 8002582:	6923      	ldr	r3, [r4, #16]
 8002584:	fab2 f282 	clz	r2, r2
 8002588:	f021 01f8 	bic.w	r1, r1, #248	; 0xf8
 800258c:	4093      	lsls	r3, r2
 800258e:	430b      	orrs	r3, r1
 8002590:	602b      	str	r3, [r5, #0]
 8002592:	6823      	ldr	r3, [r4, #0]
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002594:	071a      	lsls	r2, r3, #28
 8002596:	d420      	bmi.n	80025da <HAL_RCC_OscConfig+0x11a>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002598:	0758      	lsls	r0, r3, #29
 800259a:	d434      	bmi.n	8002606 <HAL_RCC_OscConfig+0x146>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800259c:	69a3      	ldr	r3, [r4, #24]
 800259e:	b1cb      	cbz	r3, 80025d4 <HAL_RCC_OscConfig+0x114>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80025a0:	4d6d      	ldr	r5, [pc, #436]	; (8002758 <HAL_RCC_OscConfig+0x298>)
 80025a2:	68aa      	ldr	r2, [r5, #8]
 80025a4:	f002 020c 	and.w	r2, r2, #12
 80025a8:	2a08      	cmp	r2, #8
 80025aa:	d07e      	beq.n	80026aa <HAL_RCC_OscConfig+0x1ea>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80025ac:	2b02      	cmp	r3, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80025ae:	4b6d      	ldr	r3, [pc, #436]	; (8002764 <HAL_RCC_OscConfig+0x2a4>)
 80025b0:	f04f 0200 	mov.w	r2, #0
 80025b4:	601a      	str	r2, [r3, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80025b6:	f000 80ca 	beq.w	800274e <HAL_RCC_OscConfig+0x28e>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80025ba:	f000 f979 	bl	80028b0 <HAL_GetTick>
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80025be:	462c      	mov	r4, r5
        tickstart = HAL_GetTick();
 80025c0:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80025c2:	e004      	b.n	80025ce <HAL_RCC_OscConfig+0x10e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80025c4:	f000 f974 	bl	80028b0 <HAL_GetTick>
 80025c8:	1b40      	subs	r0, r0, r5
 80025ca:	2802      	cmp	r0, #2
 80025cc:	d85f      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80025ce:	6823      	ldr	r3, [r4, #0]
 80025d0:	019b      	lsls	r3, r3, #6
 80025d2:	d4f7      	bmi.n	80025c4 <HAL_RCC_OscConfig+0x104>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80025d4:	2000      	movs	r0, #0
}
 80025d6:	b003      	add	sp, #12
 80025d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80025da:	6963      	ldr	r3, [r4, #20]
 80025dc:	2b00      	cmp	r3, #0
 80025de:	d075      	beq.n	80026cc <HAL_RCC_OscConfig+0x20c>
      __HAL_RCC_LSI_ENABLE();
 80025e0:	4b61      	ldr	r3, [pc, #388]	; (8002768 <HAL_RCC_OscConfig+0x2a8>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80025e2:	4d5d      	ldr	r5, [pc, #372]	; (8002758 <HAL_RCC_OscConfig+0x298>)
      __HAL_RCC_LSI_ENABLE();
 80025e4:	2201      	movs	r2, #1
 80025e6:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80025e8:	f000 f962 	bl	80028b0 <HAL_GetTick>
 80025ec:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80025ee:	e004      	b.n	80025fa <HAL_RCC_OscConfig+0x13a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80025f0:	f000 f95e 	bl	80028b0 <HAL_GetTick>
 80025f4:	1b80      	subs	r0, r0, r6
 80025f6:	2802      	cmp	r0, #2
 80025f8:	d849      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80025fa:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80025fc:	079b      	lsls	r3, r3, #30
 80025fe:	d5f7      	bpl.n	80025f0 <HAL_RCC_OscConfig+0x130>
 8002600:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002602:	0758      	lsls	r0, r3, #29
 8002604:	d5ca      	bpl.n	800259c <HAL_RCC_OscConfig+0xdc>
    __HAL_RCC_PWR_CLK_ENABLE();
 8002606:	4b54      	ldr	r3, [pc, #336]	; (8002758 <HAL_RCC_OscConfig+0x298>)
    PWR->CR |= PWR_CR_DBP;
 8002608:	4d58      	ldr	r5, [pc, #352]	; (800276c <HAL_RCC_OscConfig+0x2ac>)
    __HAL_RCC_PWR_CLK_ENABLE();
 800260a:	2200      	movs	r2, #0
 800260c:	9201      	str	r2, [sp, #4]
 800260e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002610:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002614:	641a      	str	r2, [r3, #64]	; 0x40
 8002616:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002618:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800261c:	9301      	str	r3, [sp, #4]
 800261e:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8002620:	682b      	ldr	r3, [r5, #0]
 8002622:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002626:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8002628:	f000 f942 	bl	80028b0 <HAL_GetTick>
 800262c:	4606      	mov	r6, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800262e:	e004      	b.n	800263a <HAL_RCC_OscConfig+0x17a>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002630:	f000 f93e 	bl	80028b0 <HAL_GetTick>
 8002634:	1b80      	subs	r0, r0, r6
 8002636:	2802      	cmp	r0, #2
 8002638:	d829      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800263a:	682b      	ldr	r3, [r5, #0]
 800263c:	05d9      	lsls	r1, r3, #23
 800263e:	d5f7      	bpl.n	8002630 <HAL_RCC_OscConfig+0x170>
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8002640:	4b4b      	ldr	r3, [pc, #300]	; (8002770 <HAL_RCC_OscConfig+0x2b0>)
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002642:	4d45      	ldr	r5, [pc, #276]	; (8002758 <HAL_RCC_OscConfig+0x298>)
    __HAL_RCC_LSE_CONFIG(RCC_LSE_OFF);
 8002644:	2200      	movs	r2, #0
 8002646:	701a      	strb	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002648:	f000 f932 	bl	80028b0 <HAL_GetTick>
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800264c:	f241 3688 	movw	r6, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8002650:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002652:	e004      	b.n	800265e <HAL_RCC_OscConfig+0x19e>
      if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002654:	f000 f92c 	bl	80028b0 <HAL_GetTick>
 8002658:	1bc0      	subs	r0, r0, r7
 800265a:	42b0      	cmp	r0, r6
 800265c:	d817      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800265e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002660:	079a      	lsls	r2, r3, #30
 8002662:	d4f7      	bmi.n	8002654 <HAL_RCC_OscConfig+0x194>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002664:	4b42      	ldr	r3, [pc, #264]	; (8002770 <HAL_RCC_OscConfig+0x2b0>)
 8002666:	7a22      	ldrb	r2, [r4, #8]
 8002668:	701a      	strb	r2, [r3, #0]
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800266a:	68a3      	ldr	r3, [r4, #8]
 800266c:	2b00      	cmp	r3, #0
 800266e:	f000 80c9 	beq.w	8002804 <HAL_RCC_OscConfig+0x344>
      tickstart = HAL_GetTick();
 8002672:	f000 f91d 	bl	80028b0 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002676:	4d38      	ldr	r5, [pc, #224]	; (8002758 <HAL_RCC_OscConfig+0x298>)
      tickstart = HAL_GetTick();
 8002678:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800267a:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800267e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002680:	079b      	lsls	r3, r3, #30
 8002682:	d48b      	bmi.n	800259c <HAL_RCC_OscConfig+0xdc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002684:	f000 f914 	bl	80028b0 <HAL_GetTick>
 8002688:	1bc0      	subs	r0, r0, r7
 800268a:	42b0      	cmp	r0, r6
 800268c:	d9f7      	bls.n	800267e <HAL_RCC_OscConfig+0x1be>
          return HAL_TIMEOUT;
 800268e:	2003      	movs	r0, #3
}
 8002690:	b003      	add	sp, #12
 8002692:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002694:	685b      	ldr	r3, [r3, #4]
 8002696:	025e      	lsls	r6, r3, #9
 8002698:	f53f af5a 	bmi.w	8002550 <HAL_RCC_OscConfig+0x90>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800269c:	4b2e      	ldr	r3, [pc, #184]	; (8002758 <HAL_RCC_OscConfig+0x298>)
 800269e:	681b      	ldr	r3, [r3, #0]
 80026a0:	079d      	lsls	r5, r3, #30
 80026a2:	d523      	bpl.n	80026ec <HAL_RCC_OscConfig+0x22c>
 80026a4:	68e3      	ldr	r3, [r4, #12]
 80026a6:	2b01      	cmp	r3, #1
 80026a8:	d020      	beq.n	80026ec <HAL_RCC_OscConfig+0x22c>
        return HAL_ERROR;
 80026aa:	2001      	movs	r0, #1
}
 80026ac:	b003      	add	sp, #12
 80026ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80026b0:	684a      	ldr	r2, [r1, #4]
 80026b2:	0255      	lsls	r5, r2, #9
 80026b4:	f57f af17 	bpl.w	80024e6 <HAL_RCC_OscConfig+0x26>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80026b8:	4a27      	ldr	r2, [pc, #156]	; (8002758 <HAL_RCC_OscConfig+0x298>)
 80026ba:	6812      	ldr	r2, [r2, #0]
 80026bc:	0390      	lsls	r0, r2, #14
 80026be:	f57f af39 	bpl.w	8002534 <HAL_RCC_OscConfig+0x74>
 80026c2:	6862      	ldr	r2, [r4, #4]
 80026c4:	2a00      	cmp	r2, #0
 80026c6:	f47f af35 	bne.w	8002534 <HAL_RCC_OscConfig+0x74>
 80026ca:	e7ee      	b.n	80026aa <HAL_RCC_OscConfig+0x1ea>
      __HAL_RCC_LSI_DISABLE();
 80026cc:	4a26      	ldr	r2, [pc, #152]	; (8002768 <HAL_RCC_OscConfig+0x2a8>)
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80026ce:	4d22      	ldr	r5, [pc, #136]	; (8002758 <HAL_RCC_OscConfig+0x298>)
      __HAL_RCC_LSI_DISABLE();
 80026d0:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80026d2:	f000 f8ed 	bl	80028b0 <HAL_GetTick>
 80026d6:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80026d8:	e004      	b.n	80026e4 <HAL_RCC_OscConfig+0x224>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80026da:	f000 f8e9 	bl	80028b0 <HAL_GetTick>
 80026de:	1b80      	subs	r0, r0, r6
 80026e0:	2802      	cmp	r0, #2
 80026e2:	d8d4      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80026e4:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80026e6:	079f      	lsls	r7, r3, #30
 80026e8:	d4f7      	bmi.n	80026da <HAL_RCC_OscConfig+0x21a>
 80026ea:	e789      	b.n	8002600 <HAL_RCC_OscConfig+0x140>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80026ec:	481a      	ldr	r0, [pc, #104]	; (8002758 <HAL_RCC_OscConfig+0x298>)
 80026ee:	22f8      	movs	r2, #248	; 0xf8
 80026f0:	6801      	ldr	r1, [r0, #0]
 80026f2:	fa92 f2a2 	rbit	r2, r2
 80026f6:	6923      	ldr	r3, [r4, #16]
 80026f8:	fab2 f282 	clz	r2, r2
 80026fc:	4093      	lsls	r3, r2
 80026fe:	f021 01f8 	bic.w	r1, r1, #248	; 0xf8
 8002702:	430b      	orrs	r3, r1
 8002704:	6003      	str	r3, [r0, #0]
 8002706:	6823      	ldr	r3, [r4, #0]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002708:	071a      	lsls	r2, r3, #28
 800270a:	f57f af45 	bpl.w	8002598 <HAL_RCC_OscConfig+0xd8>
 800270e:	e764      	b.n	80025da <HAL_RCC_OscConfig+0x11a>
        __HAL_RCC_HSI_DISABLE();
 8002710:	4a13      	ldr	r2, [pc, #76]	; (8002760 <HAL_RCC_OscConfig+0x2a0>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002712:	4d11      	ldr	r5, [pc, #68]	; (8002758 <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_DISABLE();
 8002714:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8002716:	f000 f8cb 	bl	80028b0 <HAL_GetTick>
 800271a:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800271c:	e004      	b.n	8002728 <HAL_RCC_OscConfig+0x268>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800271e:	f000 f8c7 	bl	80028b0 <HAL_GetTick>
 8002722:	1b80      	subs	r0, r0, r6
 8002724:	2802      	cmp	r0, #2
 8002726:	d8b2      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002728:	682b      	ldr	r3, [r5, #0]
 800272a:	0799      	lsls	r1, r3, #30
 800272c:	d4f7      	bmi.n	800271e <HAL_RCC_OscConfig+0x25e>
 800272e:	6823      	ldr	r3, [r4, #0]
 8002730:	e730      	b.n	8002594 <HAL_RCC_OscConfig+0xd4>
        tickstart = HAL_GetTick();
 8002732:	f000 f8bd 	bl	80028b0 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002736:	4d08      	ldr	r5, [pc, #32]	; (8002758 <HAL_RCC_OscConfig+0x298>)
        tickstart = HAL_GetTick();
 8002738:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800273a:	e004      	b.n	8002746 <HAL_RCC_OscConfig+0x286>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800273c:	f000 f8b8 	bl	80028b0 <HAL_GetTick>
 8002740:	1b80      	subs	r0, r0, r6
 8002742:	2864      	cmp	r0, #100	; 0x64
 8002744:	d8a3      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002746:	682b      	ldr	r3, [r5, #0]
 8002748:	039b      	lsls	r3, r3, #14
 800274a:	d4f7      	bmi.n	800273c <HAL_RCC_OscConfig+0x27c>
 800274c:	e6f1      	b.n	8002532 <HAL_RCC_OscConfig+0x72>
        tickstart = HAL_GetTick();
 800274e:	f000 f8af 	bl	80028b0 <HAL_GetTick>
 8002752:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002754:	e013      	b.n	800277e <HAL_RCC_OscConfig+0x2be>
 8002756:	bf00      	nop
 8002758:	40023800 	.word	0x40023800
 800275c:	40023802 	.word	0x40023802
 8002760:	42470000 	.word	0x42470000
 8002764:	42470060 	.word	0x42470060
 8002768:	42470e80 	.word	0x42470e80
 800276c:	40007000 	.word	0x40007000
 8002770:	40023870 	.word	0x40023870
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002774:	f000 f89c 	bl	80028b0 <HAL_GetTick>
 8002778:	1b80      	subs	r0, r0, r6
 800277a:	2802      	cmp	r0, #2
 800277c:	d887      	bhi.n	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800277e:	682b      	ldr	r3, [r5, #0]
 8002780:	0199      	lsls	r1, r3, #6
 8002782:	d4f7      	bmi.n	8002774 <HAL_RCC_OscConfig+0x2b4>
 8002784:	f647 7cc0 	movw	ip, #32704	; 0x7fc0
 8002788:	fa9c fcac 	rbit	ip, ip
 800278c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002790:	fabc fc8c 	clz	ip, ip
 8002794:	fa92 f2a2 	rbit	r2, r2
 8002798:	f04f 6770 	mov.w	r7, #251658240	; 0xf000000
 800279c:	fab2 fe82 	clz	lr, r2
 80027a0:	fa97 f7a7 	rbit	r7, r7
 80027a4:	f04f 41e0 	mov.w	r1, #1879048192	; 0x70000000
 80027a8:	fab7 f787 	clz	r7, r7
 80027ac:	fa91 f1a1 	rbit	r1, r1
 80027b0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80027b2:	6a26      	ldr	r6, [r4, #32]
 80027b4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80027b6:	69e3      	ldr	r3, [r4, #28]
 80027b8:	0852      	lsrs	r2, r2, #1
 80027ba:	fa00 f00c 	lsl.w	r0, r0, ip
 80027be:	4333      	orrs	r3, r6
 80027c0:	3a01      	subs	r2, #1
 80027c2:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 80027c4:	6b24      	ldr	r4, [r4, #48]	; 0x30
 80027c6:	fa02 f20e 	lsl.w	r2, r2, lr
 80027ca:	4303      	orrs	r3, r0
 80027cc:	fab1 f181 	clz	r1, r1
 80027d0:	4313      	orrs	r3, r2
 80027d2:	fa06 f707 	lsl.w	r7, r6, r7
 80027d6:	fa04 f201 	lsl.w	r2, r4, r1
 80027da:	433b      	orrs	r3, r7
        __HAL_RCC_PLL_ENABLE();
 80027dc:	4911      	ldr	r1, [pc, #68]	; (8002824 <HAL_RCC_OscConfig+0x364>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80027de:	4c12      	ldr	r4, [pc, #72]	; (8002828 <HAL_RCC_OscConfig+0x368>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80027e0:	4313      	orrs	r3, r2
        __HAL_RCC_PLL_ENABLE();
 80027e2:	2201      	movs	r2, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80027e4:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 80027e6:	600a      	str	r2, [r1, #0]
        tickstart = HAL_GetTick();
 80027e8:	f000 f862 	bl	80028b0 <HAL_GetTick>
 80027ec:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80027ee:	e005      	b.n	80027fc <HAL_RCC_OscConfig+0x33c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80027f0:	f000 f85e 	bl	80028b0 <HAL_GetTick>
 80027f4:	1b40      	subs	r0, r0, r5
 80027f6:	2802      	cmp	r0, #2
 80027f8:	f63f af49 	bhi.w	800268e <HAL_RCC_OscConfig+0x1ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80027fc:	6823      	ldr	r3, [r4, #0]
 80027fe:	019a      	lsls	r2, r3, #6
 8002800:	d5f6      	bpl.n	80027f0 <HAL_RCC_OscConfig+0x330>
 8002802:	e6e7      	b.n	80025d4 <HAL_RCC_OscConfig+0x114>
      tickstart = HAL_GetTick();
 8002804:	f000 f854 	bl	80028b0 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002808:	4d07      	ldr	r5, [pc, #28]	; (8002828 <HAL_RCC_OscConfig+0x368>)
      tickstart = HAL_GetTick();
 800280a:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800280c:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002810:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002812:	0798      	lsls	r0, r3, #30
 8002814:	f57f aec2 	bpl.w	800259c <HAL_RCC_OscConfig+0xdc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002818:	f000 f84a 	bl	80028b0 <HAL_GetTick>
 800281c:	1bc0      	subs	r0, r0, r7
 800281e:	42b0      	cmp	r0, r6
 8002820:	d9f6      	bls.n	8002810 <HAL_RCC_OscConfig+0x350>
 8002822:	e734      	b.n	800268e <HAL_RCC_OscConfig+0x1ce>
 8002824:	42470060 	.word	0x42470060
 8002828:	40023800 	.word	0x40023800
 800282c:	00000000 	.word	0x00000000

08002830 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8002830:	b510      	push	{r4, lr}
 8002832:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 8002834:	f000 ff64 	bl	8003700 <HAL_RCC_GetHCLKFreq>
 8002838:	4b06      	ldr	r3, [pc, #24]	; (8002854 <HAL_InitTick+0x24>)
 800283a:	fba3 3000 	umull	r3, r0, r3, r0
 800283e:	0980      	lsrs	r0, r0, #6
 8002840:	f000 fb26 	bl	8002e90 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8002844:	4621      	mov	r1, r4
 8002846:	2200      	movs	r2, #0
 8002848:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800284c:	f000 fad8 	bl	8002e00 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8002850:	2000      	movs	r0, #0
 8002852:	bd10      	pop	{r4, pc}
 8002854:	10624dd3 	.word	0x10624dd3
	...

08002860 <HAL_Init>:
{
 8002860:	b508      	push	{r3, lr}
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8002862:	4b0b      	ldr	r3, [pc, #44]	; (8002890 <HAL_Init+0x30>)
 8002864:	681a      	ldr	r2, [r3, #0]
 8002866:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800286a:	601a      	str	r2, [r3, #0]
   __HAL_FLASH_DATA_CACHE_ENABLE();
 800286c:	681a      	ldr	r2, [r3, #0]
 800286e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8002872:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8002874:	681a      	ldr	r2, [r3, #0]
 8002876:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800287a:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800287c:	2003      	movs	r0, #3
 800287e:	f000 faa7 	bl	8002dd0 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8002882:	2002      	movs	r0, #2
 8002884:	f7ff ffd4 	bl	8002830 <HAL_InitTick>
  HAL_MspInit();
 8002888:	f7ff fa6a 	bl	8001d60 <HAL_MspInit>
}
 800288c:	2000      	movs	r0, #0
 800288e:	bd08      	pop	{r3, pc}
 8002890:	40023c00 	.word	0x40023c00
	...

080028a0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80028a0:	4a02      	ldr	r2, [pc, #8]	; (80028ac <HAL_IncTick+0xc>)
 80028a2:	6813      	ldr	r3, [r2, #0]
 80028a4:	3301      	adds	r3, #1
 80028a6:	6013      	str	r3, [r2, #0]
 80028a8:	4770      	bx	lr
 80028aa:	bf00      	nop
 80028ac:	200012d8 	.word	0x200012d8

080028b0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80028b0:	4b01      	ldr	r3, [pc, #4]	; (80028b8 <HAL_GetTick+0x8>)
 80028b2:	6818      	ldr	r0, [r3, #0]
}
 80028b4:	4770      	bx	lr
 80028b6:	bf00      	nop
 80028b8:	200012d8 	.word	0x200012d8
 80028bc:	00000000 	.word	0x00000000

080028c0 <UART_SetConfig>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80028c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 80028c4:	6802      	ldr	r2, [r0, #0]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80028c6:	68c1      	ldr	r1, [r0, #12]
  tmpreg = huart->Instance->CR2;
 80028c8:	6913      	ldr	r3, [r2, #16]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80028ca:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80028ce:	430b      	orrs	r3, r1
  
  /* Write to USART CR2 */
  huart->Instance->CR2 = (uint32_t)tmpreg;
 80028d0:	6113      	str	r3, [r2, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 80028d2:	6801      	ldr	r1, [r0, #0]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80028d4:	6883      	ldr	r3, [r0, #8]
 80028d6:	6906      	ldr	r6, [r0, #16]
  tmpreg = huart->Instance->CR1;
 80028d8:	68ca      	ldr	r2, [r1, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80028da:	6945      	ldr	r5, [r0, #20]
{
 80028dc:	4604      	mov	r4, r0
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80028de:	4333      	orrs	r3, r6
 80028e0:	69c0      	ldr	r0, [r0, #28]
 80028e2:	432b      	orrs	r3, r5
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80028e4:	f422 4216 	bic.w	r2, r2, #38400	; 0x9600
 80028e8:	f022 020c 	bic.w	r2, r2, #12
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80028ec:	4303      	orrs	r3, r0
 80028ee:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  huart->Instance->CR1 = (uint32_t)tmpreg;
 80028f0:	60cb      	str	r3, [r1, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 80028f2:	6822      	ldr	r2, [r4, #0]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 80028f4:	69a1      	ldr	r1, [r4, #24]
  tmpreg = huart->Instance->CR3;
 80028f6:	6953      	ldr	r3, [r2, #20]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 80028f8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tmpreg |= huart->Init.HwFlowCtl;
 80028fc:	430b      	orrs	r3, r1
  
  /* Write to USART CR3 */
  huart->Instance->CR3 = (uint32_t)tmpreg;
 80028fe:	6153      	str	r3, [r2, #20]
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002900:	69e3      	ldr	r3, [r4, #28]
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8002902:	6825      	ldr	r5, [r4, #0]
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002904:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8002908:	d05e      	beq.n	80029c8 <UART_SetConfig+0x108>
    }
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 800290a:	4ba5      	ldr	r3, [pc, #660]	; (8002ba0 <UART_SetConfig+0x2e0>)
 800290c:	429d      	cmp	r5, r3
 800290e:	f000 80fa 	beq.w	8002b06 <UART_SetConfig+0x246>
 8002912:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002916:	429d      	cmp	r5, r3
 8002918:	f000 80f5 	beq.w	8002b06 <UART_SetConfig+0x246>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800291c:	f000 ff10 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002920:	f8df 8280 	ldr.w	r8, [pc, #640]	; 8002ba4 <UART_SetConfig+0x2e4>
 8002924:	6863      	ldr	r3, [r4, #4]
 8002926:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800292a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800292e:	009b      	lsls	r3, r3, #2
 8002930:	fbb0 f3f3 	udiv	r3, r0, r3
 8002934:	fba8 2303 	umull	r2, r3, r8, r3
 8002938:	095b      	lsrs	r3, r3, #5
 800293a:	011e      	lsls	r6, r3, #4
 800293c:	f000 ff00 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002940:	6863      	ldr	r3, [r4, #4]
 8002942:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002946:	009b      	lsls	r3, r3, #2
 8002948:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800294c:	fbb0 f7f3 	udiv	r7, r0, r3
 8002950:	f000 fef6 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002954:	6862      	ldr	r2, [r4, #4]
 8002956:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800295a:	0093      	lsls	r3, r2, #2
 800295c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002960:	fbb0 f3f3 	udiv	r3, r0, r3
 8002964:	fba8 2303 	umull	r2, r3, r8, r3
 8002968:	f04f 0a64 	mov.w	sl, #100	; 0x64
 800296c:	095b      	lsrs	r3, r3, #5
 800296e:	fb0a 7313 	mls	r3, sl, r3, r7
 8002972:	011b      	lsls	r3, r3, #4
 8002974:	3332      	adds	r3, #50	; 0x32
 8002976:	fba8 2303 	umull	r2, r3, r8, r3
 800297a:	095b      	lsrs	r3, r3, #5
 800297c:	f003 07f0 	and.w	r7, r3, #240	; 0xf0
 8002980:	f000 fede 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002984:	6862      	ldr	r2, [r4, #4]
 8002986:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800298a:	0093      	lsls	r3, r2, #2
 800298c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002990:	fbb0 f9f3 	udiv	r9, r0, r3
 8002994:	f000 fed4 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002998:	6863      	ldr	r3, [r4, #4]
 800299a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800299e:	009b      	lsls	r3, r3, #2
 80029a0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80029a4:	fbb0 f0f3 	udiv	r0, r0, r3
 80029a8:	fba8 3000 	umull	r3, r0, r8, r0
 80029ac:	0940      	lsrs	r0, r0, #5
 80029ae:	fb0a 9310 	mls	r3, sl, r0, r9
 80029b2:	011b      	lsls	r3, r3, #4
 80029b4:	3332      	adds	r3, #50	; 0x32
 80029b6:	fba8 2303 	umull	r2, r3, r8, r3
 80029ba:	f3c3 1343 	ubfx	r3, r3, #5, #4
 80029be:	433b      	orrs	r3, r7
 80029c0:	4433      	add	r3, r6
 80029c2:	60ab      	str	r3, [r5, #8]
 80029c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 80029c8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80029cc:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
 80029d0:	429d      	cmp	r5, r3
 80029d2:	d059      	beq.n	8002a88 <UART_SetConfig+0x1c8>
 80029d4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80029d8:	429d      	cmp	r5, r3
 80029da:	d055      	beq.n	8002a88 <UART_SetConfig+0x1c8>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 80029dc:	f000 feb0 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 80029e0:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8002ba4 <UART_SetConfig+0x2e4>
 80029e4:	6863      	ldr	r3, [r4, #4]
 80029e6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80029ea:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80029ee:	005b      	lsls	r3, r3, #1
 80029f0:	fbb0 f3f3 	udiv	r3, r0, r3
 80029f4:	fba8 2303 	umull	r2, r3, r8, r3
 80029f8:	095b      	lsrs	r3, r3, #5
 80029fa:	011f      	lsls	r7, r3, #4
 80029fc:	f000 fea0 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002a00:	6863      	ldr	r3, [r4, #4]
 8002a02:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a06:	005b      	lsls	r3, r3, #1
 8002a08:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a0c:	fbb0 f6f3 	udiv	r6, r0, r3
 8002a10:	f000 fe96 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002a14:	6862      	ldr	r2, [r4, #4]
 8002a16:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a1a:	0053      	lsls	r3, r2, #1
 8002a1c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a20:	fbb0 f3f3 	udiv	r3, r0, r3
 8002a24:	fba8 2303 	umull	r2, r3, r8, r3
 8002a28:	095b      	lsrs	r3, r3, #5
 8002a2a:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8002a2e:	fb0a 6313 	mls	r3, sl, r3, r6
 8002a32:	00db      	lsls	r3, r3, #3
 8002a34:	3332      	adds	r3, #50	; 0x32
 8002a36:	fba8 2303 	umull	r2, r3, r8, r3
 8002a3a:	091b      	lsrs	r3, r3, #4
 8002a3c:	f403 76f8 	and.w	r6, r3, #496	; 0x1f0
 8002a40:	f000 fe7e 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002a44:	6862      	ldr	r2, [r4, #4]
 8002a46:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a4a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a4e:	0053      	lsls	r3, r2, #1
 8002a50:	fbb0 f9f3 	udiv	r9, r0, r3
 8002a54:	f000 fe74 	bl	8003740 <HAL_RCC_GetPCLK1Freq>
 8002a58:	6863      	ldr	r3, [r4, #4]
 8002a5a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a5e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a62:	005b      	lsls	r3, r3, #1
 8002a64:	fbb0 f3f3 	udiv	r3, r0, r3
 8002a68:	fba8 2303 	umull	r2, r3, r8, r3
 8002a6c:	095b      	lsrs	r3, r3, #5
 8002a6e:	fb0a 9313 	mls	r3, sl, r3, r9
 8002a72:	00db      	lsls	r3, r3, #3
 8002a74:	3332      	adds	r3, #50	; 0x32
 8002a76:	fba8 2303 	umull	r2, r3, r8, r3
 8002a7a:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8002a7e:	443b      	add	r3, r7
 8002a80:	4433      	add	r3, r6
 8002a82:	60ab      	str	r3, [r5, #8]
 8002a84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002a88:	f000 fe82 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002a8c:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8002ba4 <UART_SetConfig+0x2e4>
 8002a90:	6863      	ldr	r3, [r4, #4]
 8002a92:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a96:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002a9a:	005b      	lsls	r3, r3, #1
 8002a9c:	fbb0 f3f3 	udiv	r3, r0, r3
 8002aa0:	fba8 2303 	umull	r2, r3, r8, r3
 8002aa4:	095b      	lsrs	r3, r3, #5
 8002aa6:	011f      	lsls	r7, r3, #4
 8002aa8:	f000 fe72 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002aac:	6863      	ldr	r3, [r4, #4]
 8002aae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002ab2:	005b      	lsls	r3, r3, #1
 8002ab4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002ab8:	fbb0 f6f3 	udiv	r6, r0, r3
 8002abc:	f000 fe68 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002ac0:	6862      	ldr	r2, [r4, #4]
 8002ac2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002ac6:	0053      	lsls	r3, r2, #1
 8002ac8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002acc:	fbb0 f3f3 	udiv	r3, r0, r3
 8002ad0:	fba8 2303 	umull	r2, r3, r8, r3
 8002ad4:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8002ad8:	095b      	lsrs	r3, r3, #5
 8002ada:	fb0a 6313 	mls	r3, sl, r3, r6
 8002ade:	00db      	lsls	r3, r3, #3
 8002ae0:	3332      	adds	r3, #50	; 0x32
 8002ae2:	fba8 2303 	umull	r2, r3, r8, r3
 8002ae6:	091b      	lsrs	r3, r3, #4
 8002ae8:	f403 76f8 	and.w	r6, r3, #496	; 0x1f0
 8002aec:	f000 fe50 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002af0:	6862      	ldr	r2, [r4, #4]
 8002af2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002af6:	0053      	lsls	r3, r2, #1
 8002af8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002afc:	fbb0 f9f3 	udiv	r9, r0, r3
 8002b00:	f000 fe46 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002b04:	e7a8      	b.n	8002a58 <UART_SetConfig+0x198>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8002b06:	f000 fe43 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002b0a:	f8df 8098 	ldr.w	r8, [pc, #152]	; 8002ba4 <UART_SetConfig+0x2e4>
 8002b0e:	6863      	ldr	r3, [r4, #4]
 8002b10:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b14:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b18:	009b      	lsls	r3, r3, #2
 8002b1a:	fbb0 f3f3 	udiv	r3, r0, r3
 8002b1e:	fba8 2303 	umull	r2, r3, r8, r3
 8002b22:	095b      	lsrs	r3, r3, #5
 8002b24:	011e      	lsls	r6, r3, #4
 8002b26:	f000 fe33 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002b2a:	6863      	ldr	r3, [r4, #4]
 8002b2c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b30:	009b      	lsls	r3, r3, #2
 8002b32:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b36:	fbb0 f7f3 	udiv	r7, r0, r3
 8002b3a:	f000 fe29 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002b3e:	6862      	ldr	r2, [r4, #4]
 8002b40:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b44:	0093      	lsls	r3, r2, #2
 8002b46:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b4a:	fbb0 f3f3 	udiv	r3, r0, r3
 8002b4e:	fba8 2303 	umull	r2, r3, r8, r3
 8002b52:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8002b56:	095b      	lsrs	r3, r3, #5
 8002b58:	fb0a 7313 	mls	r3, sl, r3, r7
 8002b5c:	011b      	lsls	r3, r3, #4
 8002b5e:	3332      	adds	r3, #50	; 0x32
 8002b60:	fba8 2303 	umull	r2, r3, r8, r3
 8002b64:	095b      	lsrs	r3, r3, #5
 8002b66:	f003 07f0 	and.w	r7, r3, #240	; 0xf0
 8002b6a:	f000 fe11 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002b6e:	6862      	ldr	r2, [r4, #4]
 8002b70:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b74:	0093      	lsls	r3, r2, #2
 8002b76:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b7a:	fbb0 f9f3 	udiv	r9, r0, r3
 8002b7e:	f000 fe07 	bl	8003790 <HAL_RCC_GetPCLK2Freq>
 8002b82:	6863      	ldr	r3, [r4, #4]
 8002b84:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b88:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002b8c:	009b      	lsls	r3, r3, #2
 8002b8e:	fbb0 f3f3 	udiv	r3, r0, r3
 8002b92:	fba8 2303 	umull	r2, r3, r8, r3
 8002b96:	095b      	lsrs	r3, r3, #5
 8002b98:	fb0a 9313 	mls	r3, sl, r3, r9
 8002b9c:	e709      	b.n	80029b2 <UART_SetConfig+0xf2>
 8002b9e:	bf00      	nop
 8002ba0:	40011000 	.word	0x40011000
 8002ba4:	51eb851f 	.word	0x51eb851f
	...

08002bb0 <HAL_UART_Init>:
  if(huart == NULL)
 8002bb0:	b370      	cbz	r0, 8002c10 <HAL_UART_Init+0x60>
{
 8002bb2:	b510      	push	{r4, lr}
  if(huart->gState == HAL_UART_STATE_RESET)
 8002bb4:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002bb8:	4604      	mov	r4, r0
 8002bba:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002bbe:	b313      	cbz	r3, 8002c06 <HAL_UART_Init+0x56>
  __HAL_UART_DISABLE(huart);
 8002bc0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8002bc2:	2324      	movs	r3, #36	; 0x24
 8002bc4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 8002bc8:	68d3      	ldr	r3, [r2, #12]
 8002bca:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002bce:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8002bd0:	4620      	mov	r0, r4
 8002bd2:	f7ff fe75 	bl	80028c0 <UART_SetConfig>
  huart->Instance->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
 8002bd6:	6822      	ldr	r2, [r4, #0]
 8002bd8:	6913      	ldr	r3, [r2, #16]
 8002bda:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8002bde:	6113      	str	r3, [r2, #16]
  huart->Instance->CR3 &= ~(USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN);
 8002be0:	6822      	ldr	r2, [r4, #0]
 8002be2:	6953      	ldr	r3, [r2, #20]
 8002be4:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8002be8:	6153      	str	r3, [r2, #20]
  __HAL_UART_ENABLE(huart);
 8002bea:	6820      	ldr	r0, [r4, #0]
 8002bec:	68c3      	ldr	r3, [r0, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002bee:	2100      	movs	r1, #0
  huart->gState= HAL_UART_STATE_READY;
 8002bf0:	2220      	movs	r2, #32
  __HAL_UART_ENABLE(huart);
 8002bf2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002bf6:	60c3      	str	r3, [r0, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002bf8:	63e1      	str	r1, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8002bfa:	f884 2039 	strb.w	r2, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8002bfe:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a
  return HAL_OK;
 8002c02:	4608      	mov	r0, r1
 8002c04:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 8002c06:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 8002c0a:	f7ff f961 	bl	8001ed0 <HAL_UART_MspInit>
 8002c0e:	e7d7      	b.n	8002bc0 <HAL_UART_Init+0x10>
    return HAL_ERROR;
 8002c10:	2001      	movs	r0, #1
 8002c12:	4770      	bx	lr
	...

08002c20 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002c20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8002c24:	f04f 0c01 	mov.w	ip, #1
{
 8002c28:	b082      	sub	sp, #8
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002c2a:	2600      	movs	r6, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002c2c:	f8df e18c 	ldr.w	lr, [pc, #396]	; 8002dbc <HAL_GPIO_Init+0x19c>
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002c30:	4f5e      	ldr	r7, [pc, #376]	; (8002dac <HAL_GPIO_Init+0x18c>)
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002c32:	f04f 0903 	mov.w	r9, #3
 8002c36:	e003      	b.n	8002c40 <HAL_GPIO_Init+0x20>
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002c38:	3601      	adds	r6, #1
 8002c3a:	2e10      	cmp	r6, #16
 8002c3c:	f000 80a9 	beq.w	8002d92 <HAL_GPIO_Init+0x172>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002c40:	680b      	ldr	r3, [r1, #0]
    ioposition = ((uint32_t)0x01U) << position;
 8002c42:	fa0c f206 	lsl.w	r2, ip, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002c46:	4013      	ands	r3, r2
    if(iocurrent == ioposition)
 8002c48:	429a      	cmp	r2, r3
 8002c4a:	d1f5      	bne.n	8002c38 <HAL_GPIO_Init+0x18>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002c4c:	684c      	ldr	r4, [r1, #4]
 8002c4e:	f024 0510 	bic.w	r5, r4, #16
 8002c52:	2d02      	cmp	r5, #2
 8002c54:	d115      	bne.n	8002c82 <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3U];
 8002c56:	ea4f 08d6 	mov.w	r8, r6, lsr #3
 8002c5a:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8002c5e:	f006 0507 	and.w	r5, r6, #7
        temp = GPIOx->AFR[position >> 3U];
 8002c62:	f8d8 4020 	ldr.w	r4, [r8, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8002c66:	00ad      	lsls	r5, r5, #2
 8002c68:	f04f 0a0f 	mov.w	sl, #15
 8002c6c:	fa0a fa05 	lsl.w	sl, sl, r5
 8002c70:	ea24 0a0a 	bic.w	sl, r4, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8002c74:	690c      	ldr	r4, [r1, #16]
 8002c76:	40ac      	lsls	r4, r5
 8002c78:	ea44 040a 	orr.w	r4, r4, sl
        GPIOx->AFR[position >> 3U] = temp;
 8002c7c:	f8c8 4020 	str.w	r4, [r8, #32]
 8002c80:	684c      	ldr	r4, [r1, #4]
      temp = GPIOx->MODER;
 8002c82:	f8d0 a000 	ldr.w	sl, [r0]
 8002c86:	0075      	lsls	r5, r6, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002c88:	fa09 f805 	lsl.w	r8, r9, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002c8c:	f004 0403 	and.w	r4, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002c90:	ea6f 0808 	mvn.w	r8, r8
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002c94:	40ac      	lsls	r4, r5
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002c96:	ea0a 0a08 	and.w	sl, sl, r8
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002c9a:	ea44 040a 	orr.w	r4, r4, sl
      GPIOx->MODER = temp;
 8002c9e:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002ca0:	684c      	ldr	r4, [r1, #4]
 8002ca2:	f024 0410 	bic.w	r4, r4, #16
 8002ca6:	3c01      	subs	r4, #1
 8002ca8:	2c01      	cmp	r4, #1
 8002caa:	d811      	bhi.n	8002cd0 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR; 
 8002cac:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002cae:	ea08 0a04 	and.w	sl, r8, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002cb2:	68cc      	ldr	r4, [r1, #12]
 8002cb4:	40ac      	lsls	r4, r5
 8002cb6:	ea44 040a 	orr.w	r4, r4, sl
        GPIOx->OSPEEDR = temp;
 8002cba:	6084      	str	r4, [r0, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8002cbc:	684c      	ldr	r4, [r1, #4]
        temp = GPIOx->OTYPER;
 8002cbe:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8002cc2:	f3c4 1400 	ubfx	r4, r4, #4, #1
 8002cc6:	40b4      	lsls	r4, r6
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002cc8:	ea2a 0202 	bic.w	r2, sl, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8002ccc:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 8002cce:	6042      	str	r2, [r0, #4]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002cd0:	688a      	ldr	r2, [r1, #8]
      temp = GPIOx->PUPDR;
 8002cd2:	68c4      	ldr	r4, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002cd4:	fa02 f505 	lsl.w	r5, r2, r5
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8002cd8:	ea08 0804 	and.w	r8, r8, r4
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002cdc:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
 8002ce0:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8002ce2:	684a      	ldr	r2, [r1, #4]
 8002ce4:	00d2      	lsls	r2, r2, #3
 8002ce6:	d5a7      	bpl.n	8002c38 <HAL_GPIO_Init+0x18>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002ce8:	2200      	movs	r2, #0
 8002cea:	9201      	str	r2, [sp, #4]
 8002cec:	f8de 2044 	ldr.w	r2, [lr, #68]	; 0x44
 8002cf0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002cf4:	f8ce 2044 	str.w	r2, [lr, #68]	; 0x44
 8002cf8:	f8de 2044 	ldr.w	r2, [lr, #68]	; 0x44
 8002cfc:	f026 0503 	bic.w	r5, r6, #3
 8002d00:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 8002d04:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8002d08:	f505 359c 	add.w	r5, r5, #79872	; 0x13800
 8002d0c:	9201      	str	r2, [sp, #4]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8002d0e:	f006 0203 	and.w	r2, r6, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002d12:	9c01      	ldr	r4, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8002d14:	f8d5 8008 	ldr.w	r8, [r5, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8002d18:	0092      	lsls	r2, r2, #2
 8002d1a:	240f      	movs	r4, #15
 8002d1c:	4094      	lsls	r4, r2
 8002d1e:	ea28 0a04 	bic.w	sl, r8, r4
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002d22:	4c23      	ldr	r4, [pc, #140]	; (8002db0 <HAL_GPIO_Init+0x190>)
 8002d24:	42a0      	cmp	r0, r4
 8002d26:	d037      	beq.n	8002d98 <HAL_GPIO_Init+0x178>
 8002d28:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002d2c:	42a0      	cmp	r0, r4
 8002d2e:	d035      	beq.n	8002d9c <HAL_GPIO_Init+0x17c>
 8002d30:	4c20      	ldr	r4, [pc, #128]	; (8002db4 <HAL_GPIO_Init+0x194>)
 8002d32:	42a0      	cmp	r0, r4
 8002d34:	d035      	beq.n	8002da2 <HAL_GPIO_Init+0x182>
 8002d36:	4c20      	ldr	r4, [pc, #128]	; (8002db8 <HAL_GPIO_Init+0x198>)
 8002d38:	42a0      	cmp	r0, r4
 8002d3a:	bf0c      	ite	eq
 8002d3c:	f04f 0807 	moveq.w	r8, #7
 8002d40:	f04f 0808 	movne.w	r8, #8
 8002d44:	fa08 f202 	lsl.w	r2, r8, r2
 8002d48:	ea42 020a 	orr.w	r2, r2, sl
        SYSCFG->EXTICR[position >> 2U] = temp;
 8002d4c:	60aa      	str	r2, [r5, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002d4e:	684d      	ldr	r5, [r1, #4]
        temp = EXTI->IMR;
 8002d50:	683a      	ldr	r2, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8002d52:	43dc      	mvns	r4, r3
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002d54:	03ed      	lsls	r5, r5, #15
        temp &= ~((uint32_t)iocurrent);
 8002d56:	bf54      	ite	pl
 8002d58:	4022      	andpl	r2, r4
        {
          temp |= iocurrent;
 8002d5a:	431a      	orrmi	r2, r3
        }
        EXTI->IMR = temp;
 8002d5c:	603a      	str	r2, [r7, #0]

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002d5e:	684d      	ldr	r5, [r1, #4]
        temp = EXTI->EMR;
 8002d60:	687a      	ldr	r2, [r7, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002d62:	03ad      	lsls	r5, r5, #14
        temp &= ~((uint32_t)iocurrent);
 8002d64:	bf54      	ite	pl
 8002d66:	4022      	andpl	r2, r4
        {
          temp |= iocurrent;
 8002d68:	431a      	orrmi	r2, r3
        }
        EXTI->EMR = temp;
 8002d6a:	607a      	str	r2, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002d6c:	684d      	ldr	r5, [r1, #4]
        temp = EXTI->RTSR;
 8002d6e:	68ba      	ldr	r2, [r7, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002d70:	02ed      	lsls	r5, r5, #11
        temp &= ~((uint32_t)iocurrent);
 8002d72:	bf54      	ite	pl
 8002d74:	4022      	andpl	r2, r4
        {
          temp |= iocurrent;
 8002d76:	431a      	orrmi	r2, r3
        }
        EXTI->RTSR = temp;
 8002d78:	60ba      	str	r2, [r7, #8]

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002d7a:	684d      	ldr	r5, [r1, #4]
        temp = EXTI->FTSR;
 8002d7c:	68fa      	ldr	r2, [r7, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002d7e:	02ad      	lsls	r5, r5, #10
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002d80:	f106 0601 	add.w	r6, r6, #1
        temp &= ~((uint32_t)iocurrent);
 8002d84:	bf54      	ite	pl
 8002d86:	4022      	andpl	r2, r4
        {
          temp |= iocurrent;
 8002d88:	431a      	orrmi	r2, r3
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002d8a:	2e10      	cmp	r6, #16
        }
        EXTI->FTSR = temp;
 8002d8c:	60fa      	str	r2, [r7, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002d8e:	f47f af57 	bne.w	8002c40 <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 8002d92:	b002      	add	sp, #8
 8002d94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002d98:	2200      	movs	r2, #0
 8002d9a:	e7d5      	b.n	8002d48 <HAL_GPIO_Init+0x128>
 8002d9c:	fa0c f202 	lsl.w	r2, ip, r2
 8002da0:	e7d2      	b.n	8002d48 <HAL_GPIO_Init+0x128>
 8002da2:	f04f 0802 	mov.w	r8, #2
 8002da6:	fa08 f202 	lsl.w	r2, r8, r2
 8002daa:	e7cd      	b.n	8002d48 <HAL_GPIO_Init+0x128>
 8002dac:	40013c00 	.word	0x40013c00
 8002db0:	40020000 	.word	0x40020000
 8002db4:	40020800 	.word	0x40020800
 8002db8:	40021c00 	.word	0x40021c00
 8002dbc:	40023800 	.word	0x40023800

08002dc0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002dc0:	b902      	cbnz	r2, 8002dc4 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8002dc2:	0409      	lsls	r1, r1, #16
 8002dc4:	6181      	str	r1, [r0, #24]
 8002dc6:	4770      	bx	lr
	...

08002dd0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002dd0:	4a07      	ldr	r2, [pc, #28]	; (8002df0 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8002dd2:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002dd4:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8002dd8:	400b      	ands	r3, r1
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8002dda:	0200      	lsls	r0, r0, #8
 8002ddc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8002de0:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8002de4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8002de8:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8002dea:	60d3      	str	r3, [r2, #12]
 8002dec:	4770      	bx	lr
 8002dee:	bf00      	nop
 8002df0:	e000ed00 	.word	0xe000ed00
	...

08002e00 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002e00:	b470      	push	{r4, r5, r6}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002e02:	4b18      	ldr	r3, [pc, #96]	; (8002e64 <HAL_NVIC_SetPriority+0x64>)
 8002e04:	68dc      	ldr	r4, [r3, #12]
 8002e06:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002e0a:	f1c4 0607 	rsb	r6, r4, #7
 8002e0e:	2e04      	cmp	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002e10:	f104 0304 	add.w	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002e14:	bf28      	it	cs
 8002e16:	2604      	movcs	r6, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002e18:	2b06      	cmp	r3, #6
 8002e1a:	d917      	bls.n	8002e4c <HAL_NVIC_SetPriority+0x4c>
 8002e1c:	3c03      	subs	r4, #3
 8002e1e:	2501      	movs	r5, #1
 8002e20:	40a5      	lsls	r5, r4
 8002e22:	3d01      	subs	r5, #1
 8002e24:	402a      	ands	r2, r5

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002e26:	2301      	movs	r3, #1
 8002e28:	40b3      	lsls	r3, r6
 8002e2a:	3b01      	subs	r3, #1
 8002e2c:	4019      	ands	r1, r3
 8002e2e:	40a1      	lsls	r1, r4
  if ((int32_t)(IRQn) < 0)
 8002e30:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002e32:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) < 0)
 8002e36:	db0c      	blt.n	8002e52 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002e38:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8002e3c:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8002e40:	0109      	lsls	r1, r1, #4
 8002e42:	b2c9      	uxtb	r1, r1
 8002e44:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8002e48:	bc70      	pop	{r4, r5, r6}
 8002e4a:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002e4c:	2200      	movs	r2, #0
 8002e4e:	4614      	mov	r4, r2
 8002e50:	e7e9      	b.n	8002e26 <HAL_NVIC_SetPriority+0x26>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002e52:	4b05      	ldr	r3, [pc, #20]	; (8002e68 <HAL_NVIC_SetPriority+0x68>)
 8002e54:	f000 000f 	and.w	r0, r0, #15
 8002e58:	0109      	lsls	r1, r1, #4
 8002e5a:	4403      	add	r3, r0
 8002e5c:	b2c9      	uxtb	r1, r1
 8002e5e:	7619      	strb	r1, [r3, #24]
 8002e60:	bc70      	pop	{r4, r5, r6}
 8002e62:	4770      	bx	lr
 8002e64:	e000ed00 	.word	0xe000ed00
 8002e68:	e000ecfc 	.word	0xe000ecfc
 8002e6c:	00000000 	.word	0x00000000

08002e70 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8002e70:	f000 011f 	and.w	r1, r0, #31
 8002e74:	2301      	movs	r3, #1
 8002e76:	0940      	lsrs	r0, r0, #5
 8002e78:	4a02      	ldr	r2, [pc, #8]	; (8002e84 <HAL_NVIC_EnableIRQ+0x14>)
 8002e7a:	408b      	lsls	r3, r1
 8002e7c:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8002e80:	4770      	bx	lr
 8002e82:	bf00      	nop
 8002e84:	e000e100 	.word	0xe000e100
	...

08002e90 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8002e90:	3801      	subs	r0, #1
 8002e92:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8002e96:	d20e      	bcs.n	8002eb6 <HAL_SYSTICK_Config+0x26>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002e98:	4b08      	ldr	r3, [pc, #32]	; (8002ebc <HAL_SYSTICK_Config+0x2c>)
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8002e9a:	b410      	push	{r4}
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002e9c:	4c08      	ldr	r4, [pc, #32]	; (8002ec0 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8002e9e:	6058      	str	r0, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002ea0:	2200      	movs	r2, #0
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002ea2:	20f0      	movs	r0, #240	; 0xf0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002ea4:	2107      	movs	r1, #7
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002ea6:	f884 0023 	strb.w	r0, [r4, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8002eaa:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8002eac:	6019      	str	r1, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8002eae:	4610      	mov	r0, r2
   return SysTick_Config(TicksNumb);
}
 8002eb0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002eb4:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8002eb6:	2001      	movs	r0, #1
   return SysTick_Config(TicksNumb);
 8002eb8:	4770      	bx	lr
 8002eba:	bf00      	nop
 8002ebc:	e000e010 	.word	0xe000e010
 8002ec0:	e000ed00 	.word	0xe000ed00
	...

08002ed0 <HAL_SYSTICK_CLKSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8002ed0:	4a04      	ldr	r2, [pc, #16]	; (8002ee4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
 8002ed2:	6813      	ldr	r3, [r2, #0]
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8002ed4:	2804      	cmp	r0, #4
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8002ed6:	bf0c      	ite	eq
 8002ed8:	f043 0304 	orreq.w	r3, r3, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8002edc:	f023 0304 	bicne.w	r3, r3, #4
 8002ee0:	6013      	str	r3, [r2, #0]
 8002ee2:	4770      	bx	lr
 8002ee4:	e000e010 	.word	0xe000e010
	...

08002ef0 <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp = 0U;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8002ef0:	2800      	cmp	r0, #0
 8002ef2:	d048      	beq.n	8002f86 <HAL_DMA_Init+0x96>
{
 8002ef4:	b4f0      	push	{r4, r5, r6, r7}
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002ef6:	6887      	ldr	r7, [r0, #8]
 8002ef8:	6842      	ldr	r2, [r0, #4]
 8002efa:	68c6      	ldr	r6, [r0, #12]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002efc:	6905      	ldr	r5, [r0, #16]
 8002efe:	6944      	ldr	r4, [r0, #20]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002f00:	6981      	ldr	r1, [r0, #24]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002f02:	433a      	orrs	r2, r7
 8002f04:	4603      	mov	r3, r0
 8002f06:	4332      	orrs	r2, r6
  tmp = hdma->Instance->CR;
 8002f08:	6800      	ldr	r0, [r0, #0]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002f0a:	432a      	orrs	r2, r5
  hdma->State = HAL_DMA_STATE_BUSY;
 8002f0c:	2602      	movs	r6, #2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002f0e:	4322      	orrs	r2, r4
  hdma->State = HAL_DMA_STATE_BUSY;
 8002f10:	f883 6035 	strb.w	r6, [r3, #53]	; 0x35
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002f14:	69dd      	ldr	r5, [r3, #28]
          hdma->Init.Mode                | hdma->Init.Priority;
 8002f16:	6a1e      	ldr	r6, [r3, #32]
  tmp = hdma->Instance->CR;
 8002f18:	6807      	ldr	r7, [r0, #0]
  if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 8002f1a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002f1c:	430a      	orrs	r2, r1
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002f1e:	491b      	ldr	r1, [pc, #108]	; (8002f8c <HAL_DMA_Init+0x9c>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002f20:	432a      	orrs	r2, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8002f22:	4332      	orrs	r2, r6
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002f24:	4039      	ands	r1, r7

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002f26:	2c04      	cmp	r4, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8002f28:	ea42 0201 	orr.w	r2, r2, r1
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002f2c:	d026      	beq.n	8002f7c <HAL_DMA_Init+0x8c>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8002f2e:	6002      	str	r2, [r0, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8002f30:	6819      	ldr	r1, [r3, #0]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8002f32:	6a58      	ldr	r0, [r3, #36]	; 0x24
  tmp = hdma->Instance->FCR;
 8002f34:	694a      	ldr	r2, [r1, #20]
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8002f36:	4c16      	ldr	r4, [pc, #88]	; (8002f90 <HAL_DMA_Init+0xa0>)
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002f38:	2804      	cmp	r0, #4
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8002f3a:	f022 0207 	bic.w	r2, r2, #7
  tmp |= hdma->Init.FIFOMode;
 8002f3e:	ea42 0200 	orr.w	r2, r2, r0
    tmp |= hdma->Init.FIFOThreshold;
 8002f42:	bf04      	itt	eq
 8002f44:	6a98      	ldreq	r0, [r3, #40]	; 0x28
 8002f46:	4302      	orreq	r2, r0
  hdma->Instance->FCR = tmp;
 8002f48:	614a      	str	r2, [r1, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8002f4a:	6819      	ldr	r1, [r3, #0]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8002f4c:	4811      	ldr	r0, [pc, #68]	; (8002f94 <HAL_DMA_Init+0xa4>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8002f4e:	b2ca      	uxtb	r2, r1
 8002f50:	3a10      	subs	r2, #16
 8002f52:	fba4 4202 	umull	r4, r2, r4, r2
 8002f56:	0912      	lsrs	r2, r2, #4
  
  if (stream_number > 3U)
 8002f58:	2a03      	cmp	r2, #3
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8002f5a:	5c80      	ldrb	r0, [r0, r2]
 8002f5c:	6558      	str	r0, [r3, #84]	; 0x54
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002f5e:	f421 727f 	bic.w	r2, r1, #1020	; 0x3fc
 8002f62:	f022 0203 	bic.w	r2, r2, #3
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002f66:	f04f 0000 	mov.w	r0, #0
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8002f6a:	bf88      	it	hi
 8002f6c:	3204      	addhi	r2, #4
  hdma->State = HAL_DMA_STATE_READY;
 8002f6e:	2101      	movs	r1, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8002f70:	64d8      	str	r0, [r3, #76]	; 0x4c
 8002f72:	651a      	str	r2, [r3, #80]	; 0x50
  hdma->State = HAL_DMA_STATE_READY;
 8002f74:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
}
 8002f78:	bcf0      	pop	{r4, r5, r6, r7}
 8002f7a:	4770      	bx	lr
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8002f7c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002f7e:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8002f80:	4321      	orrs	r1, r4
 8002f82:	430a      	orrs	r2, r1
 8002f84:	e7d3      	b.n	8002f2e <HAL_DMA_Init+0x3e>
    return HAL_ERROR;
 8002f86:	2001      	movs	r0, #1
 8002f88:	4770      	bx	lr
 8002f8a:	bf00      	nop
 8002f8c:	f010803f 	.word	0xf010803f
 8002f90:	aaaaaaab 	.word	0xaaaaaaab
 8002f94:	080040b0 	.word	0x080040b0
	...

08002fa0 <HAL_RTC_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 8002fa0:	2800      	cmp	r0, #0
 8002fa2:	d05b      	beq.n	800305c <HAL_RTC_Init+0xbc>
{
 8002fa4:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
  assert_param (IS_RTC_OUTPUT(hrtc->Init.OutPut));
  assert_param (IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
  assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
    
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8002fa6:	7f43      	ldrb	r3, [r0, #29]
 8002fa8:	4604      	mov	r4, r0
 8002faa:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002fae:	2b00      	cmp	r3, #0
 8002fb0:	d050      	beq.n	8003054 <HAL_RTC_Init+0xb4>
  
  /* Set RTC state */  
  hrtc->State = HAL_RTC_STATE_BUSY;  
       
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8002fb2:	6823      	ldr	r3, [r4, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8002fb4:	2102      	movs	r1, #2
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8002fb6:	22ca      	movs	r2, #202	; 0xca
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8002fb8:	7761      	strb	r1, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8002fba:	625a      	str	r2, [r3, #36]	; 0x24
 8002fbc:	6823      	ldr	r3, [r4, #0]
 8002fbe:	2253      	movs	r2, #83	; 0x53
 8002fc0:	625a      	str	r2, [r3, #36]	; 0x24
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0U; 
  
  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8002fc2:	6823      	ldr	r3, [r4, #0]
 8002fc4:	68da      	ldr	r2, [r3, #12]
 8002fc6:	0651      	lsls	r1, r2, #25
 8002fc8:	d52d      	bpl.n	8003026 <HAL_RTC_Init+0x86>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8002fca:	689a      	ldr	r2, [r3, #8]
 8002fcc:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 8002fd0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002fd4:	609a      	str	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8002fd6:	6822      	ldr	r2, [r4, #0]
 8002fd8:	6863      	ldr	r3, [r4, #4]
 8002fda:	6925      	ldr	r5, [r4, #16]
 8002fdc:	6960      	ldr	r0, [r4, #20]
 8002fde:	6891      	ldr	r1, [r2, #8]
 8002fe0:	432b      	orrs	r3, r5
 8002fe2:	4303      	orrs	r3, r0
 8002fe4:	430b      	orrs	r3, r1
 8002fe6:	6093      	str	r3, [r2, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8002fe8:	6823      	ldr	r3, [r4, #0]
 8002fea:	68e2      	ldr	r2, [r4, #12]
 8002fec:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 8002fee:	6822      	ldr	r2, [r4, #0]
 8002ff0:	68a1      	ldr	r1, [r4, #8]
 8002ff2:	6913      	ldr	r3, [r2, #16]
 8002ff4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8002ff8:	6113      	str	r3, [r2, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8002ffa:	6822      	ldr	r2, [r4, #0]
 8002ffc:	68d3      	ldr	r3, [r2, #12]
 8002ffe:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8003002:	60d3      	str	r3, [r2, #12]
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 8003004:	6822      	ldr	r2, [r4, #0]
 8003006:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8003008:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800300c:	6413      	str	r3, [r2, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType); 
 800300e:	6822      	ldr	r2, [r4, #0]
 8003010:	69a1      	ldr	r1, [r4, #24]
 8003012:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8003014:	430b      	orrs	r3, r1
 8003016:	6413      	str	r3, [r2, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8003018:	6822      	ldr	r2, [r4, #0]
 800301a:	21ff      	movs	r1, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_READY;
 800301c:	2301      	movs	r3, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 800301e:	6251      	str	r1, [r2, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8003020:	7763      	strb	r3, [r4, #29]
    return HAL_OK;
 8003022:	2000      	movs	r0, #0
}
 8003024:	bd38      	pop	{r3, r4, r5, pc}
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8003026:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800302a:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 800302c:	f7ff fc40 	bl	80028b0 <HAL_GetTick>
 8003030:	4605      	mov	r5, r0

    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003032:	6823      	ldr	r3, [r4, #0]
 8003034:	68da      	ldr	r2, [r3, #12]
 8003036:	0652      	lsls	r2, r2, #25
 8003038:	d4c7      	bmi.n	8002fca <HAL_RTC_Init+0x2a>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 800303a:	f7ff fc39 	bl	80028b0 <HAL_GetTick>
 800303e:	1b40      	subs	r0, r0, r5
 8003040:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003044:	d9f5      	bls.n	8003032 <HAL_RTC_Init+0x92>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8003046:	6822      	ldr	r2, [r4, #0]
 8003048:	21ff      	movs	r1, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 800304a:	2304      	movs	r3, #4
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 800304c:	6251      	str	r1, [r2, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 800304e:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 8003050:	2001      	movs	r0, #1
 8003052:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8003054:	7702      	strb	r2, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8003056:	f7fe fe73 	bl	8001d40 <HAL_RTC_MspInit>
 800305a:	e7aa      	b.n	8002fb2 <HAL_RTC_Init+0x12>
     return HAL_ERROR;
 800305c:	2001      	movs	r0, #1
 800305e:	4770      	bx	lr

08003060 <HAL_RTC_SetTime>:
  __HAL_LOCK(hrtc);
 8003060:	7f03      	ldrb	r3, [r0, #28]
 8003062:	2b01      	cmp	r3, #1
 8003064:	f000 8085 	beq.w	8003172 <HAL_RTC_SetTime+0x112>
{
 8003068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hrtc->State = HAL_RTC_STATE_BUSY;
 800306c:	2302      	movs	r3, #2
 800306e:	460c      	mov	r4, r1
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003070:	6806      	ldr	r6, [r0, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003072:	7743      	strb	r3, [r0, #29]
  __HAL_LOCK(hrtc);
 8003074:	2101      	movs	r1, #1
 8003076:	7701      	strb	r1, [r0, #28]
 8003078:	4605      	mov	r5, r0
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800307a:	68b7      	ldr	r7, [r6, #8]
  if(Format == RTC_FORMAT_BIN)
 800307c:	2a00      	cmp	r2, #0
 800307e:	d03e      	beq.n	80030fe <HAL_RTC_SetTime+0x9e>
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8003080:	7861      	ldrb	r1, [r4, #1]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8003082:	7822      	ldrb	r2, [r4, #0]
              ((uint32_t)sTime->Seconds) | \
 8003084:	78a3      	ldrb	r3, [r4, #2]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003086:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 800308a:	bf14      	ite	ne
 800308c:	78e7      	ldrbne	r7, [r4, #3]
      sTime->TimeFormat = 0x00U;
 800308e:	70e7      	strbeq	r7, [r4, #3]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8003090:	ea4f 2101 	mov.w	r1, r1, lsl #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8003094:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8003098:	bf18      	it	ne
 800309a:	043f      	lslne	r7, r7, #16
              ((uint32_t)(sTime->Minutes) << 8U) | \
 800309c:	ea41 0103 	orr.w	r1, r1, r3
 80030a0:	bf08      	it	eq
 80030a2:	6806      	ldreq	r6, [r0, #0]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 80030a4:	430f      	orrs	r7, r1
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80030a6:	23ca      	movs	r3, #202	; 0xca
 80030a8:	6273      	str	r3, [r6, #36]	; 0x24
 80030aa:	682b      	ldr	r3, [r5, #0]
 80030ac:	2253      	movs	r2, #83	; 0x53
 80030ae:	625a      	str	r2, [r3, #36]	; 0x24
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80030b0:	682a      	ldr	r2, [r5, #0]
 80030b2:	68d3      	ldr	r3, [r2, #12]
 80030b4:	0659      	lsls	r1, r3, #25
 80030b6:	d55e      	bpl.n	8003176 <HAL_RTC_SetTime+0x116>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80030b8:	f007 377f 	and.w	r7, r7, #2139062143	; 0x7f7f7f7f
 80030bc:	f027 47fe 	bic.w	r7, r7, #2130706432	; 0x7f000000
 80030c0:	6017      	str	r7, [r2, #0]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 80030c2:	682a      	ldr	r2, [r5, #0]
 80030c4:	6893      	ldr	r3, [r2, #8]
 80030c6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80030ca:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 80030cc:	682a      	ldr	r2, [r5, #0]
 80030ce:	68e3      	ldr	r3, [r4, #12]
 80030d0:	6920      	ldr	r0, [r4, #16]
 80030d2:	6891      	ldr	r1, [r2, #8]
 80030d4:	4303      	orrs	r3, r0
 80030d6:	430b      	orrs	r3, r1
 80030d8:	6093      	str	r3, [r2, #8]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;  
 80030da:	682a      	ldr	r2, [r5, #0]
 80030dc:	68d3      	ldr	r3, [r2, #12]
 80030de:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80030e2:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 80030e4:	682b      	ldr	r3, [r5, #0]
 80030e6:	689a      	ldr	r2, [r3, #8]
 80030e8:	0692      	lsls	r2, r2, #26
 80030ea:	d55f      	bpl.n	80031ac <HAL_RTC_SetTime+0x14c>
   __HAL_UNLOCK(hrtc); 
 80030ec:	2200      	movs	r2, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80030ee:	20ff      	movs	r0, #255	; 0xff
   hrtc->State = HAL_RTC_STATE_READY;
 80030f0:	2101      	movs	r1, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80030f2:	6258      	str	r0, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 80030f4:	7769      	strb	r1, [r5, #29]
   __HAL_UNLOCK(hrtc); 
 80030f6:	772a      	strb	r2, [r5, #28]
   return HAL_OK;
 80030f8:	4610      	mov	r0, r2
 80030fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80030fe:	f017 0740 	ands.w	r7, r7, #64	; 0x40
 8003102:	bf18      	it	ne
 8003104:	78e7      	ldrbne	r7, [r4, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8003106:	7821      	ldrb	r1, [r4, #0]
      sTime->TimeFormat = 0x00U;
 8003108:	bf06      	itte	eq
 800310a:	70e7      	strbeq	r7, [r4, #3]
 800310c:	6806      	ldreq	r6, [r0, #0]
 800310e:	043f      	lslne	r7, r7, #16
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
  
  while(Value >= 10U)
 8003110:	2909      	cmp	r1, #9
 8003112:	f04f 0000 	mov.w	r0, #0
 8003116:	d907      	bls.n	8003128 <HAL_RTC_SetTime+0xc8>
  {
    bcdhigh++;
    Value -= 10U;
 8003118:	390a      	subs	r1, #10
 800311a:	b2c9      	uxtb	r1, r1
  while(Value >= 10U)
 800311c:	2909      	cmp	r1, #9
    bcdhigh++;
 800311e:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10U)
 8003122:	d8f9      	bhi.n	8003118 <HAL_RTC_SetTime+0xb8>
 8003124:	0100      	lsls	r0, r0, #4
 8003126:	b2c0      	uxtb	r0, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8003128:	7863      	ldrb	r3, [r4, #1]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 800312a:	4301      	orrs	r1, r0
  while(Value >= 10U)
 800312c:	2b09      	cmp	r3, #9
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 800312e:	ea4f 4001 	mov.w	r0, r1, lsl #16
  while(Value >= 10U)
 8003132:	d956      	bls.n	80031e2 <HAL_RTC_SetTime+0x182>
 8003134:	2100      	movs	r1, #0
    Value -= 10U;
 8003136:	3b0a      	subs	r3, #10
 8003138:	b2db      	uxtb	r3, r3
  while(Value >= 10U)
 800313a:	2b09      	cmp	r3, #9
    bcdhigh++;
 800313c:	f101 0101 	add.w	r1, r1, #1
  while(Value >= 10U)
 8003140:	d8f9      	bhi.n	8003136 <HAL_RTC_SetTime+0xd6>
 8003142:	0109      	lsls	r1, r1, #4
 8003144:	fa5f fe81 	uxtb.w	lr, r1
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8003148:	78a1      	ldrb	r1, [r4, #2]
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 800314a:	ea43 030e 	orr.w	r3, r3, lr
  while(Value >= 10U)
 800314e:	2909      	cmp	r1, #9
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8003150:	ea4f 2303 	mov.w	r3, r3, lsl #8
  while(Value >= 10U)
 8003154:	d948      	bls.n	80031e8 <HAL_RTC_SetTime+0x188>
    Value -= 10U;
 8003156:	390a      	subs	r1, #10
 8003158:	b2c9      	uxtb	r1, r1
  while(Value >= 10U)
 800315a:	2909      	cmp	r1, #9
    bcdhigh++;
 800315c:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10U)
 8003160:	d8f9      	bhi.n	8003156 <HAL_RTC_SetTime+0xf6>
 8003162:	0112      	lsls	r2, r2, #4
 8003164:	b2d2      	uxtb	r2, r2
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 8003166:	4307      	orrs	r7, r0
 8003168:	433b      	orrs	r3, r7
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 800316a:	4311      	orrs	r1, r2
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 800316c:	ea43 0701 	orr.w	r7, r3, r1
 8003170:	e799      	b.n	80030a6 <HAL_RTC_SetTime+0x46>
  __HAL_LOCK(hrtc);
 8003172:	2002      	movs	r0, #2
 8003174:	4770      	bx	lr
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8003176:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800317a:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 800317c:	f7ff fb98 	bl	80028b0 <HAL_GetTick>
 8003180:	4680      	mov	r8, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003182:	682a      	ldr	r2, [r5, #0]
 8003184:	68d6      	ldr	r6, [r2, #12]
 8003186:	f016 0640 	ands.w	r6, r6, #64	; 0x40
 800318a:	d195      	bne.n	80030b8 <HAL_RTC_SetTime+0x58>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 800318c:	f7ff fb90 	bl	80028b0 <HAL_GetTick>
 8003190:	eba0 0008 	sub.w	r0, r0, r8
 8003194:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003198:	d9f3      	bls.n	8003182 <HAL_RTC_SetTime+0x122>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 800319a:	682a      	ldr	r2, [r5, #0]
 800319c:	21ff      	movs	r1, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 800319e:	2304      	movs	r3, #4
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 80031a0:	6251      	str	r1, [r2, #36]	; 0x24
    __HAL_UNLOCK(hrtc);
 80031a2:	772e      	strb	r6, [r5, #28]
    hrtc->State = HAL_RTC_STATE_ERROR;
 80031a4:	776b      	strb	r3, [r5, #29]
    return HAL_ERROR;
 80031a6:	2001      	movs	r0, #1
 80031a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 80031ac:	68da      	ldr	r2, [r3, #12]
 80031ae:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 80031b2:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 80031b4:	f7ff fb7c 	bl	80028b0 <HAL_GetTick>
 80031b8:	4606      	mov	r6, r0
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 80031ba:	682b      	ldr	r3, [r5, #0]
 80031bc:	68dc      	ldr	r4, [r3, #12]
 80031be:	f014 0420 	ands.w	r4, r4, #32
 80031c2:	d193      	bne.n	80030ec <HAL_RTC_SetTime+0x8c>
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80031c4:	f7ff fb74 	bl	80028b0 <HAL_GetTick>
 80031c8:	1b80      	subs	r0, r0, r6
 80031ca:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80031ce:	d9f4      	bls.n	80031ba <HAL_RTC_SetTime+0x15a>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 80031d0:	682a      	ldr	r2, [r5, #0]
 80031d2:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 80031d4:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 80031d6:	6251      	str	r1, [r2, #36]	; 0x24
        __HAL_UNLOCK(hrtc);
 80031d8:	772c      	strb	r4, [r5, #28]
        hrtc->State = HAL_RTC_STATE_ERROR;
 80031da:	776b      	strb	r3, [r5, #29]
        return HAL_ERROR;
 80031dc:	2001      	movs	r0, #1
}
 80031de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(Value >= 10U)
 80031e2:	f04f 0e00 	mov.w	lr, #0
 80031e6:	e7af      	b.n	8003148 <HAL_RTC_SetTime+0xe8>
 80031e8:	2200      	movs	r2, #0
 80031ea:	e7bc      	b.n	8003166 <HAL_RTC_SetTime+0x106>
 80031ec:	0000      	movs	r0, r0
	...

080031f0 <HAL_RTC_SetDate>:
{
 80031f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 __HAL_LOCK(hrtc);
 80031f2:	7f03      	ldrb	r3, [r0, #28]
 80031f4:	2b01      	cmp	r3, #1
 80031f6:	d064      	beq.n	80032c2 <HAL_RTC_SetDate+0xd2>
 80031f8:	4604      	mov	r4, r0
  hrtc->State = HAL_RTC_STATE_BUSY; 
 80031fa:	2302      	movs	r3, #2
 __HAL_LOCK(hrtc);
 80031fc:	2001      	movs	r0, #1
 80031fe:	7720      	strb	r0, [r4, #28]
  hrtc->State = HAL_RTC_STATE_BUSY; 
 8003200:	7763      	strb	r3, [r4, #29]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8003202:	b34a      	cbz	r2, 8003258 <HAL_RTC_SetDate+0x68>
                  (((uint32_t)sDate->Month) << 8U) | \
 8003204:	7848      	ldrb	r0, [r1, #1]
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8003206:	78ca      	ldrb	r2, [r1, #3]
                  ((uint32_t)sDate->Date) | \
 8003208:	788b      	ldrb	r3, [r1, #2]
                  (((uint32_t)sDate->WeekDay) << 13U));  
 800320a:	780d      	ldrb	r5, [r1, #0]
                  (((uint32_t)sDate->Month) << 8U) | \
 800320c:	0200      	lsls	r0, r0, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 800320e:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
                  (((uint32_t)sDate->Month) << 8U) | \
 8003212:	4318      	orrs	r0, r3
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 8003214:	ea40 3545 	orr.w	r5, r0, r5, lsl #13
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003218:	6823      	ldr	r3, [r4, #0]
 800321a:	22ca      	movs	r2, #202	; 0xca
 800321c:	625a      	str	r2, [r3, #36]	; 0x24
 800321e:	6823      	ldr	r3, [r4, #0]
 8003220:	2253      	movs	r2, #83	; 0x53
 8003222:	625a      	str	r2, [r3, #36]	; 0x24
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003224:	6822      	ldr	r2, [r4, #0]
 8003226:	68d3      	ldr	r3, [r2, #12]
 8003228:	0659      	lsls	r1, r3, #25
 800322a:	d54c      	bpl.n	80032c6 <HAL_RTC_SetDate+0xd6>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 800322c:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 8003230:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
 8003234:	6055      	str	r5, [r2, #4]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8003236:	6822      	ldr	r2, [r4, #0]
 8003238:	68d3      	ldr	r3, [r2, #12]
 800323a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800323e:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003240:	6823      	ldr	r3, [r4, #0]
 8003242:	689a      	ldr	r2, [r3, #8]
 8003244:	0692      	lsls	r2, r2, #26
 8003246:	d55d      	bpl.n	8003304 <HAL_RTC_SetDate+0x114>
    __HAL_UNLOCK(hrtc);
 8003248:	2200      	movs	r2, #0
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 800324a:	20ff      	movs	r0, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_READY ;
 800324c:	2101      	movs	r1, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 800324e:	6258      	str	r0, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 8003250:	7761      	strb	r1, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8003252:	7722      	strb	r2, [r4, #28]
    return HAL_OK;    
 8003254:	4610      	mov	r0, r2
 8003256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8003258:	784e      	ldrb	r6, [r1, #1]
 800325a:	06f0      	lsls	r0, r6, #27
 800325c:	d44c      	bmi.n	80032f8 <HAL_RTC_SetDate+0x108>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 800325e:	78cb      	ldrb	r3, [r1, #3]
  while(Value >= 10U)
 8003260:	2b09      	cmp	r3, #9
 8003262:	f04f 0000 	mov.w	r0, #0
 8003266:	d907      	bls.n	8003278 <HAL_RTC_SetDate+0x88>
    Value -= 10U;
 8003268:	3b0a      	subs	r3, #10
 800326a:	b2db      	uxtb	r3, r3
  while(Value >= 10U)
 800326c:	2b09      	cmp	r3, #9
    bcdhigh++;
 800326e:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10U)
 8003272:	d8f9      	bhi.n	8003268 <HAL_RTC_SetDate+0x78>
 8003274:	0100      	lsls	r0, r0, #4
 8003276:	b2c0      	uxtb	r0, r0
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8003278:	4303      	orrs	r3, r0
  while(Value >= 10U)
 800327a:	2e09      	cmp	r6, #9
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 800327c:	ea4f 4303 	mov.w	r3, r3, lsl #16
  while(Value >= 10U)
 8003280:	f04f 0500 	mov.w	r5, #0
 8003284:	d908      	bls.n	8003298 <HAL_RTC_SetDate+0xa8>
    Value -= 10U;
 8003286:	f1a6 000a 	sub.w	r0, r6, #10
 800328a:	b2c6      	uxtb	r6, r0
  while(Value >= 10U)
 800328c:	2e09      	cmp	r6, #9
    bcdhigh++;
 800328e:	f105 0501 	add.w	r5, r5, #1
  while(Value >= 10U)
 8003292:	d8f8      	bhi.n	8003286 <HAL_RTC_SetDate+0x96>
 8003294:	012d      	lsls	r5, r5, #4
 8003296:	b2ed      	uxtb	r5, r5
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8003298:	7888      	ldrb	r0, [r1, #2]
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 800329a:	4335      	orrs	r5, r6
  while(Value >= 10U)
 800329c:	2809      	cmp	r0, #9
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 800329e:	ea4f 2505 	mov.w	r5, r5, lsl #8
  while(Value >= 10U)
 80032a2:	d949      	bls.n	8003338 <HAL_RTC_SetDate+0x148>
    Value -= 10U;
 80032a4:	380a      	subs	r0, #10
 80032a6:	b2c0      	uxtb	r0, r0
  while(Value >= 10U)
 80032a8:	2809      	cmp	r0, #9
    bcdhigh++;
 80032aa:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10U)
 80032ae:	d8f9      	bhi.n	80032a4 <HAL_RTC_SetDate+0xb4>
 80032b0:	0112      	lsls	r2, r2, #4
 80032b2:	b2d2      	uxtb	r2, r2
                 ((uint32_t)sDate->WeekDay << 13U));   
 80032b4:	7809      	ldrb	r1, [r1, #0]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 80032b6:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
 80032ba:	431d      	orrs	r5, r3
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 80032bc:	4310      	orrs	r0, r2
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 80032be:	4305      	orrs	r5, r0
 80032c0:	e7aa      	b.n	8003218 <HAL_RTC_SetDate+0x28>
 __HAL_LOCK(hrtc);
 80032c2:	2002      	movs	r0, #2
 80032c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80032c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80032ca:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 80032cc:	f7ff faf0 	bl	80028b0 <HAL_GetTick>
 80032d0:	4607      	mov	r7, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 80032d2:	6822      	ldr	r2, [r4, #0]
 80032d4:	68d6      	ldr	r6, [r2, #12]
 80032d6:	f016 0640 	ands.w	r6, r6, #64	; 0x40
 80032da:	d1a7      	bne.n	800322c <HAL_RTC_SetDate+0x3c>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80032dc:	f7ff fae8 	bl	80028b0 <HAL_GetTick>
 80032e0:	1bc0      	subs	r0, r0, r7
 80032e2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80032e6:	d9f4      	bls.n	80032d2 <HAL_RTC_SetDate+0xe2>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 80032e8:	6822      	ldr	r2, [r4, #0]
 80032ea:	21ff      	movs	r1, #255	; 0xff
    hrtc->State = HAL_RTC_STATE_ERROR;
 80032ec:	2304      	movs	r3, #4
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 80032ee:	6251      	str	r1, [r2, #36]	; 0x24
    __HAL_UNLOCK(hrtc);
 80032f0:	7726      	strb	r6, [r4, #28]
    hrtc->State = HAL_RTC_STATE_ERROR;
 80032f2:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 80032f4:	2001      	movs	r0, #1
 80032f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 80032f8:	f026 0510 	bic.w	r5, r6, #16
 80032fc:	350a      	adds	r5, #10
 80032fe:	b2ee      	uxtb	r6, r5
 8003300:	704e      	strb	r6, [r1, #1]
 8003302:	e7ac      	b.n	800325e <HAL_RTC_SetDate+0x6e>
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8003304:	68da      	ldr	r2, [r3, #12]
 8003306:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 800330a:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 800330c:	f7ff fad0 	bl	80028b0 <HAL_GetTick>
 8003310:	4606      	mov	r6, r0
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8003312:	6823      	ldr	r3, [r4, #0]
 8003314:	68dd      	ldr	r5, [r3, #12]
 8003316:	f015 0520 	ands.w	r5, r5, #32
 800331a:	d195      	bne.n	8003248 <HAL_RTC_SetDate+0x58>
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 800331c:	f7ff fac8 	bl	80028b0 <HAL_GetTick>
 8003320:	1b80      	subs	r0, r0, r6
 8003322:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003326:	d9f4      	bls.n	8003312 <HAL_RTC_SetDate+0x122>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8003328:	6822      	ldr	r2, [r4, #0]
 800332a:	21ff      	movs	r1, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_ERROR;
 800332c:	2304      	movs	r3, #4
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 800332e:	6251      	str	r1, [r2, #36]	; 0x24
        __HAL_UNLOCK(hrtc);
 8003330:	7725      	strb	r5, [r4, #28]
        hrtc->State = HAL_RTC_STATE_ERROR;
 8003332:	7763      	strb	r3, [r4, #29]
        return HAL_ERROR;
 8003334:	2001      	movs	r0, #1
}
 8003336:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  while(Value >= 10U)
 8003338:	2200      	movs	r2, #0
 800333a:	e7bb      	b.n	80032b4 <HAL_RTC_SetDate+0xc4>
 800333c:	0000      	movs	r0, r0
	...

08003340 <HAL_RTC_SetAlarm>:
  __HAL_LOCK(hrtc);
 8003340:	7f03      	ldrb	r3, [r0, #28]
 8003342:	2b01      	cmp	r3, #1
 8003344:	f000 80bb 	beq.w	80034be <HAL_RTC_SetAlarm+0x17e>
{
 8003348:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800334c:	4605      	mov	r5, r0
  hrtc->State = HAL_RTC_STATE_BUSY;
 800334e:	2302      	movs	r3, #2
  __HAL_LOCK(hrtc);
 8003350:	2001      	movs	r0, #1
 8003352:	7728      	strb	r0, [r5, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003354:	776b      	strb	r3, [r5, #29]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003356:	682f      	ldr	r7, [r5, #0]
  if(Format == RTC_FORMAT_BIN)
 8003358:	2a00      	cmp	r2, #0
 800335a:	d055      	beq.n	8003408 <HAL_RTC_SetAlarm+0xc8>
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 800335c:	69cb      	ldr	r3, [r1, #28]
 800335e:	6948      	ldr	r0, [r1, #20]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003360:	68be      	ldr	r6, [r7, #8]
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8003362:	788a      	ldrb	r2, [r1, #2]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8003364:	780c      	ldrb	r4, [r1, #0]
 8003366:	4318      	orrs	r0, r3
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003368:	f016 0640 	ands.w	r6, r6, #64	; 0x40
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 800336c:	ea40 0002 	orr.w	r0, r0, r2
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 8003370:	784a      	ldrb	r2, [r1, #1]
 8003372:	bf18      	it	ne
 8003374:	78ce      	ldrbne	r6, [r1, #3]
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 8003376:	f891 3020 	ldrb.w	r3, [r1, #32]
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 800337a:	bf08      	it	eq
 800337c:	70ce      	strbeq	r6, [r1, #3]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 800337e:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8003382:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
 8003386:	bf18      	it	ne
 8003388:	0436      	lslne	r6, r6, #16
 800338a:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
 800338e:	bf08      	it	eq
 8003390:	682f      	ldreq	r7, [r5, #0]
 8003392:	4306      	orrs	r6, r0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003394:	23ca      	movs	r3, #202	; 0xca
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8003396:	698a      	ldr	r2, [r1, #24]
 8003398:	6848      	ldr	r0, [r1, #4]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800339a:	627b      	str	r3, [r7, #36]	; 0x24
 800339c:	682b      	ldr	r3, [r5, #0]
 800339e:	2453      	movs	r4, #83	; 0x53
 80033a0:	625c      	str	r4, [r3, #36]	; 0x24
  if(sAlarm->Alarm == RTC_ALARM_A)
 80033a2:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 80033a4:	ea40 0702 	orr.w	r7, r0, r2
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 80033a8:	682a      	ldr	r2, [r5, #0]
  if(sAlarm->Alarm == RTC_ALARM_A)
 80033aa:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 80033ae:	6893      	ldr	r3, [r2, #8]
  if(sAlarm->Alarm == RTC_ALARM_A)
 80033b0:	f000 8090 	beq.w	80034d4 <HAL_RTC_SetAlarm+0x194>
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 80033b4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80033b8:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
 80033ba:	682a      	ldr	r2, [r5, #0]
 80033bc:	6893      	ldr	r3, [r2, #8]
 80033be:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80033c2:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 80033c4:	f7ff fa74 	bl	80028b0 <HAL_GetTick>
 80033c8:	4680      	mov	r8, r0
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 80033ca:	e006      	b.n	80033da <HAL_RTC_SetAlarm+0x9a>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80033cc:	f7ff fa70 	bl	80028b0 <HAL_GetTick>
 80033d0:	eba0 0008 	sub.w	r0, r0, r8
 80033d4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80033d8:	d873      	bhi.n	80034c2 <HAL_RTC_SetAlarm+0x182>
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 80033da:	682a      	ldr	r2, [r5, #0]
 80033dc:	68d4      	ldr	r4, [r2, #12]
 80033de:	f014 0402 	ands.w	r4, r4, #2
 80033e2:	d0f3      	beq.n	80033cc <HAL_RTC_SetAlarm+0x8c>
    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 80033e4:	6216      	str	r6, [r2, #32]
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 80033e6:	682b      	ldr	r3, [r5, #0]
 80033e8:	649f      	str	r7, [r3, #72]	; 0x48
    __HAL_RTC_ALARMB_ENABLE(hrtc); 
 80033ea:	682a      	ldr	r2, [r5, #0]
 80033ec:	6893      	ldr	r3, [r2, #8]
 80033ee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80033f2:	6093      	str	r3, [r2, #8]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);   
 80033f4:	6829      	ldr	r1, [r5, #0]
  __HAL_UNLOCK(hrtc);
 80033f6:	2300      	movs	r3, #0
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);   
 80033f8:	20ff      	movs	r0, #255	; 0xff
  hrtc->State = HAL_RTC_STATE_READY; 
 80033fa:	2201      	movs	r2, #1
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);   
 80033fc:	6248      	str	r0, [r1, #36]	; 0x24
  hrtc->State = HAL_RTC_STATE_READY; 
 80033fe:	776a      	strb	r2, [r5, #29]
  __HAL_UNLOCK(hrtc);
 8003400:	772b      	strb	r3, [r5, #28]
  return HAL_OK;
 8003402:	4618      	mov	r0, r3
 8003404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003408:	68bb      	ldr	r3, [r7, #8]
    if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 800340a:	69ce      	ldr	r6, [r1, #28]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800340c:	f013 0e40 	ands.w	lr, r3, #64	; 0x40
 8003410:	bf18      	it	ne
 8003412:	f891 e003 	ldrbne.w	lr, [r1, #3]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8003416:	780b      	ldrb	r3, [r1, #0]
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 8003418:	bf0a      	itet	eq
 800341a:	f881 e003 	strbeq.w	lr, [r1, #3]
 800341e:	ea4f 4e0e 	movne.w	lr, lr, lsl #16
 8003422:	682f      	ldreq	r7, [r5, #0]
  while(Value >= 10U)
 8003424:	2b09      	cmp	r3, #9
 8003426:	d979      	bls.n	800351c <HAL_RTC_SetAlarm+0x1dc>
 8003428:	2000      	movs	r0, #0
    Value -= 10U;
 800342a:	3b0a      	subs	r3, #10
 800342c:	b2db      	uxtb	r3, r3
  while(Value >= 10U)
 800342e:	2b09      	cmp	r3, #9
    bcdhigh++;
 8003430:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10U)
 8003434:	d8f9      	bhi.n	800342a <HAL_RTC_SetAlarm+0xea>
 8003436:	0100      	lsls	r0, r0, #4
 8003438:	b2c4      	uxtb	r4, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 800343a:	7848      	ldrb	r0, [r1, #1]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 800343c:	4323      	orrs	r3, r4
  while(Value >= 10U)
 800343e:	2809      	cmp	r0, #9
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8003440:	ea4f 4303 	mov.w	r3, r3, lsl #16
  while(Value >= 10U)
 8003444:	f04f 0400 	mov.w	r4, #0
 8003448:	d907      	bls.n	800345a <HAL_RTC_SetAlarm+0x11a>
    Value -= 10U;
 800344a:	380a      	subs	r0, #10
 800344c:	b2c0      	uxtb	r0, r0
  while(Value >= 10U)
 800344e:	2809      	cmp	r0, #9
    bcdhigh++;
 8003450:	f104 0401 	add.w	r4, r4, #1
  while(Value >= 10U)
 8003454:	d8f9      	bhi.n	800344a <HAL_RTC_SetAlarm+0x10a>
 8003456:	0124      	lsls	r4, r4, #4
 8003458:	b2e4      	uxtb	r4, r4
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 800345a:	f891 c002 	ldrb.w	ip, [r1, #2]
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 800345e:	4320      	orrs	r0, r4
  while(Value >= 10U)
 8003460:	f1bc 0f09 	cmp.w	ip, #9
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 8003464:	ea4f 2400 	mov.w	r4, r0, lsl #8
  while(Value >= 10U)
 8003468:	d95a      	bls.n	8003520 <HAL_RTC_SetAlarm+0x1e0>
 800346a:	2000      	movs	r0, #0
    Value -= 10U;
 800346c:	f1ac 0c0a 	sub.w	ip, ip, #10
 8003470:	fa5f fc8c 	uxtb.w	ip, ip
  while(Value >= 10U)
 8003474:	f1bc 0f09 	cmp.w	ip, #9
    bcdhigh++;
 8003478:	f100 0001 	add.w	r0, r0, #1
  while(Value >= 10U)
 800347c:	d8f6      	bhi.n	800346c <HAL_RTC_SetAlarm+0x12c>
 800347e:	0100      	lsls	r0, r0, #4
 8003480:	fa5f f880 	uxtb.w	r8, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 8003484:	f891 0020 	ldrb.w	r0, [r1, #32]
  while(Value >= 10U)
 8003488:	2809      	cmp	r0, #9
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 800348a:	ea4c 0c08 	orr.w	ip, ip, r8
  while(Value >= 10U)
 800348e:	d942      	bls.n	8003516 <HAL_RTC_SetAlarm+0x1d6>
    Value -= 10U;
 8003490:	380a      	subs	r0, #10
 8003492:	b2c0      	uxtb	r0, r0
  while(Value >= 10U)
 8003494:	2809      	cmp	r0, #9
    bcdhigh++;
 8003496:	f102 0201 	add.w	r2, r2, #1
  while(Value >= 10U)
 800349a:	d8f9      	bhi.n	8003490 <HAL_RTC_SetAlarm+0x150>
 800349c:	0112      	lsls	r2, r2, #4
 800349e:	fa5f f882 	uxtb.w	r8, r2
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 80034a2:	694a      	ldr	r2, [r1, #20]
 80034a4:	4316      	orrs	r6, r2
 80034a6:	ea46 0e0e 	orr.w	lr, r6, lr
 80034aa:	ea4e 0303 	orr.w	r3, lr, r3
 80034ae:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 80034b0:	ea40 0008 	orr.w	r0, r0, r8
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 80034b4:	ea44 0c0c 	orr.w	ip, r4, ip
 80034b8:	ea4c 6600 	orr.w	r6, ip, r0, lsl #24
 80034bc:	e76a      	b.n	8003394 <HAL_RTC_SetAlarm+0x54>
  __HAL_LOCK(hrtc);
 80034be:	2002      	movs	r0, #2
 80034c0:	4770      	bx	lr
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80034c2:	682a      	ldr	r2, [r5, #0]
        hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 80034c4:	2303      	movs	r3, #3
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80034c6:	21ff      	movs	r1, #255	; 0xff
 80034c8:	6251      	str	r1, [r2, #36]	; 0x24
        __HAL_UNLOCK(hrtc);
 80034ca:	772c      	strb	r4, [r5, #28]
        hrtc->State = HAL_RTC_STATE_TIMEOUT; 
 80034cc:	776b      	strb	r3, [r5, #29]
        return HAL_TIMEOUT;
 80034ce:	4618      	mov	r0, r3
 80034d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 80034d4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80034d8:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
 80034da:	682a      	ldr	r2, [r5, #0]
 80034dc:	6893      	ldr	r3, [r2, #8]
 80034de:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80034e2:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 80034e4:	f7ff f9e4 	bl	80028b0 <HAL_GetTick>
 80034e8:	4680      	mov	r8, r0
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 80034ea:	e006      	b.n	80034fa <HAL_RTC_SetAlarm+0x1ba>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 80034ec:	f7ff f9e0 	bl	80028b0 <HAL_GetTick>
 80034f0:	eba0 0008 	sub.w	r0, r0, r8
 80034f4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80034f8:	d8e3      	bhi.n	80034c2 <HAL_RTC_SetAlarm+0x182>
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 80034fa:	682a      	ldr	r2, [r5, #0]
 80034fc:	68d4      	ldr	r4, [r2, #12]
 80034fe:	f014 0401 	ands.w	r4, r4, #1
 8003502:	d0f3      	beq.n	80034ec <HAL_RTC_SetAlarm+0x1ac>
    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8003504:	61d6      	str	r6, [r2, #28]
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8003506:	682b      	ldr	r3, [r5, #0]
 8003508:	645f      	str	r7, [r3, #68]	; 0x44
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 800350a:	682a      	ldr	r2, [r5, #0]
 800350c:	6893      	ldr	r3, [r2, #8]
 800350e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003512:	6093      	str	r3, [r2, #8]
 8003514:	e76e      	b.n	80033f4 <HAL_RTC_SetAlarm+0xb4>
  while(Value >= 10U)
 8003516:	f04f 0800 	mov.w	r8, #0
 800351a:	e7c2      	b.n	80034a2 <HAL_RTC_SetAlarm+0x162>
 800351c:	2400      	movs	r4, #0
 800351e:	e78c      	b.n	800343a <HAL_RTC_SetAlarm+0xfa>
 8003520:	f04f 0800 	mov.w	r8, #0
 8003524:	e7ae      	b.n	8003484 <HAL_RTC_SetAlarm+0x144>
 8003526:	bf00      	nop
	...

08003530 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8003530:	4a4f      	ldr	r2, [pc, #316]	; (8003670 <HAL_RCC_ClockConfig+0x140>)
 8003532:	6813      	ldr	r3, [r2, #0]
 8003534:	f003 030f 	and.w	r3, r3, #15
 8003538:	428b      	cmp	r3, r1
 800353a:	d208      	bcs.n	800354e <HAL_RCC_ClockConfig+0x1e>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800353c:	b2cb      	uxtb	r3, r1
 800353e:	7013      	strb	r3, [r2, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8003540:	6813      	ldr	r3, [r2, #0]
 8003542:	f003 030f 	and.w	r3, r3, #15
 8003546:	4299      	cmp	r1, r3
 8003548:	d001      	beq.n	800354e <HAL_RCC_ClockConfig+0x1e>
    {
      return HAL_ERROR;
 800354a:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
  
  return HAL_OK;
}
 800354c:	4770      	bx	lr
{
 800354e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003552:	6803      	ldr	r3, [r0, #0]
 8003554:	079a      	lsls	r2, r3, #30
 8003556:	d507      	bpl.n	8003568 <HAL_RCC_ClockConfig+0x38>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003558:	4a46      	ldr	r2, [pc, #280]	; (8003674 <HAL_RCC_ClockConfig+0x144>)
 800355a:	6884      	ldr	r4, [r0, #8]
 800355c:	6893      	ldr	r3, [r2, #8]
 800355e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003562:	4323      	orrs	r3, r4
 8003564:	6093      	str	r3, [r2, #8]
 8003566:	6803      	ldr	r3, [r0, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003568:	07df      	lsls	r7, r3, #31
 800356a:	4606      	mov	r6, r0
 800356c:	460c      	mov	r4, r1
 800356e:	d525      	bpl.n	80035bc <HAL_RCC_ClockConfig+0x8c>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003570:	6842      	ldr	r2, [r0, #4]
 8003572:	2a01      	cmp	r2, #1
 8003574:	d05b      	beq.n	800362e <HAL_RCC_ClockConfig+0xfe>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 8003576:	1e93      	subs	r3, r2, #2
 8003578:	2b01      	cmp	r3, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800357a:	4b3e      	ldr	r3, [pc, #248]	; (8003674 <HAL_RCC_ClockConfig+0x144>)
 800357c:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 800357e:	d948      	bls.n	8003612 <HAL_RCC_ClockConfig+0xe2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003580:	0799      	lsls	r1, r3, #30
 8003582:	d528      	bpl.n	80035d6 <HAL_RCC_ClockConfig+0xa6>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003584:	4d3b      	ldr	r5, [pc, #236]	; (8003674 <HAL_RCC_ClockConfig+0x144>)
 8003586:	68ab      	ldr	r3, [r5, #8]
 8003588:	f023 0303 	bic.w	r3, r3, #3
 800358c:	4313      	orrs	r3, r2
 800358e:	60ab      	str	r3, [r5, #8]
    tickstart = HAL_GetTick();
 8003590:	f7ff f98e 	bl	80028b0 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003594:	6873      	ldr	r3, [r6, #4]
 8003596:	2b01      	cmp	r3, #1
    tickstart = HAL_GetTick();
 8003598:	4607      	mov	r7, r0
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800359a:	d04d      	beq.n	8003638 <HAL_RCC_ClockConfig+0x108>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800359c:	2b02      	cmp	r3, #2
 800359e:	d059      	beq.n	8003654 <HAL_RCC_ClockConfig+0x124>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 80035a0:	2b03      	cmp	r3, #3
 80035a2:	d039      	beq.n	8003618 <HAL_RCC_ClockConfig+0xe8>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80035a4:	f241 3888 	movw	r8, #5000	; 0x1388
 80035a8:	e004      	b.n	80035b4 <HAL_RCC_ClockConfig+0x84>
 80035aa:	f7ff f981 	bl	80028b0 <HAL_GetTick>
 80035ae:	1bc0      	subs	r0, r0, r7
 80035b0:	4540      	cmp	r0, r8
 80035b2:	d839      	bhi.n	8003628 <HAL_RCC_ClockConfig+0xf8>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80035b4:	68ab      	ldr	r3, [r5, #8]
 80035b6:	f013 0f0c 	tst.w	r3, #12
 80035ba:	d1f6      	bne.n	80035aa <HAL_RCC_ClockConfig+0x7a>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80035bc:	4a2c      	ldr	r2, [pc, #176]	; (8003670 <HAL_RCC_ClockConfig+0x140>)
 80035be:	6813      	ldr	r3, [r2, #0]
 80035c0:	f003 030f 	and.w	r3, r3, #15
 80035c4:	429c      	cmp	r4, r3
 80035c6:	d209      	bcs.n	80035dc <HAL_RCC_ClockConfig+0xac>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80035c8:	b2e3      	uxtb	r3, r4
 80035ca:	7013      	strb	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80035cc:	6813      	ldr	r3, [r2, #0]
 80035ce:	f003 030f 	and.w	r3, r3, #15
 80035d2:	429c      	cmp	r4, r3
 80035d4:	d002      	beq.n	80035dc <HAL_RCC_ClockConfig+0xac>
      return HAL_ERROR;
 80035d6:	2001      	movs	r0, #1
 80035d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80035dc:	6833      	ldr	r3, [r6, #0]
 80035de:	075a      	lsls	r2, r3, #29
 80035e0:	d507      	bpl.n	80035f2 <HAL_RCC_ClockConfig+0xc2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80035e2:	4a24      	ldr	r2, [pc, #144]	; (8003674 <HAL_RCC_ClockConfig+0x144>)
 80035e4:	68f1      	ldr	r1, [r6, #12]
 80035e6:	6893      	ldr	r3, [r2, #8]
 80035e8:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 80035ec:	430b      	orrs	r3, r1
 80035ee:	6093      	str	r3, [r2, #8]
 80035f0:	6833      	ldr	r3, [r6, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80035f2:	071b      	lsls	r3, r3, #28
 80035f4:	d507      	bpl.n	8003606 <HAL_RCC_ClockConfig+0xd6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80035f6:	4a1f      	ldr	r2, [pc, #124]	; (8003674 <HAL_RCC_ClockConfig+0x144>)
 80035f8:	6931      	ldr	r1, [r6, #16]
 80035fa:	6893      	ldr	r3, [r2, #8]
 80035fc:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8003600:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8003604:	6093      	str	r3, [r2, #8]
  HAL_InitTick (TICK_INT_PRIORITY);
 8003606:	2002      	movs	r0, #2
 8003608:	f7ff f912 	bl	8002830 <HAL_InitTick>
  return HAL_OK;
 800360c:	2000      	movs	r0, #0
}
 800360e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003612:	0198      	lsls	r0, r3, #6
 8003614:	d4b6      	bmi.n	8003584 <HAL_RCC_ClockConfig+0x54>
 8003616:	e7de      	b.n	80035d6 <HAL_RCC_ClockConfig+0xa6>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003618:	f241 3488 	movw	r4, #5000	; 0x1388
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 800361c:	68ab      	ldr	r3, [r5, #8]
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800361e:	f7ff f947 	bl	80028b0 <HAL_GetTick>
 8003622:	1bc0      	subs	r0, r0, r7
 8003624:	42a0      	cmp	r0, r4
 8003626:	d9f9      	bls.n	800361c <HAL_RCC_ClockConfig+0xec>
          return HAL_TIMEOUT;
 8003628:	2003      	movs	r0, #3
 800362a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800362e:	4b11      	ldr	r3, [pc, #68]	; (8003674 <HAL_RCC_ClockConfig+0x144>)
 8003630:	681b      	ldr	r3, [r3, #0]
 8003632:	039d      	lsls	r5, r3, #14
 8003634:	d4a6      	bmi.n	8003584 <HAL_RCC_ClockConfig+0x54>
 8003636:	e7ce      	b.n	80035d6 <HAL_RCC_ClockConfig+0xa6>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003638:	f241 3888 	movw	r8, #5000	; 0x1388
 800363c:	e004      	b.n	8003648 <HAL_RCC_ClockConfig+0x118>
 800363e:	f7ff f937 	bl	80028b0 <HAL_GetTick>
 8003642:	1bc0      	subs	r0, r0, r7
 8003644:	4540      	cmp	r0, r8
 8003646:	d8ef      	bhi.n	8003628 <HAL_RCC_ClockConfig+0xf8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8003648:	68ab      	ldr	r3, [r5, #8]
 800364a:	f003 030c 	and.w	r3, r3, #12
 800364e:	2b04      	cmp	r3, #4
 8003650:	d1f5      	bne.n	800363e <HAL_RCC_ClockConfig+0x10e>
 8003652:	e7b3      	b.n	80035bc <HAL_RCC_ClockConfig+0x8c>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003654:	f241 3888 	movw	r8, #5000	; 0x1388
 8003658:	e004      	b.n	8003664 <HAL_RCC_ClockConfig+0x134>
 800365a:	f7ff f929 	bl	80028b0 <HAL_GetTick>
 800365e:	1bc0      	subs	r0, r0, r7
 8003660:	4540      	cmp	r0, r8
 8003662:	d8e1      	bhi.n	8003628 <HAL_RCC_ClockConfig+0xf8>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003664:	68ab      	ldr	r3, [r5, #8]
 8003666:	f003 030c 	and.w	r3, r3, #12
 800366a:	2b08      	cmp	r3, #8
 800366c:	d1f5      	bne.n	800365a <HAL_RCC_ClockConfig+0x12a>
 800366e:	e7a5      	b.n	80035bc <HAL_RCC_ClockConfig+0x8c>
 8003670:	40023c00 	.word	0x40023c00
 8003674:	40023800 	.word	0x40023800
	...

08003680 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003680:	4a19      	ldr	r2, [pc, #100]	; (80036e8 <HAL_RCC_GetSysClockFreq+0x68>)
 8003682:	6893      	ldr	r3, [r2, #8]
 8003684:	f003 030c 	and.w	r3, r3, #12
 8003688:	2b04      	cmp	r3, #4
 800368a:	d02b      	beq.n	80036e4 <HAL_RCC_GetSysClockFreq+0x64>
 800368c:	2b08      	cmp	r3, #8
 800368e:	d127      	bne.n	80036e0 <HAL_RCC_GetSysClockFreq+0x60>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003690:	6851      	ldr	r1, [r2, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003692:	6853      	ldr	r3, [r2, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003694:	f001 013f 	and.w	r1, r1, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003698:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 800369c:	6853      	ldr	r3, [r2, #4]
 800369e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 80036a2:	fa92 f0a2 	rbit	r0, r2
 80036a6:	fab0 f080 	clz	r0, r0
 80036aa:	ea03 0302 	and.w	r3, r3, r2
 80036ae:	fa23 f300 	lsr.w	r3, r3, r0
 80036b2:	bf14      	ite	ne
 80036b4:	480d      	ldrne	r0, [pc, #52]	; (80036ec <HAL_RCC_GetSysClockFreq+0x6c>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 80036b6:	480e      	ldreq	r0, [pc, #56]	; (80036f0 <HAL_RCC_GetSysClockFreq+0x70>)
 80036b8:	fbb0 f0f1 	udiv	r0, r0, r1
 80036bc:	fb00 f003 	mul.w	r0, r0, r3
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 80036c0:	4b09      	ldr	r3, [pc, #36]	; (80036e8 <HAL_RCC_GetSysClockFreq+0x68>)
 80036c2:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 80036c6:	685b      	ldr	r3, [r3, #4]
 80036c8:	fa92 f2a2 	rbit	r2, r2
 80036cc:	fab2 f282 	clz	r2, r2
 80036d0:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80036d4:	40d3      	lsrs	r3, r2
 80036d6:	3301      	adds	r3, #1
 80036d8:	005b      	lsls	r3, r3, #1
      
      sysclockfreq = pllvco/pllp;
 80036da:	fbb0 f0f3 	udiv	r0, r0, r3
 80036de:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
 80036e0:	4803      	ldr	r0, [pc, #12]	; (80036f0 <HAL_RCC_GetSysClockFreq+0x70>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80036e2:	4770      	bx	lr
      sysclockfreq = HSE_VALUE;
 80036e4:	4801      	ldr	r0, [pc, #4]	; (80036ec <HAL_RCC_GetSysClockFreq+0x6c>)
 80036e6:	4770      	bx	lr
 80036e8:	40023800 	.word	0x40023800
 80036ec:	007a1200 	.word	0x007a1200
 80036f0:	00f42400 	.word	0x00f42400
	...

08003700 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8003700:	b508      	push	{r3, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8003702:	f7ff ffbd 	bl	8003680 <HAL_RCC_GetSysClockFreq>
 8003706:	4b08      	ldr	r3, [pc, #32]	; (8003728 <HAL_RCC_GetHCLKFreq+0x28>)
 8003708:	22f0      	movs	r2, #240	; 0xf0
 800370a:	689b      	ldr	r3, [r3, #8]
 800370c:	fa92 f2a2 	rbit	r2, r2
 8003710:	fab2 f282 	clz	r2, r2
 8003714:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003718:	40d3      	lsrs	r3, r2
 800371a:	4904      	ldr	r1, [pc, #16]	; (800372c <HAL_RCC_GetHCLKFreq+0x2c>)
 800371c:	4a04      	ldr	r2, [pc, #16]	; (8003730 <HAL_RCC_GetHCLKFreq+0x30>)
 800371e:	5ccb      	ldrb	r3, [r1, r3]
 8003720:	40d8      	lsrs	r0, r3
 8003722:	6010      	str	r0, [r2, #0]
  return SystemCoreClock;
}
 8003724:	bd08      	pop	{r3, pc}
 8003726:	bf00      	nop
 8003728:	40023800 	.word	0x40023800
 800372c:	080040c0 	.word	0x080040c0
 8003730:	20000864 	.word	0x20000864
	...

08003740 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 8003740:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8003742:	4c0f      	ldr	r4, [pc, #60]	; (8003780 <HAL_RCC_GetPCLK1Freq+0x40>)
 8003744:	f7ff ff9c 	bl	8003680 <HAL_RCC_GetSysClockFreq>
 8003748:	22f0      	movs	r2, #240	; 0xf0
 800374a:	68a3      	ldr	r3, [r4, #8]
 800374c:	fa92 f2a2 	rbit	r2, r2
 8003750:	fab2 f282 	clz	r2, r2
 8003754:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003758:	40d3      	lsrs	r3, r2
 800375a:	490a      	ldr	r1, [pc, #40]	; (8003784 <HAL_RCC_GetPCLK1Freq+0x44>)
 800375c:	4a0a      	ldr	r2, [pc, #40]	; (8003788 <HAL_RCC_GetPCLK1Freq+0x48>)
 800375e:	5ccb      	ldrb	r3, [r1, r3]
 8003760:	40d8      	lsrs	r0, r3
 8003762:	6010      	str	r0, [r2, #0]
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 8003764:	68a3      	ldr	r3, [r4, #8]
 8003766:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 800376a:	fa92 f2a2 	rbit	r2, r2
 800376e:	fab2 f282 	clz	r2, r2
 8003772:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8003776:	40d3      	lsrs	r3, r2
 8003778:	5ccb      	ldrb	r3, [r1, r3]
}
 800377a:	40d8      	lsrs	r0, r3
 800377c:	bd10      	pop	{r4, pc}
 800377e:	bf00      	nop
 8003780:	40023800 	.word	0x40023800
 8003784:	080040c0 	.word	0x080040c0
 8003788:	20000864 	.word	0x20000864
 800378c:	00000000 	.word	0x00000000

08003790 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8003790:	b510      	push	{r4, lr}
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 8003792:	4c0f      	ldr	r4, [pc, #60]	; (80037d0 <HAL_RCC_GetPCLK2Freq+0x40>)
 8003794:	f7ff ff74 	bl	8003680 <HAL_RCC_GetSysClockFreq>
 8003798:	22f0      	movs	r2, #240	; 0xf0
 800379a:	68a3      	ldr	r3, [r4, #8]
 800379c:	fa92 f2a2 	rbit	r2, r2
 80037a0:	fab2 f282 	clz	r2, r2
 80037a4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80037a8:	40d3      	lsrs	r3, r2
 80037aa:	490a      	ldr	r1, [pc, #40]	; (80037d4 <HAL_RCC_GetPCLK2Freq+0x44>)
 80037ac:	4a0a      	ldr	r2, [pc, #40]	; (80037d8 <HAL_RCC_GetPCLK2Freq+0x48>)
 80037ae:	5ccb      	ldrb	r3, [r1, r3]
 80037b0:	40d8      	lsrs	r0, r3
 80037b2:	6010      	str	r0, [r2, #0]
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 80037b4:	68a3      	ldr	r3, [r4, #8]
 80037b6:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 80037ba:	fa92 f2a2 	rbit	r2, r2
 80037be:	fab2 f282 	clz	r2, r2
 80037c2:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 80037c6:	40d3      	lsrs	r3, r2
 80037c8:	5ccb      	ldrb	r3, [r1, r3]
} 
 80037ca:	40d8      	lsrs	r0, r3
 80037cc:	bd10      	pop	{r4, pc}
 80037ce:	bf00      	nop
 80037d0:	40023800 	.word	0x40023800
 80037d4:	080040c0 	.word	0x080040c0
 80037d8:	20000864 	.word	0x20000864
 80037dc:	00000000 	.word	0x00000000

080037e0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80037e0:	e7fe      	b.n	80037e0 <_idle_thread>
 80037e2:	bf00      	nop
	...

080037f0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80037f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80037f2:	4b1f      	ldr	r3, [pc, #124]	; (8003870 <chSysInit+0x80>)
  reg_value  =  (reg_value                                   |
 80037f4:	4a1f      	ldr	r2, [pc, #124]	; (8003874 <chSysInit+0x84>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80037f6:	4e20      	ldr	r6, [pc, #128]	; (8003878 <chSysInit+0x88>)
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80037f8:	4820      	ldr	r0, [pc, #128]	; (800387c <chSysInit+0x8c>)
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80037fa:	4d21      	ldr	r5, [pc, #132]	; (8003880 <chSysInit+0x90>)
  SCB->VTOR = CORTEX_VTOR_INIT;
 80037fc:	2400      	movs	r4, #0
 80037fe:	609c      	str	r4, [r3, #8]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003800:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003802:	f64f 07ff 	movw	r7, #63743	; 0xf8ff
 8003806:	4039      	ands	r1, r7
  reg_value  =  (reg_value                                   |
 8003808:	430a      	orrs	r2, r1
  SCB->AIRCR =  reg_value;
 800380a:	60da      	str	r2, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800380c:	68f2      	ldr	r2, [r6, #12]
 800380e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8003812:	60f2      	str	r2, [r6, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003814:	6802      	ldr	r2, [r0, #0]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003816:	2120      	movs	r1, #32
 8003818:	f042 0201 	orr.w	r2, r2, #1
 800381c:	2610      	movs	r6, #16
 800381e:	6002      	str	r2, [r0, #0]
void chSysInit(void) {
 8003820:	b083      	sub	sp, #12
 8003822:	77de      	strb	r6, [r3, #31]
 8003824:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  _scheduler_init();
 8003828:	f000 f8e2 	bl	80039f0 <_scheduler_init>
  _vt_init();
 800382c:	f000 f860 	bl	80038f0 <_vt_init>
  _core_init();
 8003830:	f000 faee 	bl	8003e10 <_core_init>
  _heap_init();
 8003834:	f000 fb24 	bl	8003e80 <_heap_init>
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8003838:	4628      	mov	r0, r5
 800383a:	2140      	movs	r1, #64	; 0x40
 800383c:	f000 f9f0 	bl	8003c20 <_thread_init>
 8003840:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8003844:	2201      	movs	r2, #1
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8003846:	6198      	str	r0, [r3, #24]
  currp->p_state = CH_STATE_CURRENT;
 8003848:	7702      	strb	r2, [r0, #28]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800384a:	f384 8811 	msr	BASEPRI, r4
  __ASM volatile ("cpsie i" : : : "memory");
 800384e:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8003850:	699b      	ldr	r3, [r3, #24]
 8003852:	490c      	ldr	r1, [pc, #48]	; (8003884 <chSysInit+0x94>)
 8003854:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8003856:	f105 0048 	add.w	r0, r5, #72	; 0x48
 800385a:	9400      	str	r4, [sp, #0]
 800385c:	4b0a      	ldr	r3, [pc, #40]	; (8003888 <chSysInit+0x98>)
 800385e:	f44f 71b0 	mov.w	r1, #352	; 0x160
 8003862:	f000 f9fd 	bl	8003c60 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8003866:	4b09      	ldr	r3, [pc, #36]	; (800388c <chSysInit+0x9c>)
 8003868:	6183      	str	r3, [r0, #24]
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
  }
#endif
}
 800386a:	b003      	add	sp, #12
 800386c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800386e:	bf00      	nop
 8003870:	e000ed00 	.word	0xe000ed00
 8003874:	05fa0300 	.word	0x05fa0300
 8003878:	e000edf0 	.word	0xe000edf0
 800387c:	e0001000 	.word	0xe0001000
 8003880:	20001310 	.word	0x20001310
 8003884:	080040d0 	.word	0x080040d0
 8003888:	080037e1 	.word	0x080037e1
 800388c:	08004070 	.word	0x08004070

08003890 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8003890:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 8003892:	4c12      	ldr	r4, [pc, #72]	; (80038dc <chSysTimerHandlerI+0x4c>)
 8003894:	69a2      	ldr	r2, [r4, #24]
 8003896:	7fd3      	ldrb	r3, [r2, #31]
 8003898:	b10b      	cbz	r3, 800389e <chSysTimerHandlerI+0xe>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800389a:	3b01      	subs	r3, #1
 800389c:	77d3      	strb	r3, [r2, #31]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 800389e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80038a0:	69e2      	ldr	r2, [r4, #28]
 80038a2:	4e0f      	ldr	r6, [pc, #60]	; (80038e0 <chSysTimerHandlerI+0x50>)
  ch.vtlist.vt_systime++;
 80038a4:	3301      	adds	r3, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80038a6:	42b2      	cmp	r2, r6
  ch.vtlist.vt_systime++;
 80038a8:	62a3      	str	r3, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80038aa:	d016      	beq.n	80038da <chSysTimerHandlerI+0x4a>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 80038ac:	6893      	ldr	r3, [r2, #8]
 80038ae:	3b01      	subs	r3, #1
 80038b0:	6093      	str	r3, [r2, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 80038b2:	69e3      	ldr	r3, [r4, #28]
 80038b4:	689d      	ldr	r5, [r3, #8]
 80038b6:	b985      	cbnz	r5, 80038da <chSysTimerHandlerI+0x4a>
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80038b8:	2720      	movs	r7, #32
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80038ba:	6819      	ldr	r1, [r3, #0]
      fn = vtp->vt_func;
 80038bc:	68da      	ldr	r2, [r3, #12]
      vtp->vt_func = NULL;
 80038be:	60dd      	str	r5, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80038c0:	604e      	str	r6, [r1, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 80038c2:	6819      	ldr	r1, [r3, #0]
 80038c4:	61e1      	str	r1, [r4, #28]
 80038c6:	f385 8811 	msr	BASEPRI, r5
      chSysUnlockFromISR();
      fn(vtp->vt_par);
 80038ca:	6918      	ldr	r0, [r3, #16]
 80038cc:	4790      	blx	r2
 80038ce:	f387 8811 	msr	BASEPRI, r7
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 80038d2:	69e3      	ldr	r3, [r4, #28]
 80038d4:	689a      	ldr	r2, [r3, #8]
 80038d6:	2a00      	cmp	r2, #0
 80038d8:	d0ef      	beq.n	80038ba <chSysTimerHandlerI+0x2a>
 80038da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80038dc:	200012e0 	.word	0x200012e0
 80038e0:	200012fc 	.word	0x200012fc
	...

080038f0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80038f0:	4b05      	ldr	r3, [pc, #20]	; (8003908 <_vt_init+0x18>)
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 80038f2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 80038f6:	f103 021c 	add.w	r2, r3, #28
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 80038fa:	2100      	movs	r1, #0
  ch.vtlist.vt_delta = (systime_t)-1;
 80038fc:	6258      	str	r0, [r3, #36]	; 0x24
  ch.vtlist.vt_systime = (systime_t)0;
 80038fe:	6299      	str	r1, [r3, #40]	; 0x28
  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8003900:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003902:	621a      	str	r2, [r3, #32]
 8003904:	4770      	bx	lr
 8003906:	bf00      	nop
 8003908:	200012e0 	.word	0x200012e0
 800390c:	00000000 	.word	0x00000000

08003910 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8003910:	b410      	push	{r4}
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8003912:	4c0d      	ldr	r4, [pc, #52]	; (8003948 <chVTDoSetI+0x38>)
  vtp->vt_par = par;
 8003914:	6103      	str	r3, [r0, #16]
  vtp->vt_func = vtfunc;
 8003916:	60c2      	str	r2, [r0, #12]
  p = ch.vtlist.vt_next;
 8003918:	69e3      	ldr	r3, [r4, #28]
  while (p->vt_delta < delta) {
 800391a:	689a      	ldr	r2, [r3, #8]
 800391c:	4291      	cmp	r1, r2
 800391e:	d904      	bls.n	800392a <chVTDoSetI+0x1a>
    delta -= p->vt_delta;
    p = p->vt_next;
 8003920:	681b      	ldr	r3, [r3, #0]
    delta -= p->vt_delta;
 8003922:	1a89      	subs	r1, r1, r2
  while (p->vt_delta < delta) {
 8003924:	689a      	ldr	r2, [r3, #8]
 8003926:	428a      	cmp	r2, r1
 8003928:	d3fa      	bcc.n	8003920 <chVTDoSetI+0x10>
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800392a:	6003      	str	r3, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800392c:	685a      	ldr	r2, [r3, #4]
 800392e:	6042      	str	r2, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
 8003930:	6010      	str	r0, [r2, #0]
  p->vt_prev = vtp;
 8003932:	6058      	str	r0, [r3, #4]
  vtp->vt_delta = delta
 8003934:	6081      	str	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8003936:	689a      	ldr	r2, [r3, #8]
 8003938:	1a51      	subs	r1, r2, r1
 800393a:	6099      	str	r1, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800393c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003940:	6260      	str	r0, [r4, #36]	; 0x24
}
 8003942:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003946:	4770      	bx	lr
 8003948:	200012e0 	.word	0x200012e0
 800394c:	00000000 	.word	0x00000000

08003950 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8003950:	b410      	push	{r4}
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8003952:	6802      	ldr	r2, [r0, #0]
 8003954:	6884      	ldr	r4, [r0, #8]
 8003956:	6893      	ldr	r3, [r2, #8]
  vtp->vt_next->vt_prev = vtp->vt_prev;
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8003958:	4908      	ldr	r1, [pc, #32]	; (800397c <chVTDoResetI+0x2c>)
  vtp->vt_next->vt_delta += vtp->vt_delta;
 800395a:	4423      	add	r3, r4
 800395c:	6093      	str	r3, [r2, #8]
  vtp->vt_prev->vt_next = vtp->vt_next;
 800395e:	e890 000c 	ldmia.w	r0, {r2, r3}
 8003962:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8003964:	6803      	ldr	r3, [r0, #0]
 8003966:	6842      	ldr	r2, [r0, #4]
 8003968:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 800396a:	2200      	movs	r2, #0
  ch.vtlist.vt_delta = (systime_t)-1;
 800396c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  vtp->vt_func = NULL;
 8003970:	60c2      	str	r2, [r0, #12]
  ch.vtlist.vt_delta = (systime_t)-1;
 8003972:	624b      	str	r3, [r1, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003974:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003978:	4770      	bx	lr
 800397a:	bf00      	nop
 800397c:	200012e0 	.word	0x200012e0

08003980 <wakeup>:
 8003980:	2320      	movs	r3, #32
 8003982:	f383 8811 	msr	BASEPRI, r3
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8003986:	7f03      	ldrb	r3, [r0, #28]
 8003988:	2b07      	cmp	r3, #7
 800398a:	d80f      	bhi.n	80039ac <wakeup+0x2c>
 800398c:	e8df f003 	tbb	[pc, r3]
 8003990:	250e0e29 	.word	0x250e0e29
 8003994:	080e0408 	.word	0x080e0408
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8003998:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800399a:	6893      	ldr	r3, [r2, #8]
 800399c:	3301      	adds	r3, #1
 800399e:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80039a0:	e890 000c 	ldmia.w	r0, {r2, r3}
 80039a4:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80039a6:	6803      	ldr	r3, [r0, #0]
 80039a8:	6842      	ldr	r2, [r0, #4]
 80039aa:	605a      	str	r2, [r3, #4]
static void wakeup(void *p) {
 80039ac:	b410      	push	{r4}
  tp->p_state = CH_STATE_READY;
 80039ae:	2200      	movs	r2, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80039b0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80039b4:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80039b6:	4b0d      	ldr	r3, [pc, #52]	; (80039ec <wakeup+0x6c>)
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80039b8:	6204      	str	r4, [r0, #32]
  tp->p_state = CH_STATE_READY;
 80039ba:	7702      	strb	r2, [r0, #28]
    cp = cp->p_next;
 80039bc:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80039be:	689a      	ldr	r2, [r3, #8]
 80039c0:	428a      	cmp	r2, r1
 80039c2:	d2fb      	bcs.n	80039bc <wakeup+0x3c>
  tp->p_next = cp;
 80039c4:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80039c6:	685a      	ldr	r2, [r3, #4]
 80039c8:	6042      	str	r2, [r0, #4]
 80039ca:	2100      	movs	r1, #0
  tp->p_prev->p_next = tp;
 80039cc:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80039ce:	6058      	str	r0, [r3, #4]
 80039d0:	f381 8811 	msr	BASEPRI, r1
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80039d4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80039d8:	4770      	bx	lr
    *tp->p_u.wttrp = NULL;
 80039da:	6a03      	ldr	r3, [r0, #32]
 80039dc:	2200      	movs	r2, #0
 80039de:	601a      	str	r2, [r3, #0]
    break;
 80039e0:	e7e4      	b.n	80039ac <wakeup+0x2c>
 80039e2:	2300      	movs	r3, #0
 80039e4:	f383 8811 	msr	BASEPRI, r3
 80039e8:	4770      	bx	lr
 80039ea:	bf00      	nop
 80039ec:	200012e0 	.word	0x200012e0

080039f0 <_scheduler_init>:
  tqp->p_next = (thread_t *)tqp;
 80039f0:	4b03      	ldr	r3, [pc, #12]	; (8003a00 <_scheduler_init+0x10>)
  ch.rlist.r_prio = NOPRIO;
 80039f2:	2200      	movs	r2, #0
 80039f4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80039f6:	605b      	str	r3, [r3, #4]
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 80039f8:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 80039fa:	615b      	str	r3, [r3, #20]
  ch.rlist.r_prio = NOPRIO;
 80039fc:	609a      	str	r2, [r3, #8]
 80039fe:	4770      	bx	lr
 8003a00:	200012e0 	.word	0x200012e0
	...

08003a10 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8003a10:	b410      	push	{r4}
  tp->p_state = CH_STATE_READY;
 8003a12:	2200      	movs	r2, #0
 8003a14:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8003a16:	4b08      	ldr	r3, [pc, #32]	; (8003a38 <chSchReadyI+0x28>)
  tp->p_state = CH_STATE_READY;
 8003a18:	7702      	strb	r2, [r0, #28]
thread_t *chSchReadyI(thread_t *tp) {
 8003a1a:	4604      	mov	r4, r0
    cp = cp->p_next;
 8003a1c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003a1e:	689a      	ldr	r2, [r3, #8]
 8003a20:	428a      	cmp	r2, r1
 8003a22:	d2fb      	bcs.n	8003a1c <chSchReadyI+0xc>
  tp->p_next = cp;
 8003a24:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8003a26:	685a      	ldr	r2, [r3, #4]
 8003a28:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 8003a2a:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8003a2c:	605c      	str	r4, [r3, #4]
}
 8003a2e:	4620      	mov	r0, r4
 8003a30:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003a34:	4770      	bx	lr
 8003a36:	bf00      	nop
 8003a38:	200012e0 	.word	0x200012e0
 8003a3c:	00000000 	.word	0x00000000

08003a40 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8003a40:	b410      	push	{r4}
  otp = currp;
 8003a42:	4b08      	ldr	r3, [pc, #32]	; (8003a64 <chSchGoSleepS+0x24>)
 8003a44:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->p_next;
 8003a46:	681a      	ldr	r2, [r3, #0]
  otp->p_state = newstate;
 8003a48:	7708      	strb	r0, [r1, #28]
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8003a4a:	200a      	movs	r0, #10
 8003a4c:	77c8      	strb	r0, [r1, #31]
  tqp->p_next = tp->p_next;
 8003a4e:	6810      	ldr	r0, [r2, #0]
 8003a50:	6018      	str	r0, [r3, #0]
  currp->p_state = CH_STATE_CURRENT;
 8003a52:	2401      	movs	r4, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003a54:	6043      	str	r3, [r0, #4]
 8003a56:	7714      	strb	r4, [r2, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003a58:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 8003a5a:	4610      	mov	r0, r2
}
 8003a5c:	f85d 4b04 	ldr.w	r4, [sp], #4
  chSysSwitch(currp, otp);
 8003a60:	f7fc bc1e 	b.w	80002a0 <_port_switch>
 8003a64:	200012e0 	.word	0x200012e0
	...

08003a70 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003a70:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8003a72:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003a74:	b087      	sub	sp, #28
 8003a76:	4605      	mov	r5, r0
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8003a78:	4c17      	ldr	r4, [pc, #92]	; (8003ad8 <chSchGoSleepTimeoutS+0x68>)
  if (TIME_INFINITE != time) {
 8003a7a:	d01b      	beq.n	8003ab4 <chSchGoSleepTimeoutS+0x44>
    chVTDoSetI(&vt, time, wakeup, currp);
 8003a7c:	4a17      	ldr	r2, [pc, #92]	; (8003adc <chSchGoSleepTimeoutS+0x6c>)
 8003a7e:	69a3      	ldr	r3, [r4, #24]
 8003a80:	a801      	add	r0, sp, #4
 8003a82:	f7ff ff45 	bl	8003910 <chVTDoSetI>
  otp = currp;
 8003a86:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->p_next;
 8003a88:	6823      	ldr	r3, [r4, #0]
  otp->p_state = newstate;
 8003a8a:	770d      	strb	r5, [r1, #28]
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8003a8c:	220a      	movs	r2, #10
 8003a8e:	77ca      	strb	r2, [r1, #31]
  tqp->p_next = tp->p_next;
 8003a90:	681a      	ldr	r2, [r3, #0]
 8003a92:	6022      	str	r2, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
 8003a94:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003a96:	6054      	str	r4, [r2, #4]
  chSysSwitch(currp, otp);
 8003a98:	4618      	mov	r0, r3
  currp->p_state = CH_STATE_CURRENT;
 8003a9a:	771d      	strb	r5, [r3, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003a9c:	61a3      	str	r3, [r4, #24]
  chSysSwitch(currp, otp);
 8003a9e:	f7fc fbff 	bl	80002a0 <_port_switch>
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8003aa2:	9b04      	ldr	r3, [sp, #16]
 8003aa4:	b113      	cbz	r3, 8003aac <chSchGoSleepTimeoutS+0x3c>
      chVTDoResetI(&vt);
 8003aa6:	a801      	add	r0, sp, #4
 8003aa8:	f7ff ff52 	bl	8003950 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8003aac:	69a3      	ldr	r3, [r4, #24]
}
 8003aae:	6a18      	ldr	r0, [r3, #32]
 8003ab0:	b007      	add	sp, #28
 8003ab2:	bd30      	pop	{r4, r5, pc}
  otp = currp;
 8003ab4:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->p_next;
 8003ab6:	6823      	ldr	r3, [r4, #0]
  otp->p_state = newstate;
 8003ab8:	7708      	strb	r0, [r1, #28]
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8003aba:	220a      	movs	r2, #10
 8003abc:	77ca      	strb	r2, [r1, #31]
  tqp->p_next = tp->p_next;
 8003abe:	681a      	ldr	r2, [r3, #0]
 8003ac0:	6022      	str	r2, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
 8003ac2:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003ac4:	6054      	str	r4, [r2, #4]
  chSysSwitch(currp, otp);
 8003ac6:	4618      	mov	r0, r3
  currp->p_state = CH_STATE_CURRENT;
 8003ac8:	771d      	strb	r5, [r3, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003aca:	61a3      	str	r3, [r4, #24]
  chSysSwitch(currp, otp);
 8003acc:	f7fc fbe8 	bl	80002a0 <_port_switch>
  return currp->p_u.rdymsg;
 8003ad0:	69a3      	ldr	r3, [r4, #24]
}
 8003ad2:	6a18      	ldr	r0, [r3, #32]
 8003ad4:	b007      	add	sp, #28
 8003ad6:	bd30      	pop	{r4, r5, pc}
 8003ad8:	200012e0 	.word	0x200012e0
 8003adc:	08003981 	.word	0x08003981

08003ae0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003ae0:	b470      	push	{r4, r5, r6}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003ae2:	4b14      	ldr	r3, [pc, #80]	; (8003b34 <chSchWakeupS+0x54>)
  ntp->p_u.rdymsg = msg;
 8003ae4:	6201      	str	r1, [r0, #32]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003ae6:	4604      	mov	r4, r0
  if (ntp->p_prio <= currp->p_prio) {
 8003ae8:	699d      	ldr	r5, [r3, #24]
 8003aea:	68a1      	ldr	r1, [r4, #8]
 8003aec:	68a8      	ldr	r0, [r5, #8]
 8003aee:	4281      	cmp	r1, r0
  tp->p_state = CH_STATE_READY;
 8003af0:	f04f 0200 	mov.w	r2, #0
  if (ntp->p_prio <= currp->p_prio) {
 8003af4:	d80b      	bhi.n	8003b0e <chSchWakeupS+0x2e>
  tp->p_state = CH_STATE_READY;
 8003af6:	7722      	strb	r2, [r4, #28]
    cp = cp->p_next;
 8003af8:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003afa:	689a      	ldr	r2, [r3, #8]
 8003afc:	4291      	cmp	r1, r2
 8003afe:	d9fb      	bls.n	8003af8 <chSchWakeupS+0x18>
  tp->p_next = cp;
 8003b00:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8003b02:	685a      	ldr	r2, [r3, #4]
 8003b04:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 8003b06:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8003b08:	605c      	str	r4, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8003b0a:	bc70      	pop	{r4, r5, r6}
 8003b0c:	4770      	bx	lr
  tp->p_state = CH_STATE_READY;
 8003b0e:	772a      	strb	r2, [r5, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8003b10:	461a      	mov	r2, r3
    cp = cp->p_next;
 8003b12:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003b14:	6891      	ldr	r1, [r2, #8]
 8003b16:	4288      	cmp	r0, r1
 8003b18:	d9fb      	bls.n	8003b12 <chSchWakeupS+0x32>
  tp->p_next = cp;
 8003b1a:	602a      	str	r2, [r5, #0]
  tp->p_prev = cp->p_prev;
 8003b1c:	6851      	ldr	r1, [r2, #4]
 8003b1e:	6069      	str	r1, [r5, #4]
    ntp->p_state = CH_STATE_CURRENT;
 8003b20:	2601      	movs	r6, #1
  tp->p_prev->p_next = tp;
 8003b22:	600d      	str	r5, [r1, #0]
  cp->p_prev = tp;
 8003b24:	6055      	str	r5, [r2, #4]
    ntp->p_state = CH_STATE_CURRENT;
 8003b26:	7726      	strb	r6, [r4, #28]
    setcurrp(ntp);
 8003b28:	619c      	str	r4, [r3, #24]
    chSysSwitch(ntp, otp);
 8003b2a:	4629      	mov	r1, r5
 8003b2c:	4620      	mov	r0, r4
}
 8003b2e:	bc70      	pop	{r4, r5, r6}
    chSysSwitch(ntp, otp);
 8003b30:	f7fc bbb6 	b.w	80002a0 <_port_switch>
 8003b34:	200012e0 	.word	0x200012e0
	...

08003b40 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8003b40:	b410      	push	{r4}
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8003b42:	4c11      	ldr	r4, [pc, #68]	; (8003b88 <chSchRescheduleS+0x48>)
 8003b44:	6822      	ldr	r2, [r4, #0]
 8003b46:	69a1      	ldr	r1, [r4, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8003b48:	6890      	ldr	r0, [r2, #8]
 8003b4a:	688b      	ldr	r3, [r1, #8]
 8003b4c:	4298      	cmp	r0, r3
 8003b4e:	d802      	bhi.n	8003b56 <chSchRescheduleS+0x16>
    chSchDoRescheduleAhead();
  }
}
 8003b50:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003b54:	4770      	bx	lr
  tqp->p_next = tp->p_next;
 8003b56:	6813      	ldr	r3, [r2, #0]
 8003b58:	6023      	str	r3, [r4, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8003b5a:	2001      	movs	r0, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003b5c:	605c      	str	r4, [r3, #4]
 8003b5e:	7710      	strb	r0, [r2, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003b60:	61a2      	str	r2, [r4, #24]

  otp->p_state = CH_STATE_READY;
 8003b62:	2200      	movs	r2, #0
 8003b64:	6888      	ldr	r0, [r1, #8]
 8003b66:	770a      	strb	r2, [r1, #28]
 8003b68:	e000      	b.n	8003b6c <chSchRescheduleS+0x2c>
 8003b6a:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 8003b6c:	689a      	ldr	r2, [r3, #8]
 8003b6e:	4290      	cmp	r0, r2
 8003b70:	d3fb      	bcc.n	8003b6a <chSchRescheduleS+0x2a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8003b72:	600b      	str	r3, [r1, #0]
  otp->p_prev = cp->p_prev;
 8003b74:	685a      	ldr	r2, [r3, #4]
 8003b76:	604a      	str	r2, [r1, #4]
  otp->p_prev->p_next = otp;
 8003b78:	6011      	str	r1, [r2, #0]
  cp->p_prev = otp;
 8003b7a:	6059      	str	r1, [r3, #4]

  chSysSwitch(currp, otp);
 8003b7c:	69a0      	ldr	r0, [r4, #24]
}
 8003b7e:	f85d 4b04 	ldr.w	r4, [sp], #4
  chSysSwitch(currp, otp);
 8003b82:	f7fc bb8d 	b.w	80002a0 <_port_switch>
 8003b86:	bf00      	nop
 8003b88:	200012e0 	.word	0x200012e0
 8003b8c:	00000000 	.word	0x00000000

08003b90 <chSchIsPreemptionRequired>:
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8003b90:	4a08      	ldr	r2, [pc, #32]	; (8003bb4 <chSchIsPreemptionRequired+0x24>)
  tprio_t p2 = currp->p_prio;
 8003b92:	6993      	ldr	r3, [r2, #24]
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8003b94:	6811      	ldr	r1, [r2, #0]
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8003b96:	7fda      	ldrb	r2, [r3, #31]
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8003b98:	6888      	ldr	r0, [r1, #8]
  tprio_t p2 = currp->p_prio;
 8003b9a:	689b      	ldr	r3, [r3, #8]
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8003b9c:	b922      	cbnz	r2, 8003ba8 <chSchIsPreemptionRequired+0x18>
 8003b9e:	4298      	cmp	r0, r3
 8003ba0:	bf34      	ite	cc
 8003ba2:	2000      	movcc	r0, #0
 8003ba4:	2001      	movcs	r0, #1
}
 8003ba6:	4770      	bx	lr
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8003ba8:	4298      	cmp	r0, r3
 8003baa:	bf94      	ite	ls
 8003bac:	2000      	movls	r0, #0
 8003bae:	2001      	movhi	r0, #1
 8003bb0:	4770      	bx	lr
 8003bb2:	bf00      	nop
 8003bb4:	200012e0 	.word	0x200012e0
	...

08003bc0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8003bc0:	b430      	push	{r4, r5}

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 8003bc2:	4c16      	ldr	r4, [pc, #88]	; (8003c1c <chSchDoReschedule+0x5c>)
 8003bc4:	69a1      	ldr	r1, [r4, #24]
 8003bc6:	7fca      	ldrb	r2, [r1, #31]
 8003bc8:	b1ba      	cbz	r2, 8003bfa <chSchDoReschedule+0x3a>
  thread_t *tp = tqp->p_next;
 8003bca:	6822      	ldr	r2, [r4, #0]
  tqp->p_next = tp->p_next;
 8003bcc:	6813      	ldr	r3, [r2, #0]
 8003bce:	6023      	str	r3, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
 8003bd0:	2001      	movs	r0, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003bd2:	605c      	str	r4, [r3, #4]
 8003bd4:	7710      	strb	r0, [r2, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003bd6:	61a2      	str	r2, [r4, #24]
  otp->p_state = CH_STATE_READY;
 8003bd8:	2200      	movs	r2, #0
 8003bda:	6888      	ldr	r0, [r1, #8]
 8003bdc:	770a      	strb	r2, [r1, #28]
 8003bde:	e000      	b.n	8003be2 <chSchDoReschedule+0x22>
 8003be0:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio > otp->p_prio);
 8003be2:	689a      	ldr	r2, [r3, #8]
 8003be4:	4282      	cmp	r2, r0
 8003be6:	d8fb      	bhi.n	8003be0 <chSchDoReschedule+0x20>
  otp->p_next = cp;
 8003be8:	600b      	str	r3, [r1, #0]
  otp->p_prev = cp->p_prev;
 8003bea:	685a      	ldr	r2, [r3, #4]
 8003bec:	604a      	str	r2, [r1, #4]
  otp->p_prev->p_next = otp;
 8003bee:	6011      	str	r1, [r2, #0]
  cp->p_prev = otp;
 8003bf0:	6059      	str	r1, [r3, #4]
  chSysSwitch(currp, otp);
 8003bf2:	69a0      	ldr	r0, [r4, #24]
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8003bf4:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
 8003bf6:	f7fc bb53 	b.w	80002a0 <_port_switch>
  thread_t *tp = tqp->p_next;
 8003bfa:	6820      	ldr	r0, [r4, #0]
  tqp->p_next = tp->p_next;
 8003bfc:	6803      	ldr	r3, [r0, #0]
 8003bfe:	6023      	str	r3, [r4, #0]
  currp->p_state = CH_STATE_CURRENT;
 8003c00:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003c02:	605c      	str	r4, [r3, #4]
 8003c04:	7705      	strb	r5, [r0, #28]
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8003c06:	61a0      	str	r0, [r4, #24]
  tp->p_state = CH_STATE_READY;
 8003c08:	770a      	strb	r2, [r1, #28]
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8003c0a:	220a      	movs	r2, #10
 8003c0c:	6888      	ldr	r0, [r1, #8]
 8003c0e:	77ca      	strb	r2, [r1, #31]
 8003c10:	e000      	b.n	8003c14 <chSchDoReschedule+0x54>
 8003c12:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8003c14:	689a      	ldr	r2, [r3, #8]
 8003c16:	4290      	cmp	r0, r2
 8003c18:	d9fb      	bls.n	8003c12 <chSchDoReschedule+0x52>
 8003c1a:	e7e5      	b.n	8003be8 <chSchDoReschedule+0x28>
 8003c1c:	200012e0 	.word	0x200012e0

08003c20 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8003c20:	b4f0      	push	{r4, r5, r6, r7}
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003c22:	4a0b      	ldr	r2, [pc, #44]	; (8003c50 <_thread_init+0x30>)
  tp->p_prio = prio;
 8003c24:	6081      	str	r1, [r0, #8]
  REG_INSERT(tp);
 8003c26:	6102      	str	r2, [r0, #16]
 8003c28:	6955      	ldr	r5, [r2, #20]
  tp->p_state = CH_STATE_WTSTART;
 8003c2a:	4f0a      	ldr	r7, [pc, #40]	; (8003c54 <_thread_init+0x34>)
  tp->p_realprio = prio;
 8003c2c:	63c1      	str	r1, [r0, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8003c2e:	2100      	movs	r1, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8003c30:	f100 0428 	add.w	r4, r0, #40	; 0x28
  REG_INSERT(tp);
 8003c34:	6145      	str	r5, [r0, #20]
  list_init(&tp->p_waiting);
 8003c36:	f100 0624 	add.w	r6, r0, #36	; 0x24
  tp->p_state = CH_STATE_WTSTART;
 8003c3a:	61c7      	str	r7, [r0, #28]
  tp->p_mtxlist = NULL;
 8003c3c:	6381      	str	r1, [r0, #56]	; 0x38
  tp->p_epending = (eventmask_t)0;
 8003c3e:	6341      	str	r1, [r0, #52]	; 0x34
  tp->p_name = NULL;
 8003c40:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
 8003c42:	6128      	str	r0, [r5, #16]
 8003c44:	6150      	str	r0, [r2, #20]
  tlp->p_next = (thread_t *)tlp;
 8003c46:	6246      	str	r6, [r0, #36]	; 0x24
  tqp->p_next = (thread_t *)tqp;
 8003c48:	6284      	str	r4, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8003c4a:	62c4      	str	r4, [r0, #44]	; 0x2c
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
}
 8003c4c:	bcf0      	pop	{r4, r5, r6, r7}
 8003c4e:	4770      	bx	lr
 8003c50:	200012e0 	.word	0x200012e0
 8003c54:	0a010002 	.word	0x0a010002
	...

08003c60 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8003c60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c62:	9e06      	ldr	r6, [sp, #24]
 8003c64:	4604      	mov	r4, r0
 8003c66:	2520      	movs	r5, #32
 8003c68:	f385 8811 	msr	BASEPRI, r5
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003c6c:	3964      	subs	r1, #100	; 0x64
 8003c6e:	4401      	add	r1, r0
 8003c70:	60c1      	str	r1, [r0, #12]
 8003c72:	640b      	str	r3, [r1, #64]	; 0x40
 8003c74:	68c3      	ldr	r3, [r0, #12]
 8003c76:	4d10      	ldr	r5, [pc, #64]	; (8003cb8 <chThdCreateStatic+0x58>)
 8003c78:	645e      	str	r6, [r3, #68]	; 0x44
 8003c7a:	68c1      	ldr	r1, [r0, #12]
  REG_INSERT(tp);
 8003c7c:	4b0f      	ldr	r3, [pc, #60]	; (8003cbc <chThdCreateStatic+0x5c>)
  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8003c7e:	660d      	str	r5, [r1, #96]	; 0x60
  tp->p_prio = prio;
 8003c80:	6082      	str	r2, [r0, #8]
  REG_INSERT(tp);
 8003c82:	6103      	str	r3, [r0, #16]
 8003c84:	6959      	ldr	r1, [r3, #20]
  tp->p_realprio = prio;
 8003c86:	63c2      	str	r2, [r0, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8003c88:	2500      	movs	r5, #0
  queue_init(&tp->p_msgqueue);
 8003c8a:	f100 0228 	add.w	r2, r0, #40	; 0x28
  list_init(&tp->p_waiting);
 8003c8e:	f100 0624 	add.w	r6, r0, #36	; 0x24
  tp->p_state = CH_STATE_WTSTART;
 8003c92:	4f0b      	ldr	r7, [pc, #44]	; (8003cc0 <chThdCreateStatic+0x60>)
  REG_INSERT(tp);
 8003c94:	6141      	str	r1, [r0, #20]
  tp->p_state = CH_STATE_WTSTART;
 8003c96:	61c7      	str	r7, [r0, #28]
  tp->p_mtxlist = NULL;
 8003c98:	6385      	str	r5, [r0, #56]	; 0x38
  tp->p_epending = (eventmask_t)0;
 8003c9a:	6345      	str	r5, [r0, #52]	; 0x34
  tp->p_name = NULL;
 8003c9c:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 8003c9e:	6108      	str	r0, [r1, #16]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8003ca0:	4629      	mov	r1, r5
  tlp->p_next = (thread_t *)tlp;
 8003ca2:	6246      	str	r6, [r0, #36]	; 0x24
  tqp->p_next = (thread_t *)tqp;
 8003ca4:	6282      	str	r2, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8003ca6:	62c2      	str	r2, [r0, #44]	; 0x2c
  REG_INSERT(tp);
 8003ca8:	6158      	str	r0, [r3, #20]
  chSchWakeupS(tp, MSG_OK);
 8003caa:	f7ff ff19 	bl	8003ae0 <chSchWakeupS>
 8003cae:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8003cb2:	4620      	mov	r0, r4
 8003cb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003cb6:	bf00      	nop
 8003cb8:	080002b9 	.word	0x080002b9
 8003cbc:	200012e0 	.word	0x200012e0
 8003cc0:	0a010002 	.word	0x0a010002
	...

08003cd0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8003cd0:	b510      	push	{r4, lr}
 8003cd2:	4602      	mov	r2, r0
 8003cd4:	2320      	movs	r3, #32
 8003cd6:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 8003cda:	4809      	ldr	r0, [pc, #36]	; (8003d00 <chThdSetPriority+0x30>)
 8003cdc:	6983      	ldr	r3, [r0, #24]
 8003cde:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8003ce0:	6899      	ldr	r1, [r3, #8]
 8003ce2:	428c      	cmp	r4, r1
 8003ce4:	d001      	beq.n	8003cea <chThdSetPriority+0x1a>
 8003ce6:	4291      	cmp	r1, r2
 8003ce8:	d201      	bcs.n	8003cee <chThdSetPriority+0x1e>
    currp->p_prio = newprio;
 8003cea:	609a      	str	r2, [r3, #8]
 8003cec:	6983      	ldr	r3, [r0, #24]
  }
  currp->p_realprio = newprio;
 8003cee:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 8003cf0:	f7ff ff26 	bl	8003b40 <chSchRescheduleS>
 8003cf4:	2300      	movs	r3, #0
 8003cf6:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8003cfa:	4620      	mov	r0, r4
 8003cfc:	bd10      	pop	{r4, pc}
 8003cfe:	bf00      	nop
 8003d00:	200012e0 	.word	0x200012e0
	...

08003d10 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8003d10:	b508      	push	{r3, lr}
 8003d12:	4601      	mov	r1, r0
 8003d14:	2320      	movs	r3, #32
 8003d16:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003d1a:	2008      	movs	r0, #8
 8003d1c:	f7ff fea8 	bl	8003a70 <chSchGoSleepTimeoutS>
 8003d20:	2300      	movs	r3, #0
 8003d22:	f383 8811 	msr	BASEPRI, r3
 8003d26:	bd08      	pop	{r3, pc}
	...

08003d30 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8003d30:	b538      	push	{r3, r4, r5, lr}
 8003d32:	2220      	movs	r2, #32
 8003d34:	4603      	mov	r3, r0
 8003d36:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8003d3a:	4a0e      	ldr	r2, [pc, #56]	; (8003d74 <chThdExit+0x44>)
 8003d3c:	6994      	ldr	r4, [r2, #24]
  return (bool)(tlp->p_next != (thread_t *)tlp);
 8003d3e:	6a60      	ldr	r0, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8003d40:	6223      	str	r3, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8003d42:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8003d46:	42a8      	cmp	r0, r5
 8003d48:	d006      	beq.n	8003d58 <chThdExit+0x28>
  tlp->p_next = tp->p_next;
 8003d4a:	6803      	ldr	r3, [r0, #0]
 8003d4c:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8003d4e:	f7ff fe5f 	bl	8003a10 <chSchReadyI>
  return (bool)(tlp->p_next != (thread_t *)tlp);
 8003d52:	6a60      	ldr	r0, [r4, #36]	; 0x24
  while (list_notempty(&tp->p_waiting)) {
 8003d54:	42a8      	cmp	r0, r5
 8003d56:	d1f8      	bne.n	8003d4a <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8003d58:	7f63      	ldrb	r3, [r4, #29]
 8003d5a:	079b      	lsls	r3, r3, #30
 8003d5c:	d105      	bne.n	8003d6a <chThdExit+0x3a>
    REG_REMOVE(tp);
 8003d5e:	6963      	ldr	r3, [r4, #20]
 8003d60:	6922      	ldr	r2, [r4, #16]
 8003d62:	611a      	str	r2, [r3, #16]
 8003d64:	6923      	ldr	r3, [r4, #16]
 8003d66:	6962      	ldr	r2, [r4, #20]
 8003d68:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8003d6a:	200f      	movs	r0, #15
}
 8003d6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8003d70:	f7ff be66 	b.w	8003a40 <chSchGoSleepS>
 8003d74:	200012e0 	.word	0x200012e0
	...

08003d80 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8003d80:	2300      	movs	r3, #0
  tqp->p_next = (thread_t *)tqp;
 8003d82:	6000      	str	r0, [r0, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003d84:	6040      	str	r0, [r0, #4]
 8003d86:	6083      	str	r3, [r0, #8]
 8003d88:	4770      	bx	lr
 8003d8a:	bf00      	nop
 8003d8c:	0000      	movs	r0, r0
	...

08003d90 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8003d90:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003d92:	7f02      	ldrb	r2, [r0, #28]
  tp->p_epending |= events;
 8003d94:	4319      	orrs	r1, r3
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003d96:	2a0a      	cmp	r2, #10
  tp->p_epending |= events;
 8003d98:	6341      	str	r1, [r0, #52]	; 0x34
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003d9a:	d009      	beq.n	8003db0 <chEvtSignalI+0x20>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8003d9c:	2a0b      	cmp	r2, #11
 8003d9e:	d000      	beq.n	8003da2 <chEvtSignalI+0x12>
 8003da0:	4770      	bx	lr
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8003da2:	6a03      	ldr	r3, [r0, #32]
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8003da4:	438b      	bics	r3, r1
 8003da6:	d1fb      	bne.n	8003da0 <chEvtSignalI+0x10>
    tp->p_u.rdymsg = MSG_OK;
 8003da8:	2300      	movs	r3, #0
 8003daa:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8003dac:	f7ff be30 	b.w	8003a10 <chSchReadyI>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8003db0:	6a03      	ldr	r3, [r0, #32]
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8003db2:	4219      	tst	r1, r3
 8003db4:	d1f8      	bne.n	8003da8 <chEvtSignalI+0x18>
 8003db6:	4770      	bx	lr
	...

08003dc0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 8003dc0:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8003dc2:	4b10      	ldr	r3, [pc, #64]	; (8003e04 <chEvtWaitAnyTimeout+0x44>)
 8003dc4:	699e      	ldr	r6, [r3, #24]
 8003dc6:	2320      	movs	r3, #32
 8003dc8:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8003dcc:	6b73      	ldr	r3, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8003dce:	ea13 0500 	ands.w	r5, r3, r0
 8003dd2:	d10e      	bne.n	8003df2 <chEvtWaitAnyTimeout+0x32>
    if (TIME_IMMEDIATE == time) {
 8003dd4:	b919      	cbnz	r1, 8003dde <chEvtWaitAnyTimeout+0x1e>
 8003dd6:	f385 8811 	msr	BASEPRI, r5
  }
  ctp->p_epending &= ~m;
  chSysUnlock();

  return m;
}
 8003dda:	4628      	mov	r0, r5
 8003ddc:	bd70      	pop	{r4, r5, r6, pc}
    ctp->p_u.ewmask = events;
 8003dde:	6230      	str	r0, [r6, #32]
 8003de0:	4604      	mov	r4, r0
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8003de2:	200a      	movs	r0, #10
 8003de4:	f7ff fe44 	bl	8003a70 <chSchGoSleepTimeoutS>
 8003de8:	2800      	cmp	r0, #0
 8003dea:	dbf4      	blt.n	8003dd6 <chEvtWaitAnyTimeout+0x16>
    m = ctp->p_epending & events;
 8003dec:	6b73      	ldr	r3, [r6, #52]	; 0x34
 8003dee:	ea04 0503 	and.w	r5, r4, r3
  ctp->p_epending &= ~m;
 8003df2:	ea23 0305 	bic.w	r3, r3, r5
 8003df6:	6373      	str	r3, [r6, #52]	; 0x34
 8003df8:	2300      	movs	r3, #0
 8003dfa:	f383 8811 	msr	BASEPRI, r3
}
 8003dfe:	4628      	mov	r0, r5
 8003e00:	bd70      	pop	{r4, r5, r6, pc}
 8003e02:	bf00      	nop
 8003e04:	200012e0 	.word	0x200012e0
	...

08003e10 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003e10:	4a05      	ldr	r2, [pc, #20]	; (8003e28 <_core_init+0x18>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003e12:	4b06      	ldr	r3, [pc, #24]	; (8003e2c <_core_init+0x1c>)
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003e14:	4806      	ldr	r0, [pc, #24]	; (8003e30 <_core_init+0x20>)
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003e16:	4907      	ldr	r1, [pc, #28]	; (8003e34 <_core_init+0x24>)
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003e18:	f022 0207 	bic.w	r2, r2, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003e1c:	f023 0307 	bic.w	r3, r3, #7
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003e20:	6002      	str	r2, [r0, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8003e22:	600b      	str	r3, [r1, #0]
 8003e24:	4770      	bx	lr
 8003e26:	bf00      	nop
 8003e28:	200014e7 	.word	0x200014e7
 8003e2c:	20008000 	.word	0x20008000
 8003e30:	200014bc 	.word	0x200014bc
 8003e34:	200014b8 	.word	0x200014b8
	...

08003e40 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8003e40:	b410      	push	{r4}
 8003e42:	2320      	movs	r3, #32
 8003e44:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8003e48:	4c09      	ldr	r4, [pc, #36]	; (8003e70 <chCoreAlloc+0x30>)
 8003e4a:	4b0a      	ldr	r3, [pc, #40]	; (8003e74 <chCoreAlloc+0x34>)
 8003e4c:	6822      	ldr	r2, [r4, #0]
 8003e4e:	6819      	ldr	r1, [r3, #0]
  size = MEM_ALIGN_NEXT(size);
 8003e50:	1dc3      	adds	r3, r0, #7
 8003e52:	f023 0307 	bic.w	r3, r3, #7
  if ((size_t)(endmem - nextmem) < size) {
 8003e56:	1a89      	subs	r1, r1, r2
 8003e58:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8003e5a:	bf9d      	ittte	ls
 8003e5c:	189b      	addls	r3, r3, r2
 8003e5e:	6023      	strls	r3, [r4, #0]

  return p;
 8003e60:	4610      	movls	r0, r2
    return NULL;
 8003e62:	2000      	movhi	r0, #0
 8003e64:	2300      	movs	r3, #0
 8003e66:	f383 8811 	msr	BASEPRI, r3
}
 8003e6a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003e6e:	4770      	bx	lr
 8003e70:	200014bc 	.word	0x200014bc
 8003e74:	200014b8 	.word	0x200014b8
	...

08003e80 <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8003e80:	4b04      	ldr	r3, [pc, #16]	; (8003e94 <_heap_init+0x14>)
 8003e82:	4a05      	ldr	r2, [pc, #20]	; (8003e98 <_heap_init+0x18>)
 8003e84:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8003e86:	f103 0010 	add.w	r0, r3, #16
  default_heap.h_free.h.u.next = NULL;
 8003e8a:	2200      	movs	r2, #0
 8003e8c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 8003e8e:	60da      	str	r2, [r3, #12]
  chMtxObjectInit(&default_heap.h_mtx);
 8003e90:	f7ff bf76 	b.w	8003d80 <chMtxObjectInit>
 8003e94:	200014c0 	.word	0x200014c0
 8003e98:	08003e41 	.word	0x08003e41
 8003e9c:	00000000 	.word	0x00000000

08003ea0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003ea0:	b480      	push	{r7}
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8003ea2:	4a09      	ldr	r2, [pc, #36]	; (8003ec8 <SVC_Handler+0x28>)
 8003ea4:	6853      	ldr	r3, [r2, #4]
 8003ea6:	f023 0301 	bic.w	r3, r3, #1
void SVC_Handler(void) {
 8003eaa:	af00      	add	r7, sp, #0
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8003eac:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003eae:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003eb2:	3368      	adds	r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003eb4:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003eb8:	2300      	movs	r3, #0
 8003eba:	f383 8811 	msr	BASEPRI, r3
  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 8003ebe:	46bd      	mov	sp, r7
 8003ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ec4:	4770      	bx	lr
 8003ec6:	bf00      	nop
 8003ec8:	e000ef30 	.word	0xe000ef30
 8003ecc:	00000000 	.word	0x00000000

08003ed0 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003ed0:	b598      	push	{r3, r4, r7, lr}
 8003ed2:	2320      	movs	r3, #32
 8003ed4:	af00      	add	r7, sp, #0
 8003ed6:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003eda:	4b11      	ldr	r3, [pc, #68]	; (8003f20 <_port_irq_epilogue+0x50>)
 8003edc:	685b      	ldr	r3, [r3, #4]
 8003ede:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8003ee2:	d102      	bne.n	8003eea <_port_irq_epilogue+0x1a>
 8003ee4:	f383 8811 	msr	BASEPRI, r3
 8003ee8:	bd98      	pop	{r3, r4, r7, pc}
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8003eea:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003eee:	f3ef 8409 	mrs	r4, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003ef2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8003ef6:	4b0b      	ldr	r3, [pc, #44]	; (8003f24 <_port_irq_epilogue+0x54>)
    ctxp->xpsr = (regarm_t)0x01000000;
 8003ef8:	f844 2c4c 	str.w	r2, [r4, #-76]
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8003efc:	68db      	ldr	r3, [r3, #12]
 8003efe:	f844 3c08 	str.w	r3, [r4, #-8]
    ctxp--;
 8003f02:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003f06:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003f0a:	f7ff fe41 	bl	8003b90 <chSchIsPreemptionRequired>
 8003f0e:	b118      	cbz	r0, 8003f18 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003f10:	4b05      	ldr	r3, [pc, #20]	; (8003f28 <_port_irq_epilogue+0x58>)
 8003f12:	f844 3c50 	str.w	r3, [r4, #-80]
 8003f16:	bd98      	pop	{r3, r4, r7, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003f18:	4b04      	ldr	r3, [pc, #16]	; (8003f2c <_port_irq_epilogue+0x5c>)
 8003f1a:	f844 3c50 	str.w	r3, [r4, #-80]
 8003f1e:	bd98      	pop	{r3, r4, r7, pc}
 8003f20:	e000ed00 	.word	0xe000ed00
 8003f24:	e000ef30 	.word	0xe000ef30
 8003f28:	080002c9 	.word	0x080002c9
 8003f2c:	080002cc 	.word	0x080002cc

08003f30 <__core_init>:
 8003f30:	4770      	bx	lr
 8003f32:	bf00      	nop
	...

08003f40 <__early_init>:
 8003f40:	4770      	bx	lr
 8003f42:	bf00      	nop
	...

08003f50 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8003f50:	e7fe      	b.n	8003f50 <__default_exit>
 8003f52:	bf00      	nop
	...

08003f60 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003f60:	4a12      	ldr	r2, [pc, #72]	; (8003fac <__init_ram_areas+0x4c>)
 8003f62:	b430      	push	{r4, r5}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003f64:	2400      	movs	r4, #0
 8003f66:	f102 0580 	add.w	r5, r2, #128	; 0x80
    uint32_t *p = rap->init_area;
 8003f6a:	f852 3c0c 	ldr.w	r3, [r2, #-12]
    while (p < rap->clear_area) {
 8003f6e:	f852 0c08 	ldr.w	r0, [r2, #-8]
    uint32_t *tp = rap->init_text_area;
 8003f72:	f852 1c10 	ldr.w	r1, [r2, #-16]
    while (p < rap->clear_area) {
 8003f76:	4283      	cmp	r3, r0
 8003f78:	d208      	bcs.n	8003f8c <__init_ram_areas+0x2c>
 8003f7a:	3904      	subs	r1, #4
      *p = *tp;
 8003f7c:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8003f80:	f843 0b04 	str.w	r0, [r3], #4
    while (p < rap->clear_area) {
 8003f84:	f852 0c08 	ldr.w	r0, [r2, #-8]
 8003f88:	4298      	cmp	r0, r3
 8003f8a:	d8f7      	bhi.n	8003f7c <__init_ram_areas+0x1c>
    while (p < rap->no_init_area) {
 8003f8c:	f852 1c04 	ldr.w	r1, [r2, #-4]
 8003f90:	428b      	cmp	r3, r1
 8003f92:	d205      	bcs.n	8003fa0 <__init_ram_areas+0x40>
      *p = 0;
 8003f94:	f843 4b04 	str.w	r4, [r3], #4
    while (p < rap->no_init_area) {
 8003f98:	f852 1c04 	ldr.w	r1, [r2, #-4]
 8003f9c:	4299      	cmp	r1, r3
 8003f9e:	d8f9      	bhi.n	8003f94 <__init_ram_areas+0x34>
 8003fa0:	3210      	adds	r2, #16
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003fa2:	42aa      	cmp	r2, r5
 8003fa4:	d1e1      	bne.n	8003f6a <__init_ram_areas+0xa>
#endif
}
 8003fa6:	bc30      	pop	{r4, r5}
 8003fa8:	4770      	bx	lr
 8003faa:	bf00      	nop
 8003fac:	08004100 	.word	0x08004100

08003fb0 <_unhandled_exception>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8003fb0:	e7fe      	b.n	8003fb0 <_unhandled_exception>
 8003fb2:	bf00      	nop
	...

08003fc0 <_global_impure_ptr>:
 8003fc0:	0804 2000 0000 0000 0000 0000 0000 0000     ... ............

08003fd0 <__sf_fake_stderr>:
	...

08003ff0 <__sf_fake_stdout>:
	...

08004010 <__sf_fake_stdin>:
	...
 8004030:	6c62 6e69 656b 0072 6854 6572 6461 625f     blinker.Thread_b
 8004040:	696c 6b6e 7220 6e75 000a 0000 0000 0000     link run........
 8004050:	6175 7472 0000 0000 6854 6572 6461 755f     uart....Thread_u
 8004060:	7261 2074 7572 006e 7325 2520 0a64 0000     art run.%s %d...
 8004070:	6469 656c 0000 0000 7572 6e6e 6e69 2067     idle....running 
 8004080:	6425 000a 0000 0000 0000 0000 0000 0000     %d..............
 8004090:	6548 6c6c 206f 6f57 6c72 2064 0032 0000     Hello World 2...
 80040a0:	6548 6c6c 206f 6f77 6c72 2064 0a31 0000     Hello world 1...

080040b0 <flagBitshiftOffset.8223>:
 80040b0:	0600 1610 0600 1610 0000 0000 0000 0000     ................

080040c0 <APBAHBPrescTable>:
 80040c0:	0000 0000 0201 0403 0201 0403 0706 0908     ................

080040d0 <ch_debug>:
 80040d0:	616d 6e69 1600 1843 0404 0844 100c 1814     main..C...D.....
 80040e0:	1c00 1e1d 001f 0000 0000 0000 0000 0000     ................

080040f0 <ram_areas>:
 80040f0:	4230 0800 14e0 2000 14e0 2000 14e0 2000     0B..... ... ... 
 8004100:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004110:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004120:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004130:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004140:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004150:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004160:	4230 0800 0000 0000 0000 0000 0000 0000     0B..............
 8004170:	0043 0000 0000 0000 0000 0000 0000 0000     C...............
 8004180:	2d23 2b30 0020 0000 6c68 004c 6665 4567     #-0+ ...hlL.efgE
 8004190:	4746 0000 0000 0000 0000 0000 0000 0000     FG..............
 80041a0:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
 80041b0:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
 80041c0:	6463 6665 0000 0000                         cdef....
