library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.custom_types.all;

entity regfile is
generic (DATAW: positive := 4; ADDRW: positive := 3);
port (
	clk: in std_logic;
	rst: in std_logic; -- active low
	wr: in std_logic;
	wr_addr: in unsigned(ADDRW-1 downto 0);
	rd_addrA: in unsigned(ADDRW-1 downto 0);
	rd_addrB: in unsigned(ADDRW-1 downto 0);
	wr_data: in std_logic_vector(DATAW-1 downto 0);
	rd_dataA: out std_logic_vector(DATAW-1 downto 0);
	rd_dataB: out std_logic_vector(DATAW-1 downto 0)
);
end entity;

architecture behavioral of regfile is
	component reg is
	generic (W: integer := 4);
	port(
		clk: in std_logic;
		reset_n: in std_logic;
		enable: in std_logic;
		d: in std_logic_vector(W-1 downto 0);
		q: out std_logic_vector(W-1 downto 0)
	);
	end component;

	component decoder is
	generic (SELW: integer := 4);
	port (
		sel: in unsigned(SELW-1 downto 0);
		en: in std_logic;
		d: out std_logic_vector(2**SELW-1 downto 0)
	);
	end component;

	component busmux is 
	generic (DATAW: integer := 8; ADDRW: integer := 4);
	port (
		sel: in unsigned(ADDRW-1 downto 0);
		din: in bus_arr (0 to 2**ADDRW-1)(0 to DATAW-1);
		dout: out std_logic_vector(DATAW-1 downto 0)
	);
	end component;

	signal decoded_wr_addr: std_logic_vector(2**ADDRW-1 downto 0);

	-- declare an array signal of ADDRW-1 std_logic_vectors for each register
	signal qs: bus_arr (0 to 2**ADDRW-1)(0 to DATAW-1) := (others => (others => '0'));
begin
	-- map each register
	GEN: for i in 0 to 2**ADDRW-1 generate
		REG_N: reg generic map (DATAW) port map (clk, rst, decoded_wr_addr(i), wr_data, qs(i)); 
	end generate;

	-- decode wr_addr and enable one of the regisers if wr
	WR_DECODER: decoder generic map (ADDRW) port map (wr_addr, wr, decoded_wr_addr);
	
	-- select one of the register q outputs for A based on rd_dataA
	MUX_A: busmux generic map (DATAW, ADDRW) port map (rd_addrA, qs, rd_dataA)

	-- select one of the register q outputs for B based on rd_dataB
	rd_dataB <= qs(to_integer(rd_addrB));
	
end architecture;
